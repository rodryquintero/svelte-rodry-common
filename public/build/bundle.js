
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
        const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function set_store_value(store, ret, value = ret) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.38.2' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /* src\Modal\index.svelte generated by Svelte v3.38.2 */

    const file$b = "src\\Modal\\index.svelte";
    const get_footer_slot_changes = dirty => ({});
    const get_footer_slot_context = ctx => ({});
    const get_body_slot_changes = dirty => ({});
    const get_body_slot_context = ctx => ({});
    const get_title_slot_changes = dirty => ({});
    const get_title_slot_context = ctx => ({});

    // (12:0) {#if show}
    function create_if_block$4(ctx) {
    	let div9;
    	let div1;
    	let div0;
    	let t0;
    	let div8;
    	let div5;
    	let div4;
    	let div2;
    	let t1;
    	let div3;
    	let span;
    	let t3;
    	let div6;
    	let t4;
    	let div7;
    	let div8_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const title_slot_template = /*#slots*/ ctx[5].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[4], get_title_slot_context);
    	const body_slot_template = /*#slots*/ ctx[5].body;
    	const body_slot = create_slot(body_slot_template, ctx, /*$$scope*/ ctx[4], get_body_slot_context);
    	const footer_slot_template = /*#slots*/ ctx[5].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[4], get_footer_slot_context);

    	const block = {
    		c: function create() {
    			div9 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div8 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div2 = element("div");
    			if (title_slot) title_slot.c();
    			t1 = space();
    			div3 = element("div");
    			span = element("span");
    			span.textContent = "X";
    			t3 = space();
    			div6 = element("div");
    			if (body_slot) body_slot.c();
    			t4 = space();
    			div7 = element("div");
    			if (footer_slot) footer_slot.c();
    			attr_dev(div0, "class", "absolute inset-0 bg-gray-500 opacity-75");
    			add_location(div0, file$b, 17, 6, 388);
    			attr_dev(div1, "class", "fixed inset-0 transition-opacity");
    			add_location(div1, file$b, 16, 4, 334);
    			attr_dev(div2, "class", "w-11/12");
    			add_location(div2, file$b, 31, 10, 792);
    			attr_dev(span, "class", "close svelte-1stvsba");
    			add_location(span, file$b, 37, 12, 968);
    			attr_dev(div3, "class", "w-1/12 text-right close svelte-1stvsba");
    			add_location(div3, file$b, 36, 10, 917);
    			attr_dev(div4, "class", "flex");
    			add_location(div4, file$b, 30, 8, 762);
    			attr_dev(div5, "class", "bg-white px-4 pt-3");
    			add_location(div5, file$b, 28, 6, 697);
    			attr_dev(div6, "class", "bg-white px-4 pt-3 pb-3");
    			add_location(div6, file$b, 43, 6, 1091);
    			attr_dev(div7, "class", "bg-gray-300 px-4 py-3");
    			add_location(div7, file$b, 49, 6, 1228);

    			attr_dev(div8, "class", div8_class_value = "" + (null_to_empty(`bg-white rounded-lg overflow-hidden shadow-xl transform
      transition-all ${/*cssClass*/ ctx[1]}`) + " svelte-1stvsba"));

    			attr_dev(div8, "role", "dialog");
    			attr_dev(div8, "aria-modal", "true");
    			attr_dev(div8, "aria-labelledby", "modal-headline");
    			add_location(div8, file$b, 20, 4, 463);
    			set_style(div9, "z-index", "2000");
    			attr_dev(div9, "class", "fixed bottom-0 inset-x-0 px-4 pb-4 sm:inset-0 sm:flex sm:items-center\r\n    sm:justify-center");
    			add_location(div9, file$b, 12, 2, 191);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div1);
    			append_dev(div1, div0);
    			append_dev(div9, t0);
    			append_dev(div9, div8);
    			append_dev(div8, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div2);

    			if (title_slot) {
    				title_slot.m(div2, null);
    			}

    			append_dev(div4, t1);
    			append_dev(div4, div3);
    			append_dev(div3, span);
    			append_dev(div8, t3);
    			append_dev(div8, div6);

    			if (body_slot) {
    				body_slot.m(div6, null);
    			}

    			append_dev(div8, t4);
    			append_dev(div8, div7);

    			if (footer_slot) {
    				footer_slot.m(div7, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*hide*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (title_slot) {
    				if (title_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[4], dirty, get_title_slot_changes, get_title_slot_context);
    				}
    			}

    			if (body_slot) {
    				if (body_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot(body_slot, body_slot_template, ctx, /*$$scope*/ ctx[4], dirty, get_body_slot_changes, get_body_slot_context);
    				}
    			}

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[4], dirty, get_footer_slot_changes, get_footer_slot_context);
    				}
    			}

    			if (!current || dirty & /*cssClass*/ 2 && div8_class_value !== (div8_class_value = "" + (null_to_empty(`bg-white rounded-lg overflow-hidden shadow-xl transform
      transition-all ${/*cssClass*/ ctx[1]}`) + " svelte-1stvsba"))) {
    				attr_dev(div8, "class", div8_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			transition_in(body_slot, local);
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			transition_out(body_slot, local);
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div9);
    			if (title_slot) title_slot.d(detaching);
    			if (body_slot) body_slot.d(detaching);
    			if (footer_slot) footer_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(12:0) {#if show}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*show*/ ctx[0] && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*show*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*show*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Modal", slots, ['title','body','footer']);
    	let { show = false } = $$props;
    	let { cssClass = "" } = $$props;

    	let { onClose = () => {
    		
    	} } = $$props;

    	function hide() {
    		$$invalidate(0, show = false);
    		onClose();
    	}

    	const writable_props = ["show", "cssClass", "onClose"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Modal> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("show" in $$props) $$invalidate(0, show = $$props.show);
    		if ("cssClass" in $$props) $$invalidate(1, cssClass = $$props.cssClass);
    		if ("onClose" in $$props) $$invalidate(3, onClose = $$props.onClose);
    		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ show, cssClass, onClose, hide });

    	$$self.$inject_state = $$props => {
    		if ("show" in $$props) $$invalidate(0, show = $$props.show);
    		if ("cssClass" in $$props) $$invalidate(1, cssClass = $$props.cssClass);
    		if ("onClose" in $$props) $$invalidate(3, onClose = $$props.onClose);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [show, cssClass, hide, onClose, $$scope, slots];
    }

    class Modal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, { show: 0, cssClass: 1, onClose: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modal",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get show() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set show(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cssClass() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cssClass(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClose() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClose(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    const initialState = {
      currentUrl: window.location.hash,
    };

    const store = writable(initialState);

    /* src\Treeview\Item.svelte generated by Svelte v3.38.2 */
    const file$a = "src\\Treeview\\Item.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (24:0) {:else}
    function create_else_block_1$1(ctx) {
    	let a;
    	let t_value = /*item*/ ctx[0].title + "";
    	let t;
    	let a_title_value;
    	let a_href_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "class", "icon svelte-11zf6t5");
    			attr_dev(a, "title", a_title_value = `${/*item*/ ctx[0].title}`);
    			attr_dev(a, "href", a_href_value = `${/*item*/ ctx[0].url}`);
    			toggle_class(a, "active", /*$store*/ ctx[5].currentUrl == /*item*/ ctx[0].url);
    			add_location(a, file$a, 24, 2, 482);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*item*/ 1 && t_value !== (t_value = /*item*/ ctx[0].title + "")) set_data_dev(t, t_value);

    			if (dirty & /*item*/ 1 && a_title_value !== (a_title_value = `${/*item*/ ctx[0].title}`)) {
    				attr_dev(a, "title", a_title_value);
    			}

    			if (dirty & /*item*/ 1 && a_href_value !== (a_href_value = `${/*item*/ ctx[0].url}`)) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (dirty & /*$store, item*/ 33) {
    				toggle_class(a, "active", /*$store*/ ctx[5].currentUrl == /*item*/ ctx[0].url);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(24:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (16:0) {#if children}
    function create_if_block_1$1(ctx) {
    	let span;
    	let t0;
    	let t1;
    	let span_title_value;
    	let mounted;
    	let dispose;

    	function select_block_type_1(ctx, dirty) {
    		if (/*showChildren*/ ctx[2]) return create_if_block_2$1;
    		return create_else_block$1;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if_block.c();
    			t0 = space();
    			t1 = text(/*title*/ ctx[3]);
    			attr_dev(span, "class", "icon svelte-11zf6t5");
    			attr_dev(span, "title", span_title_value = `${/*title*/ ctx[3]}`);
    			add_location(span, file$a, 16, 2, 311);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if_block.m(span, null);
    			append_dev(span, t0);
    			append_dev(span, t1);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*toggleChildren*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(span, t0);
    				}
    			}

    			if (dirty & /*title*/ 8) set_data_dev(t1, /*title*/ ctx[3]);

    			if (dirty & /*title*/ 8 && span_title_value !== (span_title_value = `${/*title*/ ctx[3]}`)) {
    				attr_dev(span, "title", span_title_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(16:0) {#if children}",
    		ctx
    	});

    	return block;
    }

    // (20:4) {:else}
    function create_else_block$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("►");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(20:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (18:4) {#if showChildren}
    function create_if_block_2$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("▼");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(18:4) {#if showChildren}",
    		ctx
    	});

    	return block;
    }

    // (34:0) {#if showChildren}
    function create_if_block$3(ctx) {
    	let ul;
    	let current;
    	let each_value = /*children*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "svelte-11zf6t5");
    			add_location(ul, file$a, 34, 2, 701);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*children, onClick*/ 18) {
    				each_value = /*children*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(34:0) {#if showChildren}",
    		ctx
    	});

    	return block;
    }

    // (36:4) {#each children as child}
    function create_each_block$4(ctx) {
    	let li;
    	let item_1;
    	let t;
    	let current;

    	item_1 = new Item({
    			props: {
    				item: /*child*/ ctx[8],
    				onClick: /*onClick*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(item_1.$$.fragment);
    			t = space();
    			attr_dev(li, "class", "child svelte-11zf6t5");
    			add_location(li, file$a, 36, 6, 744);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(item_1, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const item_1_changes = {};
    			if (dirty & /*children*/ 16) item_1_changes.item = /*child*/ ctx[8];
    			if (dirty & /*onClick*/ 2) item_1_changes.onClick = /*onClick*/ ctx[1];
    			item_1.$set(item_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(item_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(item_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(item_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(36:4) {#each children as child}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;

    	function select_block_type(ctx, dirty) {
    		if (/*children*/ ctx[4]) return create_if_block_1$1;
    		return create_else_block_1$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = /*showChildren*/ ctx[2] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			}

    			if (/*showChildren*/ ctx[2]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*showChildren*/ 4) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let title;
    	let children;
    	let $store;
    	validate_store(store, "store");
    	component_subscribe($$self, store, $$value => $$invalidate(5, $store = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Item", slots, []);
    	let { item = {} } = $$props;

    	let { onClick = (e, item) => {
    		
    	} } = $$props;

    	let showChildren = false;

    	const toggleChildren = () => {
    		$$invalidate(2, showChildren = !showChildren);
    	};

    	const writable_props = ["item", "onClick"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Item> was created with unknown prop '${key}'`);
    	});

    	const click_handler = e => onClick(e, item);

    	$$self.$$set = $$props => {
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("onClick" in $$props) $$invalidate(1, onClick = $$props.onClick);
    	};

    	$$self.$capture_state = () => ({
    		store,
    		item,
    		onClick,
    		showChildren,
    		toggleChildren,
    		title,
    		children,
    		$store
    	});

    	$$self.$inject_state = $$props => {
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("onClick" in $$props) $$invalidate(1, onClick = $$props.onClick);
    		if ("showChildren" in $$props) $$invalidate(2, showChildren = $$props.showChildren);
    		if ("title" in $$props) $$invalidate(3, title = $$props.title);
    		if ("children" in $$props) $$invalidate(4, children = $$props.children);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*item*/ 1) {
    			$$invalidate(3, title = item.title);
    		}

    		if ($$self.$$.dirty & /*item*/ 1) {
    			$$invalidate(4, children = item.children);
    		}
    	};

    	return [
    		item,
    		onClick,
    		showChildren,
    		title,
    		children,
    		$store,
    		toggleChildren,
    		click_handler
    	];
    }

    class Item extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, { item: 0, onClick: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Item",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get item() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Treeview\index.svelte generated by Svelte v3.38.2 */
    const file$9 = "src\\Treeview\\index.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (24:2) {#each items as item}
    function create_each_block$3(ctx) {
    	let li;
    	let item;
    	let t;
    	let current;

    	item = new Item({
    			props: {
    				item: /*item*/ ctx[4],
    				onClick: /*onClick*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(item.$$.fragment);
    			t = space();
    			attr_dev(li, "class", "svelte-56obm");
    			add_location(li, file$9, 24, 4, 578);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(item, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const item_changes = {};
    			if (dirty & /*items*/ 1) item_changes.item = /*item*/ ctx[4];
    			if (dirty & /*onClick*/ 2) item_changes.onClick = /*onClick*/ ctx[1];
    			item.$set(item_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(item.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(item.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(item);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(24:2) {#each items as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let ul;
    	let current;
    	let each_value = /*items*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "svelte-56obm");
    			add_location(ul, file$9, 22, 0, 543);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*items, onClick*/ 3) {
    				each_value = /*items*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let $store;
    	validate_store(store, "store");
    	component_subscribe($$self, store, $$value => $$invalidate(2, $store = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Treeview", slots, []);
    	let { items = [] } = $$props;

    	let { onClick = () => {
    		
    	} } = $$props;

    	// ==================================================================
    	const onHashChange = () => {
    		set_store_value(store, $store.currentUrl = window.location.hash, $store);
    	};

    	onMount(() => {
    		window.addEventListener("hashchange", onHashChange);
    	});

    	onDestroy(() => {
    		window.removeEventListener("hashchange", onHashChange);
    	});

    	const writable_props = ["items", "onClick"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Treeview> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("items" in $$props) $$invalidate(0, items = $$props.items);
    		if ("onClick" in $$props) $$invalidate(1, onClick = $$props.onClick);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		store,
    		Item,
    		items,
    		onClick,
    		onHashChange,
    		$store
    	});

    	$$self.$inject_state = $$props => {
    		if ("items" in $$props) $$invalidate(0, items = $$props.items);
    		if ("onClick" in $$props) $$invalidate(1, onClick = $$props.onClick);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [items, onClick];
    }

    class Treeview extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { items: 0, onClick: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Treeview",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get items() {
    		throw new Error("<Treeview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<Treeview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<Treeview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<Treeview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\MultiSelect\index.svelte generated by Svelte v3.38.2 */
    const file$8 = "src\\MultiSelect\\index.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	return child_ctx;
    }

    // (91:4) {#each value as val}
    function create_each_block_1(ctx) {
    	let span;
    	let t_value = /*val*/ ctx[19] + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "" + (null_to_empty(`value ${/*className*/ ctx[6]}`) + " svelte-wsm0x7"));
    			add_location(span, file$8, 91, 6, 2053);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*value*/ 1 && t_value !== (t_value = /*val*/ ctx[19] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(91:4) {#each value as val}",
    		ctx
    	});

    	return block;
    }

    // (97:2) {#if show}
    function create_if_block$2(ctx) {
    	let div1;
    	let label0;
    	let input0;
    	let t0;
    	let div0;
    	let label1;
    	let input1;
    	let t1;
    	let small;
    	let t3;
    	let mounted;
    	let dispose;
    	let each_value = /*displayItems*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			label0 = element("label");
    			input0 = element("input");
    			t0 = space();
    			div0 = element("div");
    			label1 = element("label");
    			input1 = element("input");
    			t1 = space();
    			small = element("small");
    			small.textContent = "Select all";
    			t3 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(input0, "placeholder", "filter");
    			attr_dev(input0, "autocomplete", "off");
    			attr_dev(input0, "id", "filter");
    			attr_dev(input0, "type", "search");
    			attr_dev(input0, "class", "filter svelte-wsm0x7");
    			add_location(input0, file$8, 100, 8, 2334);
    			attr_dev(label0, "for", "filter");
    			attr_dev(label0, "class", "svelte-wsm0x7");
    			add_location(label0, file$8, 99, 6, 2304);
    			attr_dev(input1, "id", "select-all");
    			attr_dev(input1, "type", "checkbox");
    			input1.checked = /*selectAll*/ ctx[7];
    			add_location(input1, file$8, 113, 10, 2696);
    			attr_dev(small, "class", "svelte-wsm0x7");
    			add_location(small, file$8, 119, 10, 2860);
    			attr_dev(label1, "for", "select-all");
    			attr_dev(label1, "class", "svelte-wsm0x7");
    			add_location(label1, file$8, 112, 8, 2660);
    			attr_dev(div0, "class", "" + (null_to_empty(`list-actions ${/*className*/ ctx[6]}`) + " svelte-wsm0x7"));
    			add_location(div0, file$8, 110, 6, 2580);
    			attr_dev(div1, "class", "" + (null_to_empty(`${/*className*/ ctx[6]} dropdown-content`) + " svelte-wsm0x7"));
    			add_location(div1, file$8, 97, 4, 2224);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, label0);
    			append_dev(label0, input0);
    			set_input_value(input0, /*filter*/ ctx[2]);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, label1);
    			append_dev(label1, input1);
    			append_dev(label1, t1);
    			append_dev(label1, small);
    			append_dev(div1, t3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[13]),
    					listen_dev(input1, "change", /*toggleSelectAll*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*filter*/ 4) {
    				set_input_value(input0, /*filter*/ ctx[2]);
    			}

    			if (dirty & /*className, displayItems, value, name, toggleCheck*/ 1099) {
    				each_value = /*displayItems*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(97:2) {#if show}",
    		ctx
    	});

    	return block;
    }

    // (134:6) {#each displayItems as item}
    function create_each_block$2(ctx) {
    	let label;
    	let input;
    	let input_checked_value;
    	let input_value_value;
    	let input_id_value;
    	let t0;
    	let t1_value = /*item*/ ctx[16] + "";
    	let t1;
    	let t2;
    	let label_for_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			label = element("label");
    			input = element("input");
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			attr_dev(input, "class", "" + (null_to_empty(`${/*className*/ ctx[6]}`) + " svelte-wsm0x7"));
    			input.checked = input_checked_value = /*value*/ ctx[0].indexOf(/*item*/ ctx[16]) != -1;
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "name", /*name*/ ctx[1]);
    			input.value = input_value_value = /*item*/ ctx[16];
    			attr_dev(input, "id", input_id_value = `${/*item*/ ctx[16]}`);
    			add_location(input, file$8, 135, 10, 3327);
    			attr_dev(label, "class", "" + (null_to_empty(`menu-item ${/*className*/ ctx[6]}`) + " svelte-wsm0x7"));
    			attr_dev(label, "for", label_for_value = `${/*item*/ ctx[16]}`);
    			add_location(label, file$8, 134, 8, 3259);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			append_dev(label, input);
    			append_dev(label, t0);
    			append_dev(label, t1);
    			append_dev(label, t2);

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*toggleCheck*/ ctx[10], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*value, displayItems*/ 9 && input_checked_value !== (input_checked_value = /*value*/ ctx[0].indexOf(/*item*/ ctx[16]) != -1)) {
    				prop_dev(input, "checked", input_checked_value);
    			}

    			if (dirty & /*name*/ 2) {
    				attr_dev(input, "name", /*name*/ ctx[1]);
    			}

    			if (dirty & /*displayItems*/ 8 && input_value_value !== (input_value_value = /*item*/ ctx[16])) {
    				prop_dev(input, "value", input_value_value);
    			}

    			if (dirty & /*displayItems*/ 8 && input_id_value !== (input_id_value = `${/*item*/ ctx[16]}`)) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (dirty & /*displayItems*/ 8 && t1_value !== (t1_value = /*item*/ ctx[16] + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*displayItems*/ 8 && label_for_value !== (label_for_value = `${/*item*/ ctx[16]}`)) {
    				attr_dev(label, "for", label_for_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(134:6) {#each displayItems as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let div;
    	let button;
    	let span;
    	let t0;
    	let t1;
    	let t2;
    	let mounted;
    	let dispose;
    	let each_value_1 = /*value*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	let if_block = /*show*/ ctx[4] && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			span = element("span");
    			t0 = text("▼");
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			if (if_block) if_block.c();
    			attr_dev(span, "class", "" + (null_to_empty(`${/*className*/ ctx[6]}`) + " svelte-wsm0x7"));
    			set_style(span, "margin-left", "2px");
    			add_location(span, file$8, 89, 4, 1951);
    			attr_dev(button, "class", "" + (null_to_empty(`dropbtn ${/*className*/ ctx[6]}`) + " svelte-wsm0x7"));
    			attr_dev(button, "title", /*itemsTooltip*/ ctx[5]);
    			toggle_class(button, "menu-open", /*show*/ ctx[4]);
    			add_location(button, file$8, 83, 2, 1819);
    			attr_dev(div, "class", "" + (null_to_empty(`${/*className*/ ctx[6]} dropdown`) + " svelte-wsm0x7"));
    			add_location(div, file$8, 82, 0, 1778);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			append_dev(button, span);
    			append_dev(span, t0);
    			append_dev(button, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(button, null);
    			}

    			append_dev(div, t2);
    			if (if_block) if_block.m(div, null);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*trigger*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*className, value*/ 65) {
    				each_value_1 = /*value*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(button, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (dirty & /*itemsTooltip*/ 32) {
    				attr_dev(button, "title", /*itemsTooltip*/ ctx[5]);
    			}

    			if (dirty & /*show*/ 16) {
    				toggle_class(button, "menu-open", /*show*/ ctx[4]);
    			}

    			if (/*show*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let itemsTooltip;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MultiSelect", slots, []);
    	let { items = [] } = $$props;
    	let { value = [] } = $$props;
    	let { name = "" } = $$props;

    	let { onChange = () => {
    		
    	} } = $$props;

    	const className = `dropdown-${Date.now()}-${Math.random() * 100}`;

    	const onClickOutside = e => {
    		if (!e.target.className.includes(className)) {
    			$$invalidate(4, show = false);
    		}
    	};

    	onMount(() => {
    		window.addEventListener("click", onClickOutside);
    	});

    	onDestroy(() => {
    		window.removeEventListener("click", onClickOutside);
    	});

    	let filter = "";
    	let show = false;
    	let showChecked = false;
    	let selectAll = value.length == items.length ? true : false;

    	// $: selectTotal = value.length;
    	let displayItems = [];

    	// METHODS
    	// =======================================================
    	const trigger = () => {
    		$$invalidate(4, show = !show);
    	};

    	const toggleSelectAll = e => {
    		const { checked } = e.target;

    		if (checked) {
    			$$invalidate(0, value = displayItems);
    		} else {
    			$$invalidate(0, value = []);
    		}

    		onChange(value);
    	};

    	// const toggleShowChecked = (e) => {
    	//   const { checked } = e.target;
    	//   showChecked = checked;
    	// };
    	const toggleCheck = e => {
    		const { checked } = e.target;

    		if (checked) {
    			$$invalidate(0, value = [...value, e.target.value]);
    		} else {
    			$$invalidate(0, value = value.filter(d => d != e.target.value));
    		}

    		onChange(value);
    	};

    	const writable_props = ["items", "value", "name", "onChange"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MultiSelect> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		filter = this.value;
    		$$invalidate(2, filter);
    	}

    	$$self.$$set = $$props => {
    		if ("items" in $$props) $$invalidate(11, items = $$props.items);
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("name" in $$props) $$invalidate(1, name = $$props.name);
    		if ("onChange" in $$props) $$invalidate(12, onChange = $$props.onChange);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		items,
    		value,
    		name,
    		onChange,
    		className,
    		onClickOutside,
    		filter,
    		show,
    		showChecked,
    		selectAll,
    		displayItems,
    		trigger,
    		toggleSelectAll,
    		toggleCheck,
    		itemsTooltip
    	});

    	$$self.$inject_state = $$props => {
    		if ("items" in $$props) $$invalidate(11, items = $$props.items);
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("name" in $$props) $$invalidate(1, name = $$props.name);
    		if ("onChange" in $$props) $$invalidate(12, onChange = $$props.onChange);
    		if ("filter" in $$props) $$invalidate(2, filter = $$props.filter);
    		if ("show" in $$props) $$invalidate(4, show = $$props.show);
    		if ("showChecked" in $$props) $$invalidate(15, showChecked = $$props.showChecked);
    		if ("selectAll" in $$props) $$invalidate(7, selectAll = $$props.selectAll);
    		if ("displayItems" in $$props) $$invalidate(3, displayItems = $$props.displayItems);
    		if ("itemsTooltip" in $$props) $$invalidate(5, itemsTooltip = $$props.itemsTooltip);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 1) {
    			$$invalidate(5, itemsTooltip = value.length ? value.join(",") : "");
    		}

    		if ($$self.$$.dirty & /*filter, items, displayItems, value*/ 2061) {
    			{
    				$$invalidate(3, displayItems = !filter
    				? items
    				: items.filter(d => {
    						return d.toLowerCase().indexOf(filter.toLowerCase()) != -1;
    					}));

    				if (showChecked) {
    					$$invalidate(3, displayItems = displayItems.filter(d => value.indexOf(d) != -1));
    				}
    			}
    		}
    	};

    	return [
    		value,
    		name,
    		filter,
    		displayItems,
    		show,
    		itemsTooltip,
    		className,
    		selectAll,
    		trigger,
    		toggleSelectAll,
    		toggleCheck,
    		items,
    		onChange,
    		input0_input_handler
    	];
    }

    class MultiSelect extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {
    			items: 11,
    			value: 0,
    			name: 1,
    			onChange: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MultiSelect",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get items() {
    		throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onChange() {
    		throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onChange(value) {
    		throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Breadcrumbs\index.svelte generated by Svelte v3.38.2 */
    const file$7 = "src\\Breadcrumbs\\index.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (38:2) {#each items as item}
    function create_each_block$1(ctx) {
    	let li;
    	let a;
    	let t0_value = /*item*/ ctx[5].label + "";
    	let t0;
    	let a_href_value;
    	let t1;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(a, "href", a_href_value = /*item*/ ctx[5].url);
    			add_location(a, file$7, 41, 6, 1157);
    			attr_dev(li, "class", "svelte-h7f8jb");

    			toggle_class(li, "active", /*activeItem*/ ctx[2]
    			? /*activeItem*/ ctx[2] == /*item*/ ctx[5].id
    			: /*item*/ ctx[5].url == /*currentUrl*/ ctx[3]);

    			add_location(li, file$7, 38, 4, 1057);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, t0);
    			append_dev(li, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*items*/ 1 && t0_value !== (t0_value = /*item*/ ctx[5].label + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*items*/ 1 && a_href_value !== (a_href_value = /*item*/ ctx[5].url)) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (dirty & /*activeItem, items, currentUrl*/ 13) {
    				toggle_class(li, "active", /*activeItem*/ ctx[2]
    				? /*activeItem*/ ctx[2] == /*item*/ ctx[5].id
    				: /*item*/ ctx[5].url == /*currentUrl*/ ctx[3]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(38:2) {#each items as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let ul;
    	let each_value = /*items*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "breadcrumb svelte-h7f8jb");
    			attr_dev(ul, "style", /*style*/ ctx[1]);
    			add_location(ul, file$7, 36, 0, 995);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*activeItem, items, currentUrl*/ 13) {
    				each_value = /*items*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*style*/ 2) {
    				attr_dev(ul, "style", /*style*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Breadcrumbs", slots, []);
    	let { items = [] } = $$props;
    	let { style = "" } = $$props;
    	let { activeItem = "" } = $$props;
    	let currentUrl = window.location.hash;

    	const onHashChange = () => {
    		$$invalidate(3, currentUrl = window.location.hash);
    	};

    	onMount(() => {
    		window.addEventListener("hashchange", onHashChange);
    	});

    	onDestroy(() => {
    		window.removeEventListener("hashchange", onHashChange);
    	});

    	const writable_props = ["items", "style", "activeItem"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Breadcrumbs> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("items" in $$props) $$invalidate(0, items = $$props.items);
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    		if ("activeItem" in $$props) $$invalidate(2, activeItem = $$props.activeItem);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		items,
    		style,
    		activeItem,
    		currentUrl,
    		onHashChange
    	});

    	$$self.$inject_state = $$props => {
    		if ("items" in $$props) $$invalidate(0, items = $$props.items);
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    		if ("activeItem" in $$props) $$invalidate(2, activeItem = $$props.activeItem);
    		if ("currentUrl" in $$props) $$invalidate(3, currentUrl = $$props.currentUrl);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [items, style, activeItem, currentUrl];
    }

    class Breadcrumbs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, { items: 0, style: 1, activeItem: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Breadcrumbs",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get items() {
    		throw new Error("<Breadcrumbs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<Breadcrumbs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Breadcrumbs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Breadcrumbs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeItem() {
    		throw new Error("<Breadcrumbs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeItem(value) {
    		throw new Error("<Breadcrumbs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    /*!
     * html2canvas 1.0.0-rc.7 <https://html2canvas.hertzen.com>
     * Copyright (c) 2020 Niklas von Hertzen <https://hertzen.com>
     * Released under MIT License
     */

    var html2canvas = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
        module.exports = factory() ;
    }(commonjsGlobal, function () {
        /*! *****************************************************************************
        Copyright (c) Microsoft Corporation. All rights reserved.
        Licensed under the Apache License, Version 2.0 (the "License"); you may not use
        this file except in compliance with the License. You may obtain a copy of the
        License at http://www.apache.org/licenses/LICENSE-2.0

        THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
        KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
        WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
        MERCHANTABLITY OR NON-INFRINGEMENT.

        See the Apache Version 2.0 License for specific language governing permissions
        and limitations under the License.
        ***************************************************************************** */
        /* global Reflect, Promise */

        var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };

        function __extends(d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        }

        var __assign = function() {
            __assign = Object.assign || function __assign(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return __assign.apply(this, arguments);
        };

        function __awaiter(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))(function (resolve, reject) {
                function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
                function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
                function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        }

        function __generator(thisArg, body) {
            var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
            return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
            function verb(n) { return function (v) { return step([n, v]); }; }
            function step(op) {
                if (f) throw new TypeError("Generator is already executing.");
                while (_) try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                    if (y = 0, t) op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0: case 1: t = op; break;
                        case 4: _.label++; return { value: op[1], done: false };
                        case 5: _.label++; y = op[1]; op = [0]; continue;
                        case 7: op = _.ops.pop(); _.trys.pop(); continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                            if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                            if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                            if (t[2]) _.ops.pop();
                            _.trys.pop(); continue;
                    }
                    op = body.call(thisArg, _);
                } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
                if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
            }
        }

        var Bounds = /** @class */ (function () {
            function Bounds(x, y, w, h) {
                this.left = x;
                this.top = y;
                this.width = w;
                this.height = h;
            }
            Bounds.prototype.add = function (x, y, w, h) {
                return new Bounds(this.left + x, this.top + y, this.width + w, this.height + h);
            };
            Bounds.fromClientRect = function (clientRect) {
                return new Bounds(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
            };
            return Bounds;
        }());
        var parseBounds = function (node) {
            return Bounds.fromClientRect(node.getBoundingClientRect());
        };
        var parseDocumentSize = function (document) {
            var body = document.body;
            var documentElement = document.documentElement;
            if (!body || !documentElement) {
                throw new Error("Unable to get document size");
            }
            var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
            var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
            return new Bounds(0, 0, width, height);
        };

        /*
         * css-line-break 1.1.1 <https://github.com/niklasvh/css-line-break#readme>
         * Copyright (c) 2019 Niklas von Hertzen <https://hertzen.com>
         * Released under MIT License
         */
        var toCodePoints = function (str) {
            var codePoints = [];
            var i = 0;
            var length = str.length;
            while (i < length) {
                var value = str.charCodeAt(i++);
                if (value >= 0xd800 && value <= 0xdbff && i < length) {
                    var extra = str.charCodeAt(i++);
                    if ((extra & 0xfc00) === 0xdc00) {
                        codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
                    }
                    else {
                        codePoints.push(value);
                        i--;
                    }
                }
                else {
                    codePoints.push(value);
                }
            }
            return codePoints;
        };
        var fromCodePoint = function () {
            var codePoints = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                codePoints[_i] = arguments[_i];
            }
            if (String.fromCodePoint) {
                return String.fromCodePoint.apply(String, codePoints);
            }
            var length = codePoints.length;
            if (!length) {
                return '';
            }
            var codeUnits = [];
            var index = -1;
            var result = '';
            while (++index < length) {
                var codePoint = codePoints[index];
                if (codePoint <= 0xffff) {
                    codeUnits.push(codePoint);
                }
                else {
                    codePoint -= 0x10000;
                    codeUnits.push((codePoint >> 10) + 0xd800, codePoint % 0x400 + 0xdc00);
                }
                if (index + 1 === length || codeUnits.length > 0x4000) {
                    result += String.fromCharCode.apply(String, codeUnits);
                    codeUnits.length = 0;
                }
            }
            return result;
        };
        var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        // Use a lookup table to find the index.
        var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
        for (var i = 0; i < chars.length; i++) {
            lookup[chars.charCodeAt(i)] = i;
        }
        var decode = function (base64) {
            var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
            if (base64[base64.length - 1] === '=') {
                bufferLength--;
                if (base64[base64.length - 2] === '=') {
                    bufferLength--;
                }
            }
            var buffer = typeof ArrayBuffer !== 'undefined' &&
                typeof Uint8Array !== 'undefined' &&
                typeof Uint8Array.prototype.slice !== 'undefined'
                ? new ArrayBuffer(bufferLength)
                : new Array(bufferLength);
            var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
            for (i = 0; i < len; i += 4) {
                encoded1 = lookup[base64.charCodeAt(i)];
                encoded2 = lookup[base64.charCodeAt(i + 1)];
                encoded3 = lookup[base64.charCodeAt(i + 2)];
                encoded4 = lookup[base64.charCodeAt(i + 3)];
                bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
                bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
                bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
            }
            return buffer;
        };
        var polyUint16Array = function (buffer) {
            var length = buffer.length;
            var bytes = [];
            for (var i = 0; i < length; i += 2) {
                bytes.push((buffer[i + 1] << 8) | buffer[i]);
            }
            return bytes;
        };
        var polyUint32Array = function (buffer) {
            var length = buffer.length;
            var bytes = [];
            for (var i = 0; i < length; i += 4) {
                bytes.push((buffer[i + 3] << 24) | (buffer[i + 2] << 16) | (buffer[i + 1] << 8) | buffer[i]);
            }
            return bytes;
        };

        /** Shift size for getting the index-2 table offset. */
        var UTRIE2_SHIFT_2 = 5;
        /** Shift size for getting the index-1 table offset. */
        var UTRIE2_SHIFT_1 = 6 + 5;
        /**
         * Shift size for shifting left the index array values.
         * Increases possible data size with 16-bit index values at the cost
         * of compactability.
         * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
         */
        var UTRIE2_INDEX_SHIFT = 2;
        /**
         * Difference between the two shift sizes,
         * for getting an index-1 offset from an index-2 offset. 6=11-5
         */
        var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
        /**
         * The part of the index-2 table for U+D800..U+DBFF stores values for
         * lead surrogate code _units_ not code _points_.
         * Values for lead surrogate code _points_ are indexed with this portion of the table.
         * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
         */
        var UTRIE2_LSCP_INDEX_2_OFFSET = 0x10000 >> UTRIE2_SHIFT_2;
        /** Number of entries in a data block. 32=0x20 */
        var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
        /** Mask for getting the lower bits for the in-data-block offset. */
        var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
        var UTRIE2_LSCP_INDEX_2_LENGTH = 0x400 >> UTRIE2_SHIFT_2;
        /** Count the lengths of both BMP pieces. 2080=0x820 */
        var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
        /**
         * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
         * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
         */
        var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
        var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */
        /**
         * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
         * Variable length, for code points up to highStart, where the last single-value range starts.
         * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
         * (For 0x100000 supplementary code points U+10000..U+10ffff.)
         *
         * The part of the index-2 table for supplementary code points starts
         * after this index-1 table.
         *
         * Both the index-1 table and the following part of the index-2 table
         * are omitted completely if there is only BMP data.
         */
        var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
        /**
         * Number of index-1 entries for the BMP. 32=0x20
         * This part of the index-1 table is omitted from the serialized form.
         */
        var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> UTRIE2_SHIFT_1;
        /** Number of entries in an index-2 block. 64=0x40 */
        var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
        /** Mask for getting the lower bits for the in-index-2-block offset. */
        var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
        var slice16 = function (view, start, end) {
            if (view.slice) {
                return view.slice(start, end);
            }
            return new Uint16Array(Array.prototype.slice.call(view, start, end));
        };
        var slice32 = function (view, start, end) {
            if (view.slice) {
                return view.slice(start, end);
            }
            return new Uint32Array(Array.prototype.slice.call(view, start, end));
        };
        var createTrieFromBase64 = function (base64) {
            var buffer = decode(base64);
            var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
            var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
            var headerLength = 24;
            var index = slice16(view16, headerLength / 2, view32[4] / 2);
            var data = view32[5] === 2
                ? slice16(view16, (headerLength + view32[4]) / 2)
                : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
            return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);
        };
        var Trie = /** @class */ (function () {
            function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {
                this.initialValue = initialValue;
                this.errorValue = errorValue;
                this.highStart = highStart;
                this.highValueIndex = highValueIndex;
                this.index = index;
                this.data = data;
            }
            /**
             * Get the value for a code point as stored in the Trie.
             *
             * @param codePoint the code point
             * @return the value
             */
            Trie.prototype.get = function (codePoint) {
                var ix;
                if (codePoint >= 0) {
                    if (codePoint < 0x0d800 || (codePoint > 0x0dbff && codePoint <= 0x0ffff)) {
                        // Ordinary BMP code point, excluding leading surrogates.
                        // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.
                        // 16 bit data is stored in the index array itself.
                        ix = this.index[codePoint >> UTRIE2_SHIFT_2];
                        ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                        return this.data[ix];
                    }
                    if (codePoint <= 0xffff) {
                        // Lead Surrogate Code Point.  A Separate index section is stored for
                        // lead surrogate code units and code points.
                        //   The main index has the code unit data.
                        //   For this function, we need the code point data.
                        // Note: this expression could be refactored for slightly improved efficiency, but
                        //       surrogate code points will be so rare in practice that it's not worth it.
                        ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + ((codePoint - 0xd800) >> UTRIE2_SHIFT_2)];
                        ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                        return this.data[ix];
                    }
                    if (codePoint < this.highStart) {
                        // Supplemental code point, use two-level lookup.
                        ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
                        ix = this.index[ix];
                        ix += (codePoint >> UTRIE2_SHIFT_2) & UTRIE2_INDEX_2_MASK;
                        ix = this.index[ix];
                        ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                        return this.data[ix];
                    }
                    if (codePoint <= 0x10ffff) {
                        return this.data[this.highValueIndex];
                    }
                }
                // Fall through.  The code point is outside of the legal range of 0..0x10ffff.
                return this.errorValue;
            };
            return Trie;
        }());

        var base64 = 'KwAAAAAAAAAACA4AIDoAAPAfAAACAAAAAAAIABAAGABAAEgAUABYAF4AZgBeAGYAYABoAHAAeABeAGYAfACEAIAAiACQAJgAoACoAK0AtQC9AMUAXgBmAF4AZgBeAGYAzQDVAF4AZgDRANkA3gDmAOwA9AD8AAQBDAEUARoBIgGAAIgAJwEvATcBPwFFAU0BTAFUAVwBZAFsAXMBewGDATAAiwGTAZsBogGkAawBtAG8AcIBygHSAdoB4AHoAfAB+AH+AQYCDgIWAv4BHgImAi4CNgI+AkUCTQJTAlsCYwJrAnECeQKBAk0CiQKRApkCoQKoArACuALAAsQCzAIwANQC3ALkAjAA7AL0AvwCAQMJAxADGAMwACADJgMuAzYDPgOAAEYDSgNSA1IDUgNaA1oDYANiA2IDgACAAGoDgAByA3YDfgOAAIQDgACKA5IDmgOAAIAAogOqA4AAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAK8DtwOAAIAAvwPHA88D1wPfAyAD5wPsA/QD/AOAAIAABAQMBBIEgAAWBB4EJgQuBDMEIAM7BEEEXgBJBCADUQRZBGEEaQQwADAAcQQ+AXkEgQSJBJEEgACYBIAAoASoBK8EtwQwAL8ExQSAAIAAgACAAIAAgACgAM0EXgBeAF4AXgBeAF4AXgBeANUEXgDZBOEEXgDpBPEE+QQBBQkFEQUZBSEFKQUxBTUFPQVFBUwFVAVcBV4AYwVeAGsFcwV7BYMFiwWSBV4AmgWgBacFXgBeAF4AXgBeAKsFXgCyBbEFugW7BcIFwgXIBcIFwgXQBdQF3AXkBesF8wX7BQMGCwYTBhsGIwYrBjMGOwZeAD8GRwZNBl4AVAZbBl4AXgBeAF4AXgBeAF4AXgBeAF4AXgBeAGMGXgBqBnEGXgBeAF4AXgBeAF4AXgBeAF4AXgB5BoAG4wSGBo4GkwaAAIADHgR5AF4AXgBeAJsGgABGA4AAowarBrMGswagALsGwwbLBjAA0wbaBtoG3QbaBtoG2gbaBtoG2gblBusG8wb7BgMHCwcTBxsHCwcjBysHMAc1BzUHOgdCB9oGSgdSB1oHYAfaBloHaAfaBlIH2gbaBtoG2gbaBtoG2gbaBjUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHbQdeAF4ANQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQd1B30HNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B4MH2gaKB68EgACAAIAAgACAAIAAgACAAI8HlwdeAJ8HpweAAIAArwe3B14AXgC/B8UHygcwANAH2AfgB4AA6AfwBz4B+AcACFwBCAgPCBcIogEYAR8IJwiAAC8INwg/CCADRwhPCFcIXwhnCEoDGgSAAIAAgABvCHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIhAiLCI4IMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAANQc1BzUHNQc1BzUHNQc1BzUHNQc1B54INQc1B6II2gaqCLIIugiAAIAAvgjGCIAAgACAAIAAgACAAIAAgACAAIAAywiHAYAA0wiAANkI3QjlCO0I9Aj8CIAAgACAAAIJCgkSCRoJIgknCTYHLwk3CZYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiAAIAAAAFAAXgBeAGAAcABeAHwAQACQAKAArQC9AJ4AXgBeAE0A3gBRAN4A7AD8AMwBGgEAAKcBNwEFAUwBXAF4QkhCmEKnArcCgAHHAsABz4LAAcABwAHAAd+C6ABoAG+C/4LAAcABwAHAAc+DF4MAAcAB54M3gweDV4Nng3eDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEeDqABVg6WDqABoQ6gAaABoAHXDvcONw/3DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DncPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB7cPPwlGCU4JMACAAIAAgABWCV4JYQmAAGkJcAl4CXwJgAkwADAAMAAwAIgJgACLCZMJgACZCZ8JowmrCYAAswkwAF4AXgB8AIAAuwkABMMJyQmAAM4JgADVCTAAMAAwADAAgACAAIAAgACAAIAAgACAAIAAqwYWBNkIMAAwADAAMADdCeAJ6AnuCR4E9gkwAP4JBQoNCjAAMACAABUK0wiAAB0KJAosCjQKgAAwADwKQwqAAEsKvQmdCVMKWwowADAAgACAALcEMACAAGMKgABrCjAAMAAwADAAMAAwADAAMAAwADAAMAAeBDAAMAAwADAAMAAwADAAMAAwADAAMAAwAIkEPQFzCnoKiQSCCooKkAqJBJgKoAqkCokEGAGsCrQKvArBCjAAMADJCtEKFQHZCuEK/gHpCvEKMAAwADAAMACAAIwE+QowAIAAPwEBCzAAMAAwADAAMACAAAkLEQswAIAAPwEZCyELgAAOCCkLMAAxCzkLMAAwADAAMAAwADAAXgBeAEELMAAwADAAMAAwADAAMAAwAEkLTQtVC4AAXAtkC4AAiQkwADAAMAAwADAAMAAwADAAbAtxC3kLgAuFC4sLMAAwAJMLlwufCzAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAApwswADAAMACAAIAAgACvC4AAgACAAIAAgACAALcLMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAvwuAAMcLgACAAIAAgACAAIAAyguAAIAAgACAAIAA0QswADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAANkLgACAAIAA4AswADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACJCR4E6AswADAAhwHwC4AA+AsADAgMEAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMACAAIAAGAwdDCUMMAAwAC0MNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQw1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHPQwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADUHNQc1BzUHNQc1BzUHNQc2BzAAMAA5DDUHNQc1BzUHNQc1BzUHNQc1BzUHNQdFDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAgACAAIAATQxSDFoMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAF4AXgBeAF4AXgBeAF4AYgxeAGoMXgBxDHkMfwxeAIUMXgBeAI0MMAAwADAAMAAwAF4AXgCVDJ0MMAAwADAAMABeAF4ApQxeAKsMswy7DF4Awgy9DMoMXgBeAF4AXgBeAF4AXgBeAF4AXgDRDNkMeQBqCeAM3Ax8AOYM7Az0DPgMXgBeAF4AXgBeAF4AXgBeAF4AXgBeAF4AXgBeAF4AXgCgAAANoAAHDQ4NFg0wADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAeDSYNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIAAgACAAIAAgACAAC4NMABeAF4ANg0wADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAD4NRg1ODVYNXg1mDTAAbQ0wADAAMAAwADAAMAAwADAA2gbaBtoG2gbaBtoG2gbaBnUNeg3CBYANwgWFDdoGjA3aBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gaUDZwNpA2oDdoG2gawDbcNvw3HDdoG2gbPDdYN3A3fDeYN2gbsDfMN2gbaBvoN/g3aBgYODg7aBl4AXgBeABYOXgBeACUG2gYeDl4AJA5eACwO2w3aBtoGMQ45DtoG2gbaBtoGQQ7aBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gZJDjUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B1EO2gY1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQdZDjUHNQc1BzUHNQc1B2EONQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHaA41BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B3AO2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gY1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B2EO2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gZJDtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBkkOeA6gAKAAoAAwADAAMAAwAKAAoACgAKAAoACgAKAAgA4wADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAD//wQABAAEAAQABAAEAAQABAAEAA0AAwABAAEAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAKABMAFwAeABsAGgAeABcAFgASAB4AGwAYAA8AGAAcAEsASwBLAEsASwBLAEsASwBLAEsAGAAYAB4AHgAeABMAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAFgAbABIAHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYADQARAB4ABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkAFgAaABsAGwAbAB4AHQAdAB4ATwAXAB4ADQAeAB4AGgAbAE8ATwAOAFAAHQAdAB0ATwBPABcATwBPAE8AFgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwArAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAAQABAANAA0ASwBLAEsASwBLAEsASwBLAEsASwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUAArACsABABQAAQABAAEAAQABAAEAAQAKwArAAQABAArACsABAAEAAQAUAArACsAKwArACsAKwArACsABAArACsAKwArAFAAUAArAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAGgAaAFAAUABQAFAAUABMAB4AGwBQAB4AKwArACsABAAEAAQAKwBQAFAAUABQAFAAUAArACsAKwArAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUAArAFAAUAArACsABAArAAQABAAEAAQABAArACsAKwArAAQABAArACsABAAEAAQAKwArACsABAArACsAKwArACsAKwArAFAAUABQAFAAKwBQACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwAEAAQAUABQAFAABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUAArACsABABQAAQABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQAKwArAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwAeABsAKwArACsAKwArACsAKwBQAAQABAAEAAQABAAEACsABAAEAAQAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwArAAQABAArACsABAAEAAQAKwArACsAKwArACsAKwArAAQABAArACsAKwArAFAAUAArAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwAeAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwAEAFAAKwBQAFAAUABQAFAAUAArACsAKwBQAFAAUAArAFAAUABQAFAAKwArACsAUABQACsAUAArAFAAUAArACsAKwBQAFAAKwArACsAUABQAFAAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQAKwArACsABAAEAAQAKwAEAAQABAAEACsAKwBQACsAKwArACsAKwArAAQAKwArACsAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAB4AHgAeAB4AHgAeABsAHgArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABAArACsAKwArACsAKwArAAQABAArAFAAUABQACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAB4AUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABAArACsAKwArACsAKwArAAQABAArACsAKwArACsAKwArAFAAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwArAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAKwBcAFwAKwBcACsAKwBcACsAKwArACsAKwArAFwAXABcAFwAKwBcAFwAXABcAFwAXABcACsAXABcAFwAKwBcACsAXAArACsAXABcACsAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgArACoAKgBcACsAKwBcAFwAXABcAFwAKwBcACsAKgAqACoAKgAqACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAFwAXABcAFwAUAAOAA4ADgAOAB4ADgAOAAkADgAOAA0ACQATABMAEwATABMACQAeABMAHgAeAB4ABAAEAB4AHgAeAB4AHgAeAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUAANAAQAHgAEAB4ABAAWABEAFgARAAQABABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAAQABAAEAAQABAANAAQABABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsADQANAB4AHgAeAB4AHgAeAAQAHgAeAB4AHgAeAB4AKwAeAB4ADgAOAA0ADgAeAB4AHgAeAB4ACQAJACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgAeAB4AHgBcAFwAXABcAFwAXAAqACoAKgAqAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAKgAqACoAKgAqACoAKgBcAFwAXAAqACoAKgAqAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAXAAqAEsASwBLAEsASwBLAEsASwBLAEsAKgAqACoAKgAqACoAUABQAFAAUABQAFAAKwBQACsAKwArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQACsAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwAEAAQABAAeAA0AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAEQArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAADQANAA0AUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAA0ADQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoADQANABUAXAANAB4ADQAbAFwAKgArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAB4AHgATABMADQANAA4AHgATABMAHgAEAAQABAAJACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAUABQAFAAUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwAeACsAKwArABMAEwBLAEsASwBLAEsASwBLAEsASwBLAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwBcAFwAXABcAFwAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcACsAKwArACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwAeAB4AXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgArACsABABLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKgAqACoAKgAqACoAKgBcACoAKgAqACoAKgAqACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAUABQAFAAUABQAFAAUAArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4ADQANAA0ADQAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAHgAeAB4AHgBQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwANAA0ADQANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwBQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsABAAEAAQAHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAABABQAFAAUABQAAQABAAEAFAAUAAEAAQABAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAKwBQACsAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAKwArAB4AHgAeAB4AHgAeACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAUABQAFAAKwAeAB4AHgAeAB4AHgAeAA4AHgArAA0ADQANAA0ADQANAA0ACQANAA0ADQAIAAQACwAEAAQADQAJAA0ADQAMAB0AHQAeABcAFwAWABcAFwAXABYAFwAdAB0AHgAeABQAFAAUAA0AAQABAAQABAAEAAQABAAJABoAGgAaABoAGgAaABoAGgAeABcAFwAdABUAFQAeAB4AHgAeAB4AHgAYABYAEQAVABUAFQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgANAB4ADQANAA0ADQAeAA0ADQANAAcAHgAeAB4AHgArAAQABAAEAAQABAAEAAQABAAEAAQAUABQACsAKwBPAFAAUABQAFAAUAAeAB4AHgAWABEATwBQAE8ATwBPAE8AUABQAFAAUABQAB4AHgAeABYAEQArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAGwAbABsAGwAbABsAGwAaABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAaABsAGwAbABsAGgAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgBQABoAHgAdAB4AUAAeABoAHgAeAB4AHgAeAB4AHgAeAB4ATwAeAFAAGwAeAB4AUABQAFAAUABQAB4AHgAeAB0AHQAeAFAAHgBQAB4AUAAeAFAATwBQAFAAHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AUABQAFAAUABPAE8AUABQAFAAUABQAE8AUABQAE8AUABPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAE8ATwBPAE8ATwBPAE8ATwBPAE8AUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAATwAeAB4AKwArACsAKwAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB0AHQAeAB4AHgAdAB0AHgAeAB0AHgAeAB4AHQAeAB0AGwAbAB4AHQAeAB4AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB0AHgAdAB4AHQAdAB0AHQAdAB0AHgAdAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAdAB0AHQAdAB4AHgAdAB0AHgAeAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABQAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAlACUAHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBQAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAeAB4AHgAeAB0AHQAeAB4AHgAeAB0AHQAdAB4AHgAdAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB0AHQAeAB4AHQAeAB4AHgAeAB0AHQAeAB4AHgAeACUAJQAdAB0AJQAeACUAJQAlACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAHgAeAB4AHgAdAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHQAdAB0AHgAdACUAHQAdAB4AHQAdAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHQAdAB0AHQAlAB4AJQAlACUAHQAlACUAHQAdAB0AJQAlAB0AHQAlAB0AHQAlACUAJQAeAB0AHgAeAB4AHgAdAB0AJQAdAB0AHQAdAB0AHQAlACUAJQAlACUAHQAlACUAIAAlAB0AHQAlACUAJQAlACUAJQAlACUAHgAeAB4AJQAlACAAIAAgACAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeABcAFwAXABcAFwAXAB4AEwATACUAHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwArACUAJQBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAKwArACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAE8ATwBPAE8ATwBPAE8ATwAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeACsAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUAArACsAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQBQAFAAUABQACsAKwArACsAUABQAFAAUABQAFAAUABQAA0AUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQACsAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgBQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAABAAEAAQAKwAEAAQAKwArACsAKwArAAQABAAEAAQAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsABAAEAAQAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsADQANAA0ADQANAA0ADQANAB4AKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AUABQAFAAUABQAFAAUABQAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAUABQAFAAUABQAA0ADQANAA0ADQANABQAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwANAA0ADQANAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAeAAQABAAEAB4AKwArAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLACsADQArAB4AKwArAAQABAAEAAQAUABQAB4AUAArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwAEAAQABAAEAAQABAAEAAQABAAOAA0ADQATABMAHgAeAB4ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0AUABQAFAAUAAEAAQAKwArAAQADQANAB4AUAArACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXABcAA0ADQANACoASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUAArACsAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANACsADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEcARwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQACsAKwAeAAQABAANAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAEAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUAArACsAUAArACsAUABQACsAKwBQAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AKwArAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAeAB4ADQANAA0ADQAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAArAAQABAArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAEAAQABAAEAAQABAAEACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAFgAWAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAKwBQACsAKwArACsAKwArAFAAKwArACsAKwBQACsAUAArAFAAKwBQAFAAUAArAFAAUAArAFAAKwArAFAAKwBQACsAUAArAFAAKwBQACsAUABQACsAUAArACsAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAUABQAFAAUAArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUAArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAlACUAJQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeACUAJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeACUAJQAlACUAJQAeACUAJQAlACUAJQAgACAAIAAlACUAIAAlACUAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIQAhACEAIQAhACUAJQAgACAAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAgACAAIAAlACUAJQAlACAAJQAgACAAIAAgACAAIAAgACAAIAAlACUAJQAgACUAJQAlACUAIAAgACAAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeACUAHgAlAB4AJQAlACUAJQAlACAAJQAlACUAJQAeACUAHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAgACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAlACUAJQAlACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAIAAgACAAJQAlACUAIAAgACAAIAAgAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFwAXABcAFQAVABUAHgAeAB4AHgAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAgACAAJQAlACUAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAlACAAIAAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsA';

        /* @flow */
        var LETTER_NUMBER_MODIFIER = 50;
        // Non-tailorable Line Breaking Classes
        var BK = 1; //  Cause a line break (after)
        var CR = 2; //  Cause a line break (after), except between CR and LF
        var LF = 3; //  Cause a line break (after)
        var CM = 4; //  Prohibit a line break between the character and the preceding character
        var NL = 5; //  Cause a line break (after)
        var WJ = 7; //  Prohibit line breaks before and after
        var ZW = 8; //  Provide a break opportunity
        var GL = 9; //  Prohibit line breaks before and after
        var SP = 10; // Enable indirect line breaks
        var ZWJ = 11; // Prohibit line breaks within joiner sequences
        // Break Opportunities
        var B2 = 12; //  Provide a line break opportunity before and after the character
        var BA = 13; //  Generally provide a line break opportunity after the character
        var BB = 14; //  Generally provide a line break opportunity before the character
        var HY = 15; //  Provide a line break opportunity after the character, except in numeric context
        var CB = 16; //   Provide a line break opportunity contingent on additional information
        // Characters Prohibiting Certain Breaks
        var CL = 17; //  Prohibit line breaks before
        var CP = 18; //  Prohibit line breaks before
        var EX = 19; //  Prohibit line breaks before
        var IN = 20; //  Allow only indirect line breaks between pairs
        var NS = 21; //  Allow only indirect line breaks before
        var OP = 22; //  Prohibit line breaks after
        var QU = 23; //  Act like they are both opening and closing
        // Numeric Context
        var IS = 24; //  Prevent breaks after any and before numeric
        var NU = 25; //  Form numeric expressions for line breaking purposes
        var PO = 26; //  Do not break following a numeric expression
        var PR = 27; //  Do not break in front of a numeric expression
        var SY = 28; //  Prevent a break before; and allow a break after
        // Other Characters
        var AI = 29; //  Act like AL when the resolvedEAW is N; otherwise; act as ID
        var AL = 30; //  Are alphabetic characters or symbols that are used with alphabetic characters
        var CJ = 31; //  Treat as NS or ID for strict or normal breaking.
        var EB = 32; //  Do not break from following Emoji Modifier
        var EM = 33; //  Do not break from preceding Emoji Base
        var H2 = 34; //  Form Korean syllable blocks
        var H3 = 35; //  Form Korean syllable blocks
        var HL = 36; //  Do not break around a following hyphen; otherwise act as Alphabetic
        var ID = 37; //  Break before or after; except in some numeric context
        var JL = 38; //  Form Korean syllable blocks
        var JV = 39; //  Form Korean syllable blocks
        var JT = 40; //  Form Korean syllable blocks
        var RI = 41; //  Keep pairs together. For pairs; break before and after other classes
        var SA = 42; //  Provide a line break opportunity contingent on additional, language-specific context analysis
        var XX = 43; //  Have as yet unknown line breaking behavior or unassigned code positions
        var BREAK_MANDATORY = '!';
        var BREAK_NOT_ALLOWED = '×';
        var BREAK_ALLOWED = '÷';
        var UnicodeTrie = createTrieFromBase64(base64);
        var ALPHABETICS = [AL, HL];
        var HARD_LINE_BREAKS = [BK, CR, LF, NL];
        var SPACE = [SP, ZW];
        var PREFIX_POSTFIX = [PR, PO];
        var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE);
        var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
        var HYPHEN = [HY, BA];
        var codePointsToCharacterClasses = function (codePoints, lineBreak) {
            if (lineBreak === void 0) { lineBreak = 'strict'; }
            var types = [];
            var indicies = [];
            var categories = [];
            codePoints.forEach(function (codePoint, index) {
                var classType = UnicodeTrie.get(codePoint);
                if (classType > LETTER_NUMBER_MODIFIER) {
                    categories.push(true);
                    classType -= LETTER_NUMBER_MODIFIER;
                }
                else {
                    categories.push(false);
                }
                if (['normal', 'auto', 'loose'].indexOf(lineBreak) !== -1) {
                    // U+2010, – U+2013, 〜 U+301C, ゠ U+30A0
                    if ([0x2010, 0x2013, 0x301c, 0x30a0].indexOf(codePoint) !== -1) {
                        indicies.push(index);
                        return types.push(CB);
                    }
                }
                if (classType === CM || classType === ZWJ) {
                    // LB10 Treat any remaining combining mark or ZWJ as AL.
                    if (index === 0) {
                        indicies.push(index);
                        return types.push(AL);
                    }
                    // LB9 Do not break a combining character sequence; treat it as if it has the line breaking class of
                    // the base character in all of the following rules. Treat ZWJ as if it were CM.
                    var prev = types[index - 1];
                    if (LINE_BREAKS.indexOf(prev) === -1) {
                        indicies.push(indicies[index - 1]);
                        return types.push(prev);
                    }
                    indicies.push(index);
                    return types.push(AL);
                }
                indicies.push(index);
                if (classType === CJ) {
                    return types.push(lineBreak === 'strict' ? NS : ID);
                }
                if (classType === SA) {
                    return types.push(AL);
                }
                if (classType === AI) {
                    return types.push(AL);
                }
                // For supplementary characters, a useful default is to treat characters in the range 10000..1FFFD as AL
                // and characters in the ranges 20000..2FFFD and 30000..3FFFD as ID, until the implementation can be revised
                // to take into account the actual line breaking properties for these characters.
                if (classType === XX) {
                    if ((codePoint >= 0x20000 && codePoint <= 0x2fffd) || (codePoint >= 0x30000 && codePoint <= 0x3fffd)) {
                        return types.push(ID);
                    }
                    else {
                        return types.push(AL);
                    }
                }
                types.push(classType);
            });
            return [indicies, types, categories];
        };
        var isAdjacentWithSpaceIgnored = function (a, b, currentIndex, classTypes) {
            var current = classTypes[currentIndex];
            if (Array.isArray(a) ? a.indexOf(current) !== -1 : a === current) {
                var i = currentIndex;
                while (i <= classTypes.length) {
                    i++;
                    var next = classTypes[i];
                    if (next === b) {
                        return true;
                    }
                    if (next !== SP) {
                        break;
                    }
                }
            }
            if (current === SP) {
                var i = currentIndex;
                while (i > 0) {
                    i--;
                    var prev = classTypes[i];
                    if (Array.isArray(a) ? a.indexOf(prev) !== -1 : a === prev) {
                        var n = currentIndex;
                        while (n <= classTypes.length) {
                            n++;
                            var next = classTypes[n];
                            if (next === b) {
                                return true;
                            }
                            if (next !== SP) {
                                break;
                            }
                        }
                    }
                    if (prev !== SP) {
                        break;
                    }
                }
            }
            return false;
        };
        var previousNonSpaceClassType = function (currentIndex, classTypes) {
            var i = currentIndex;
            while (i >= 0) {
                var type = classTypes[i];
                if (type === SP) {
                    i--;
                }
                else {
                    return type;
                }
            }
            return 0;
        };
        var _lineBreakAtIndex = function (codePoints, classTypes, indicies, index, forbiddenBreaks) {
            if (indicies[index] === 0) {
                return BREAK_NOT_ALLOWED;
            }
            var currentIndex = index - 1;
            if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
                return BREAK_NOT_ALLOWED;
            }
            var beforeIndex = currentIndex - 1;
            var afterIndex = currentIndex + 1;
            var current = classTypes[currentIndex];
            // LB4 Always break after hard line breaks.
            // LB5 Treat CR followed by LF, as well as CR, LF, and NL as hard line breaks.
            var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
            var next = classTypes[afterIndex];
            if (current === CR && next === LF) {
                return BREAK_NOT_ALLOWED;
            }
            if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
                return BREAK_MANDATORY;
            }
            // LB6 Do not break before hard line breaks.
            if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
                return BREAK_NOT_ALLOWED;
            }
            // LB7 Do not break before spaces or zero width space.
            if (SPACE.indexOf(next) !== -1) {
                return BREAK_NOT_ALLOWED;
            }
            // LB8 Break before any character following a zero-width space, even if one or more spaces intervene.
            if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
                return BREAK_ALLOWED;
            }
            // LB8a Do not break between a zero width joiner and an ideograph, emoji base or emoji modifier.
            if (UnicodeTrie.get(codePoints[currentIndex]) === ZWJ && (next === ID || next === EB || next === EM)) {
                return BREAK_NOT_ALLOWED;
            }
            // LB11 Do not break before or after Word joiner and related characters.
            if (current === WJ || next === WJ) {
                return BREAK_NOT_ALLOWED;
            }
            // LB12 Do not break after NBSP and related characters.
            if (current === GL) {
                return BREAK_NOT_ALLOWED;
            }
            // LB12a Do not break before NBSP and related characters, except after spaces and hyphens.
            if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
                return BREAK_NOT_ALLOWED;
            }
            // LB13 Do not break before ‘]’ or ‘!’ or ‘;’ or ‘/’, even after spaces.
            if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
                return BREAK_NOT_ALLOWED;
            }
            // LB14 Do not break after ‘[’, even after spaces.
            if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
                return BREAK_NOT_ALLOWED;
            }
            // LB15 Do not break within ‘”[’, even with intervening spaces.
            if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
                return BREAK_NOT_ALLOWED;
            }
            // LB16 Do not break between closing punctuation and a nonstarter (lb=NS), even with intervening spaces.
            if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
                return BREAK_NOT_ALLOWED;
            }
            // LB17 Do not break within ‘——’, even with intervening spaces.
            if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
                return BREAK_NOT_ALLOWED;
            }
            // LB18 Break after spaces.
            if (current === SP) {
                return BREAK_ALLOWED;
            }
            // LB19 Do not break before or after quotation marks, such as ‘ ” ’.
            if (current === QU || next === QU) {
                return BREAK_NOT_ALLOWED;
            }
            // LB20 Break before and after unresolved CB.
            if (next === CB || current === CB) {
                return BREAK_ALLOWED;
            }
            // LB21 Do not break before hyphen-minus, other hyphens, fixed-width spaces, small kana, and other non-starters, or after acute accents.
            if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
                return BREAK_NOT_ALLOWED;
            }
            // LB21a Don't break after Hebrew + Hyphen.
            if (before === HL && HYPHEN.indexOf(current) !== -1) {
                return BREAK_NOT_ALLOWED;
            }
            // LB21b Don’t break between Solidus and Hebrew letters.
            if (current === SY && next === HL) {
                return BREAK_NOT_ALLOWED;
            }
            // LB22 Do not break between two ellipses, or between letters, numbers or exclamations and ellipsis.
            if (next === IN && ALPHABETICS.concat(IN, EX, NU, ID, EB, EM).indexOf(current) !== -1) {
                return BREAK_NOT_ALLOWED;
            }
            // LB23 Do not break between digits and letters.
            if ((ALPHABETICS.indexOf(next) !== -1 && current === NU) || (ALPHABETICS.indexOf(current) !== -1 && next === NU)) {
                return BREAK_NOT_ALLOWED;
            }
            // LB23a Do not break between numeric prefixes and ideographs, or between ideographs and numeric postfixes.
            if ((current === PR && [ID, EB, EM].indexOf(next) !== -1) ||
                ([ID, EB, EM].indexOf(current) !== -1 && next === PO)) {
                return BREAK_NOT_ALLOWED;
            }
            // LB24 Do not break between numeric prefix/postfix and letters, or between letters and prefix/postfix.
            if ((ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1) ||
                (PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1)) {
                return BREAK_NOT_ALLOWED;
            }
            // LB25 Do not break between the following pairs of classes relevant to numbers:
            if (
            // (PR | PO) × ( OP | HY )? NU
            ([PR, PO].indexOf(current) !== -1 &&
                (next === NU || ([OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU))) ||
                // ( OP | HY ) × NU
                ([OP, HY].indexOf(current) !== -1 && next === NU) ||
                // NU ×	(NU | SY | IS)
                (current === NU && [NU, SY, IS].indexOf(next) !== -1)) {
                return BREAK_NOT_ALLOWED;
            }
            // NU (NU | SY | IS)* × (NU | SY | IS | CL | CP)
            if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
                var prevIndex = currentIndex;
                while (prevIndex >= 0) {
                    var type = classTypes[prevIndex];
                    if (type === NU) {
                        return BREAK_NOT_ALLOWED;
                    }
                    else if ([SY, IS].indexOf(type) !== -1) {
                        prevIndex--;
                    }
                    else {
                        break;
                    }
                }
            }
            // NU (NU | SY | IS)* (CL | CP)? × (PO | PR))
            if ([PR, PO].indexOf(next) !== -1) {
                var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
                while (prevIndex >= 0) {
                    var type = classTypes[prevIndex];
                    if (type === NU) {
                        return BREAK_NOT_ALLOWED;
                    }
                    else if ([SY, IS].indexOf(type) !== -1) {
                        prevIndex--;
                    }
                    else {
                        break;
                    }
                }
            }
            // LB26 Do not break a Korean syllable.
            if ((JL === current && [JL, JV, H2, H3].indexOf(next) !== -1) ||
                ([JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1) ||
                ([JT, H3].indexOf(current) !== -1 && next === JT)) {
                return BREAK_NOT_ALLOWED;
            }
            // LB27 Treat a Korean Syllable Block the same as ID.
            if ((KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1) ||
                (KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR)) {
                return BREAK_NOT_ALLOWED;
            }
            // LB28 Do not break between alphabetics (“at”).
            if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
                return BREAK_NOT_ALLOWED;
            }
            // LB29 Do not break between numeric punctuation and alphabetics (“e.g.”).
            if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
                return BREAK_NOT_ALLOWED;
            }
            // LB30 Do not break between letters, numbers, or ordinary symbols and opening or closing parentheses.
            if ((ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP) ||
                (ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP)) {
                return BREAK_NOT_ALLOWED;
            }
            // LB30a Break between two regional indicator symbols if and only if there are an even number of regional
            // indicators preceding the position of the break.
            if (current === RI && next === RI) {
                var i = indicies[currentIndex];
                var count = 1;
                while (i > 0) {
                    i--;
                    if (classTypes[i] === RI) {
                        count++;
                    }
                    else {
                        break;
                    }
                }
                if (count % 2 !== 0) {
                    return BREAK_NOT_ALLOWED;
                }
            }
            // LB30b Do not break between an emoji base and an emoji modifier.
            if (current === EB && next === EM) {
                return BREAK_NOT_ALLOWED;
            }
            return BREAK_ALLOWED;
        };
        var cssFormattedClasses = function (codePoints, options) {
            if (!options) {
                options = { lineBreak: 'normal', wordBreak: 'normal' };
            }
            var _a = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a[0], classTypes = _a[1], isLetterNumber = _a[2];
            if (options.wordBreak === 'break-all' || options.wordBreak === 'break-word') {
                classTypes = classTypes.map(function (type) { return ([NU, AL, SA].indexOf(type) !== -1 ? ID : type); });
            }
            var forbiddenBreakpoints = options.wordBreak === 'keep-all'
                ? isLetterNumber.map(function (letterNumber, i) {
                    return letterNumber && codePoints[i] >= 0x4e00 && codePoints[i] <= 0x9fff;
                })
                : undefined;
            return [indicies, classTypes, forbiddenBreakpoints];
        };
        var Break = /** @class */ (function () {
            function Break(codePoints, lineBreak, start, end) {
                this.codePoints = codePoints;
                this.required = lineBreak === BREAK_MANDATORY;
                this.start = start;
                this.end = end;
            }
            Break.prototype.slice = function () {
                return fromCodePoint.apply(void 0, this.codePoints.slice(this.start, this.end));
            };
            return Break;
        }());
        var LineBreaker = function (str, options) {
            var codePoints = toCodePoints(str);
            var _a = cssFormattedClasses(codePoints, options), indicies = _a[0], classTypes = _a[1], forbiddenBreakpoints = _a[2];
            var length = codePoints.length;
            var lastEnd = 0;
            var nextIndex = 0;
            return {
                next: function () {
                    if (nextIndex >= length) {
                        return { done: true, value: null };
                    }
                    var lineBreak = BREAK_NOT_ALLOWED;
                    while (nextIndex < length &&
                        (lineBreak = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) ===
                            BREAK_NOT_ALLOWED) { }
                    if (lineBreak !== BREAK_NOT_ALLOWED || nextIndex === length) {
                        var value = new Break(codePoints, lineBreak, lastEnd, nextIndex);
                        lastEnd = nextIndex;
                        return { value: value, done: false };
                    }
                    return { done: true, value: null };
                },
            };
        };

        // https://www.w3.org/TR/css-syntax-3
        var TokenType;
        (function (TokenType) {
            TokenType[TokenType["STRING_TOKEN"] = 0] = "STRING_TOKEN";
            TokenType[TokenType["BAD_STRING_TOKEN"] = 1] = "BAD_STRING_TOKEN";
            TokenType[TokenType["LEFT_PARENTHESIS_TOKEN"] = 2] = "LEFT_PARENTHESIS_TOKEN";
            TokenType[TokenType["RIGHT_PARENTHESIS_TOKEN"] = 3] = "RIGHT_PARENTHESIS_TOKEN";
            TokenType[TokenType["COMMA_TOKEN"] = 4] = "COMMA_TOKEN";
            TokenType[TokenType["HASH_TOKEN"] = 5] = "HASH_TOKEN";
            TokenType[TokenType["DELIM_TOKEN"] = 6] = "DELIM_TOKEN";
            TokenType[TokenType["AT_KEYWORD_TOKEN"] = 7] = "AT_KEYWORD_TOKEN";
            TokenType[TokenType["PREFIX_MATCH_TOKEN"] = 8] = "PREFIX_MATCH_TOKEN";
            TokenType[TokenType["DASH_MATCH_TOKEN"] = 9] = "DASH_MATCH_TOKEN";
            TokenType[TokenType["INCLUDE_MATCH_TOKEN"] = 10] = "INCLUDE_MATCH_TOKEN";
            TokenType[TokenType["LEFT_CURLY_BRACKET_TOKEN"] = 11] = "LEFT_CURLY_BRACKET_TOKEN";
            TokenType[TokenType["RIGHT_CURLY_BRACKET_TOKEN"] = 12] = "RIGHT_CURLY_BRACKET_TOKEN";
            TokenType[TokenType["SUFFIX_MATCH_TOKEN"] = 13] = "SUFFIX_MATCH_TOKEN";
            TokenType[TokenType["SUBSTRING_MATCH_TOKEN"] = 14] = "SUBSTRING_MATCH_TOKEN";
            TokenType[TokenType["DIMENSION_TOKEN"] = 15] = "DIMENSION_TOKEN";
            TokenType[TokenType["PERCENTAGE_TOKEN"] = 16] = "PERCENTAGE_TOKEN";
            TokenType[TokenType["NUMBER_TOKEN"] = 17] = "NUMBER_TOKEN";
            TokenType[TokenType["FUNCTION"] = 18] = "FUNCTION";
            TokenType[TokenType["FUNCTION_TOKEN"] = 19] = "FUNCTION_TOKEN";
            TokenType[TokenType["IDENT_TOKEN"] = 20] = "IDENT_TOKEN";
            TokenType[TokenType["COLUMN_TOKEN"] = 21] = "COLUMN_TOKEN";
            TokenType[TokenType["URL_TOKEN"] = 22] = "URL_TOKEN";
            TokenType[TokenType["BAD_URL_TOKEN"] = 23] = "BAD_URL_TOKEN";
            TokenType[TokenType["CDC_TOKEN"] = 24] = "CDC_TOKEN";
            TokenType[TokenType["CDO_TOKEN"] = 25] = "CDO_TOKEN";
            TokenType[TokenType["COLON_TOKEN"] = 26] = "COLON_TOKEN";
            TokenType[TokenType["SEMICOLON_TOKEN"] = 27] = "SEMICOLON_TOKEN";
            TokenType[TokenType["LEFT_SQUARE_BRACKET_TOKEN"] = 28] = "LEFT_SQUARE_BRACKET_TOKEN";
            TokenType[TokenType["RIGHT_SQUARE_BRACKET_TOKEN"] = 29] = "RIGHT_SQUARE_BRACKET_TOKEN";
            TokenType[TokenType["UNICODE_RANGE_TOKEN"] = 30] = "UNICODE_RANGE_TOKEN";
            TokenType[TokenType["WHITESPACE_TOKEN"] = 31] = "WHITESPACE_TOKEN";
            TokenType[TokenType["EOF_TOKEN"] = 32] = "EOF_TOKEN";
        })(TokenType || (TokenType = {}));
        var FLAG_UNRESTRICTED = 1 << 0;
        var FLAG_ID = 1 << 1;
        var FLAG_INTEGER = 1 << 2;
        var FLAG_NUMBER = 1 << 3;
        var LINE_FEED = 0x000a;
        var SOLIDUS = 0x002f;
        var REVERSE_SOLIDUS = 0x005c;
        var CHARACTER_TABULATION = 0x0009;
        var SPACE$1 = 0x0020;
        var QUOTATION_MARK = 0x0022;
        var EQUALS_SIGN = 0x003d;
        var NUMBER_SIGN = 0x0023;
        var DOLLAR_SIGN = 0x0024;
        var PERCENTAGE_SIGN = 0x0025;
        var APOSTROPHE = 0x0027;
        var LEFT_PARENTHESIS = 0x0028;
        var RIGHT_PARENTHESIS = 0x0029;
        var LOW_LINE = 0x005f;
        var HYPHEN_MINUS = 0x002d;
        var EXCLAMATION_MARK = 0x0021;
        var LESS_THAN_SIGN = 0x003c;
        var GREATER_THAN_SIGN = 0x003e;
        var COMMERCIAL_AT = 0x0040;
        var LEFT_SQUARE_BRACKET = 0x005b;
        var RIGHT_SQUARE_BRACKET = 0x005d;
        var CIRCUMFLEX_ACCENT = 0x003d;
        var LEFT_CURLY_BRACKET = 0x007b;
        var QUESTION_MARK = 0x003f;
        var RIGHT_CURLY_BRACKET = 0x007d;
        var VERTICAL_LINE = 0x007c;
        var TILDE = 0x007e;
        var CONTROL = 0x0080;
        var REPLACEMENT_CHARACTER = 0xfffd;
        var ASTERISK = 0x002a;
        var PLUS_SIGN = 0x002b;
        var COMMA = 0x002c;
        var COLON = 0x003a;
        var SEMICOLON = 0x003b;
        var FULL_STOP = 0x002e;
        var NULL = 0x0000;
        var BACKSPACE = 0x0008;
        var LINE_TABULATION = 0x000b;
        var SHIFT_OUT = 0x000e;
        var INFORMATION_SEPARATOR_ONE = 0x001f;
        var DELETE = 0x007f;
        var EOF = -1;
        var ZERO = 0x0030;
        var a = 0x0061;
        var e = 0x0065;
        var f = 0x0066;
        var u = 0x0075;
        var z = 0x007a;
        var A = 0x0041;
        var E = 0x0045;
        var F = 0x0046;
        var U = 0x0055;
        var Z = 0x005a;
        var isDigit = function (codePoint) { return codePoint >= ZERO && codePoint <= 0x0039; };
        var isSurrogateCodePoint = function (codePoint) { return codePoint >= 0xd800 && codePoint <= 0xdfff; };
        var isHex = function (codePoint) {
            return isDigit(codePoint) || (codePoint >= A && codePoint <= F) || (codePoint >= a && codePoint <= f);
        };
        var isLowerCaseLetter = function (codePoint) { return codePoint >= a && codePoint <= z; };
        var isUpperCaseLetter = function (codePoint) { return codePoint >= A && codePoint <= Z; };
        var isLetter = function (codePoint) { return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint); };
        var isNonASCIICodePoint = function (codePoint) { return codePoint >= CONTROL; };
        var isWhiteSpace = function (codePoint) {
            return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE$1;
        };
        var isNameStartCodePoint = function (codePoint) {
            return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
        };
        var isNameCodePoint = function (codePoint) {
            return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
        };
        var isNonPrintableCodePoint = function (codePoint) {
            return ((codePoint >= NULL && codePoint <= BACKSPACE) ||
                codePoint === LINE_TABULATION ||
                (codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE) ||
                codePoint === DELETE);
        };
        var isValidEscape = function (c1, c2) {
            if (c1 !== REVERSE_SOLIDUS) {
                return false;
            }
            return c2 !== LINE_FEED;
        };
        var isIdentifierStart = function (c1, c2, c3) {
            if (c1 === HYPHEN_MINUS) {
                return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
            }
            else if (isNameStartCodePoint(c1)) {
                return true;
            }
            else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
                return true;
            }
            return false;
        };
        var isNumberStart = function (c1, c2, c3) {
            if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
                if (isDigit(c2)) {
                    return true;
                }
                return c2 === FULL_STOP && isDigit(c3);
            }
            if (c1 === FULL_STOP) {
                return isDigit(c2);
            }
            return isDigit(c1);
        };
        var stringToNumber = function (codePoints) {
            var c = 0;
            var sign = 1;
            if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
                if (codePoints[c] === HYPHEN_MINUS) {
                    sign = -1;
                }
                c++;
            }
            var integers = [];
            while (isDigit(codePoints[c])) {
                integers.push(codePoints[c++]);
            }
            var int = integers.length ? parseInt(fromCodePoint.apply(void 0, integers), 10) : 0;
            if (codePoints[c] === FULL_STOP) {
                c++;
            }
            var fraction = [];
            while (isDigit(codePoints[c])) {
                fraction.push(codePoints[c++]);
            }
            var fracd = fraction.length;
            var frac = fracd ? parseInt(fromCodePoint.apply(void 0, fraction), 10) : 0;
            if (codePoints[c] === E || codePoints[c] === e) {
                c++;
            }
            var expsign = 1;
            if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
                if (codePoints[c] === HYPHEN_MINUS) {
                    expsign = -1;
                }
                c++;
            }
            var exponent = [];
            while (isDigit(codePoints[c])) {
                exponent.push(codePoints[c++]);
            }
            var exp = exponent.length ? parseInt(fromCodePoint.apply(void 0, exponent), 10) : 0;
            return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
        };
        var LEFT_PARENTHESIS_TOKEN = {
            type: TokenType.LEFT_PARENTHESIS_TOKEN
        };
        var RIGHT_PARENTHESIS_TOKEN = {
            type: TokenType.RIGHT_PARENTHESIS_TOKEN
        };
        var COMMA_TOKEN = { type: TokenType.COMMA_TOKEN };
        var SUFFIX_MATCH_TOKEN = { type: TokenType.SUFFIX_MATCH_TOKEN };
        var PREFIX_MATCH_TOKEN = { type: TokenType.PREFIX_MATCH_TOKEN };
        var COLUMN_TOKEN = { type: TokenType.COLUMN_TOKEN };
        var DASH_MATCH_TOKEN = { type: TokenType.DASH_MATCH_TOKEN };
        var INCLUDE_MATCH_TOKEN = { type: TokenType.INCLUDE_MATCH_TOKEN };
        var LEFT_CURLY_BRACKET_TOKEN = {
            type: TokenType.LEFT_CURLY_BRACKET_TOKEN
        };
        var RIGHT_CURLY_BRACKET_TOKEN = {
            type: TokenType.RIGHT_CURLY_BRACKET_TOKEN
        };
        var SUBSTRING_MATCH_TOKEN = { type: TokenType.SUBSTRING_MATCH_TOKEN };
        var BAD_URL_TOKEN = { type: TokenType.BAD_URL_TOKEN };
        var BAD_STRING_TOKEN = { type: TokenType.BAD_STRING_TOKEN };
        var CDO_TOKEN = { type: TokenType.CDO_TOKEN };
        var CDC_TOKEN = { type: TokenType.CDC_TOKEN };
        var COLON_TOKEN = { type: TokenType.COLON_TOKEN };
        var SEMICOLON_TOKEN = { type: TokenType.SEMICOLON_TOKEN };
        var LEFT_SQUARE_BRACKET_TOKEN = {
            type: TokenType.LEFT_SQUARE_BRACKET_TOKEN
        };
        var RIGHT_SQUARE_BRACKET_TOKEN = {
            type: TokenType.RIGHT_SQUARE_BRACKET_TOKEN
        };
        var WHITESPACE_TOKEN = { type: TokenType.WHITESPACE_TOKEN };
        var EOF_TOKEN = { type: TokenType.EOF_TOKEN };
        var Tokenizer = /** @class */ (function () {
            function Tokenizer() {
                this._value = [];
            }
            Tokenizer.prototype.write = function (chunk) {
                this._value = this._value.concat(toCodePoints(chunk));
            };
            Tokenizer.prototype.read = function () {
                var tokens = [];
                var token = this.consumeToken();
                while (token !== EOF_TOKEN) {
                    tokens.push(token);
                    token = this.consumeToken();
                }
                return tokens;
            };
            Tokenizer.prototype.consumeToken = function () {
                var codePoint = this.consumeCodePoint();
                switch (codePoint) {
                    case QUOTATION_MARK:
                        return this.consumeStringToken(QUOTATION_MARK);
                    case NUMBER_SIGN:
                        var c1 = this.peekCodePoint(0);
                        var c2 = this.peekCodePoint(1);
                        var c3 = this.peekCodePoint(2);
                        if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
                            var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
                            var value = this.consumeName();
                            return { type: TokenType.HASH_TOKEN, value: value, flags: flags };
                        }
                        break;
                    case DOLLAR_SIGN:
                        if (this.peekCodePoint(0) === EQUALS_SIGN) {
                            this.consumeCodePoint();
                            return SUFFIX_MATCH_TOKEN;
                        }
                        break;
                    case APOSTROPHE:
                        return this.consumeStringToken(APOSTROPHE);
                    case LEFT_PARENTHESIS:
                        return LEFT_PARENTHESIS_TOKEN;
                    case RIGHT_PARENTHESIS:
                        return RIGHT_PARENTHESIS_TOKEN;
                    case ASTERISK:
                        if (this.peekCodePoint(0) === EQUALS_SIGN) {
                            this.consumeCodePoint();
                            return SUBSTRING_MATCH_TOKEN;
                        }
                        break;
                    case PLUS_SIGN:
                        if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                            this.reconsumeCodePoint(codePoint);
                            return this.consumeNumericToken();
                        }
                        break;
                    case COMMA:
                        return COMMA_TOKEN;
                    case HYPHEN_MINUS:
                        var e1 = codePoint;
                        var e2 = this.peekCodePoint(0);
                        var e3 = this.peekCodePoint(1);
                        if (isNumberStart(e1, e2, e3)) {
                            this.reconsumeCodePoint(codePoint);
                            return this.consumeNumericToken();
                        }
                        if (isIdentifierStart(e1, e2, e3)) {
                            this.reconsumeCodePoint(codePoint);
                            return this.consumeIdentLikeToken();
                        }
                        if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
                            this.consumeCodePoint();
                            this.consumeCodePoint();
                            return CDC_TOKEN;
                        }
                        break;
                    case FULL_STOP:
                        if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                            this.reconsumeCodePoint(codePoint);
                            return this.consumeNumericToken();
                        }
                        break;
                    case SOLIDUS:
                        if (this.peekCodePoint(0) === ASTERISK) {
                            this.consumeCodePoint();
                            while (true) {
                                var c = this.consumeCodePoint();
                                if (c === ASTERISK) {
                                    c = this.consumeCodePoint();
                                    if (c === SOLIDUS) {
                                        return this.consumeToken();
                                    }
                                }
                                if (c === EOF) {
                                    return this.consumeToken();
                                }
                            }
                        }
                        break;
                    case COLON:
                        return COLON_TOKEN;
                    case SEMICOLON:
                        return SEMICOLON_TOKEN;
                    case LESS_THAN_SIGN:
                        if (this.peekCodePoint(0) === EXCLAMATION_MARK &&
                            this.peekCodePoint(1) === HYPHEN_MINUS &&
                            this.peekCodePoint(2) === HYPHEN_MINUS) {
                            this.consumeCodePoint();
                            this.consumeCodePoint();
                            return CDO_TOKEN;
                        }
                        break;
                    case COMMERCIAL_AT:
                        var a1 = this.peekCodePoint(0);
                        var a2 = this.peekCodePoint(1);
                        var a3 = this.peekCodePoint(2);
                        if (isIdentifierStart(a1, a2, a3)) {
                            var value = this.consumeName();
                            return { type: TokenType.AT_KEYWORD_TOKEN, value: value };
                        }
                        break;
                    case LEFT_SQUARE_BRACKET:
                        return LEFT_SQUARE_BRACKET_TOKEN;
                    case REVERSE_SOLIDUS:
                        if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                            this.reconsumeCodePoint(codePoint);
                            return this.consumeIdentLikeToken();
                        }
                        break;
                    case RIGHT_SQUARE_BRACKET:
                        return RIGHT_SQUARE_BRACKET_TOKEN;
                    case CIRCUMFLEX_ACCENT:
                        if (this.peekCodePoint(0) === EQUALS_SIGN) {
                            this.consumeCodePoint();
                            return PREFIX_MATCH_TOKEN;
                        }
                        break;
                    case LEFT_CURLY_BRACKET:
                        return LEFT_CURLY_BRACKET_TOKEN;
                    case RIGHT_CURLY_BRACKET:
                        return RIGHT_CURLY_BRACKET_TOKEN;
                    case u:
                    case U:
                        var u1 = this.peekCodePoint(0);
                        var u2 = this.peekCodePoint(1);
                        if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
                            this.consumeCodePoint();
                            this.consumeUnicodeRangeToken();
                        }
                        this.reconsumeCodePoint(codePoint);
                        return this.consumeIdentLikeToken();
                    case VERTICAL_LINE:
                        if (this.peekCodePoint(0) === EQUALS_SIGN) {
                            this.consumeCodePoint();
                            return DASH_MATCH_TOKEN;
                        }
                        if (this.peekCodePoint(0) === VERTICAL_LINE) {
                            this.consumeCodePoint();
                            return COLUMN_TOKEN;
                        }
                        break;
                    case TILDE:
                        if (this.peekCodePoint(0) === EQUALS_SIGN) {
                            this.consumeCodePoint();
                            return INCLUDE_MATCH_TOKEN;
                        }
                        break;
                    case EOF:
                        return EOF_TOKEN;
                }
                if (isWhiteSpace(codePoint)) {
                    this.consumeWhiteSpace();
                    return WHITESPACE_TOKEN;
                }
                if (isDigit(codePoint)) {
                    this.reconsumeCodePoint(codePoint);
                    return this.consumeNumericToken();
                }
                if (isNameStartCodePoint(codePoint)) {
                    this.reconsumeCodePoint(codePoint);
                    return this.consumeIdentLikeToken();
                }
                return { type: TokenType.DELIM_TOKEN, value: fromCodePoint(codePoint) };
            };
            Tokenizer.prototype.consumeCodePoint = function () {
                var value = this._value.shift();
                return typeof value === 'undefined' ? -1 : value;
            };
            Tokenizer.prototype.reconsumeCodePoint = function (codePoint) {
                this._value.unshift(codePoint);
            };
            Tokenizer.prototype.peekCodePoint = function (delta) {
                if (delta >= this._value.length) {
                    return -1;
                }
                return this._value[delta];
            };
            Tokenizer.prototype.consumeUnicodeRangeToken = function () {
                var digits = [];
                var codePoint = this.consumeCodePoint();
                while (isHex(codePoint) && digits.length < 6) {
                    digits.push(codePoint);
                    codePoint = this.consumeCodePoint();
                }
                var questionMarks = false;
                while (codePoint === QUESTION_MARK && digits.length < 6) {
                    digits.push(codePoint);
                    codePoint = this.consumeCodePoint();
                    questionMarks = true;
                }
                if (questionMarks) {
                    var start_1 = parseInt(fromCodePoint.apply(void 0, digits.map(function (digit) { return (digit === QUESTION_MARK ? ZERO : digit); })), 16);
                    var end = parseInt(fromCodePoint.apply(void 0, digits.map(function (digit) { return (digit === QUESTION_MARK ? F : digit); })), 16);
                    return { type: TokenType.UNICODE_RANGE_TOKEN, start: start_1, end: end };
                }
                var start = parseInt(fromCodePoint.apply(void 0, digits), 16);
                if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
                    this.consumeCodePoint();
                    codePoint = this.consumeCodePoint();
                    var endDigits = [];
                    while (isHex(codePoint) && endDigits.length < 6) {
                        endDigits.push(codePoint);
                        codePoint = this.consumeCodePoint();
                    }
                    var end = parseInt(fromCodePoint.apply(void 0, endDigits), 16);
                    return { type: TokenType.UNICODE_RANGE_TOKEN, start: start, end: end };
                }
                else {
                    return { type: TokenType.UNICODE_RANGE_TOKEN, start: start, end: start };
                }
            };
            Tokenizer.prototype.consumeIdentLikeToken = function () {
                var value = this.consumeName();
                if (value.toLowerCase() === 'url' && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
                    this.consumeCodePoint();
                    return this.consumeUrlToken();
                }
                else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
                    this.consumeCodePoint();
                    return { type: TokenType.FUNCTION_TOKEN, value: value };
                }
                return { type: TokenType.IDENT_TOKEN, value: value };
            };
            Tokenizer.prototype.consumeUrlToken = function () {
                var value = [];
                this.consumeWhiteSpace();
                if (this.peekCodePoint(0) === EOF) {
                    return { type: TokenType.URL_TOKEN, value: '' };
                }
                var next = this.peekCodePoint(0);
                if (next === APOSTROPHE || next === QUOTATION_MARK) {
                    var stringToken = this.consumeStringToken(this.consumeCodePoint());
                    if (stringToken.type === TokenType.STRING_TOKEN) {
                        this.consumeWhiteSpace();
                        if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                            this.consumeCodePoint();
                            return { type: TokenType.URL_TOKEN, value: stringToken.value };
                        }
                    }
                    this.consumeBadUrlRemnants();
                    return BAD_URL_TOKEN;
                }
                while (true) {
                    var codePoint = this.consumeCodePoint();
                    if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
                        return { type: TokenType.URL_TOKEN, value: fromCodePoint.apply(void 0, value) };
                    }
                    else if (isWhiteSpace(codePoint)) {
                        this.consumeWhiteSpace();
                        if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                            this.consumeCodePoint();
                            return { type: TokenType.URL_TOKEN, value: fromCodePoint.apply(void 0, value) };
                        }
                        this.consumeBadUrlRemnants();
                        return BAD_URL_TOKEN;
                    }
                    else if (codePoint === QUOTATION_MARK ||
                        codePoint === APOSTROPHE ||
                        codePoint === LEFT_PARENTHESIS ||
                        isNonPrintableCodePoint(codePoint)) {
                        this.consumeBadUrlRemnants();
                        return BAD_URL_TOKEN;
                    }
                    else if (codePoint === REVERSE_SOLIDUS) {
                        if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                            value.push(this.consumeEscapedCodePoint());
                        }
                        else {
                            this.consumeBadUrlRemnants();
                            return BAD_URL_TOKEN;
                        }
                    }
                    else {
                        value.push(codePoint);
                    }
                }
            };
            Tokenizer.prototype.consumeWhiteSpace = function () {
                while (isWhiteSpace(this.peekCodePoint(0))) {
                    this.consumeCodePoint();
                }
            };
            Tokenizer.prototype.consumeBadUrlRemnants = function () {
                while (true) {
                    var codePoint = this.consumeCodePoint();
                    if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
                        return;
                    }
                    if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                        this.consumeEscapedCodePoint();
                    }
                }
            };
            Tokenizer.prototype.consumeStringSlice = function (count) {
                var SLICE_STACK_SIZE = 60000;
                var value = '';
                while (count > 0) {
                    var amount = Math.min(SLICE_STACK_SIZE, count);
                    value += fromCodePoint.apply(void 0, this._value.splice(0, amount));
                    count -= amount;
                }
                this._value.shift();
                return value;
            };
            Tokenizer.prototype.consumeStringToken = function (endingCodePoint) {
                var value = '';
                var i = 0;
                do {
                    var codePoint = this._value[i];
                    if (codePoint === EOF || codePoint === undefined || codePoint === endingCodePoint) {
                        value += this.consumeStringSlice(i);
                        return { type: TokenType.STRING_TOKEN, value: value };
                    }
                    if (codePoint === LINE_FEED) {
                        this._value.splice(0, i);
                        return BAD_STRING_TOKEN;
                    }
                    if (codePoint === REVERSE_SOLIDUS) {
                        var next = this._value[i + 1];
                        if (next !== EOF && next !== undefined) {
                            if (next === LINE_FEED) {
                                value += this.consumeStringSlice(i);
                                i = -1;
                                this._value.shift();
                            }
                            else if (isValidEscape(codePoint, next)) {
                                value += this.consumeStringSlice(i);
                                value += fromCodePoint(this.consumeEscapedCodePoint());
                                i = -1;
                            }
                        }
                    }
                    i++;
                } while (true);
            };
            Tokenizer.prototype.consumeNumber = function () {
                var repr = [];
                var type = FLAG_INTEGER;
                var c1 = this.peekCodePoint(0);
                if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
                    repr.push(this.consumeCodePoint());
                }
                while (isDigit(this.peekCodePoint(0))) {
                    repr.push(this.consumeCodePoint());
                }
                c1 = this.peekCodePoint(0);
                var c2 = this.peekCodePoint(1);
                if (c1 === FULL_STOP && isDigit(c2)) {
                    repr.push(this.consumeCodePoint(), this.consumeCodePoint());
                    type = FLAG_NUMBER;
                    while (isDigit(this.peekCodePoint(0))) {
                        repr.push(this.consumeCodePoint());
                    }
                }
                c1 = this.peekCodePoint(0);
                c2 = this.peekCodePoint(1);
                var c3 = this.peekCodePoint(2);
                if ((c1 === E || c1 === e) && (((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3)) || isDigit(c2))) {
                    repr.push(this.consumeCodePoint(), this.consumeCodePoint());
                    type = FLAG_NUMBER;
                    while (isDigit(this.peekCodePoint(0))) {
                        repr.push(this.consumeCodePoint());
                    }
                }
                return [stringToNumber(repr), type];
            };
            Tokenizer.prototype.consumeNumericToken = function () {
                var _a = this.consumeNumber(), number = _a[0], flags = _a[1];
                var c1 = this.peekCodePoint(0);
                var c2 = this.peekCodePoint(1);
                var c3 = this.peekCodePoint(2);
                if (isIdentifierStart(c1, c2, c3)) {
                    var unit = this.consumeName();
                    return { type: TokenType.DIMENSION_TOKEN, number: number, flags: flags, unit: unit };
                }
                if (c1 === PERCENTAGE_SIGN) {
                    this.consumeCodePoint();
                    return { type: TokenType.PERCENTAGE_TOKEN, number: number, flags: flags };
                }
                return { type: TokenType.NUMBER_TOKEN, number: number, flags: flags };
            };
            Tokenizer.prototype.consumeEscapedCodePoint = function () {
                var codePoint = this.consumeCodePoint();
                if (isHex(codePoint)) {
                    var hex = fromCodePoint(codePoint);
                    while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
                        hex += fromCodePoint(this.consumeCodePoint());
                    }
                    if (isWhiteSpace(this.peekCodePoint(0))) {
                        this.consumeCodePoint();
                    }
                    var hexCodePoint = parseInt(hex, 16);
                    if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 0x10ffff) {
                        return REPLACEMENT_CHARACTER;
                    }
                    return hexCodePoint;
                }
                if (codePoint === EOF) {
                    return REPLACEMENT_CHARACTER;
                }
                return codePoint;
            };
            Tokenizer.prototype.consumeName = function () {
                var result = '';
                while (true) {
                    var codePoint = this.consumeCodePoint();
                    if (isNameCodePoint(codePoint)) {
                        result += fromCodePoint(codePoint);
                    }
                    else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                        result += fromCodePoint(this.consumeEscapedCodePoint());
                    }
                    else {
                        this.reconsumeCodePoint(codePoint);
                        return result;
                    }
                }
            };
            return Tokenizer;
        }());

        var Parser = /** @class */ (function () {
            function Parser(tokens) {
                this._tokens = tokens;
            }
            Parser.create = function (value) {
                var tokenizer = new Tokenizer();
                tokenizer.write(value);
                return new Parser(tokenizer.read());
            };
            Parser.parseValue = function (value) {
                return Parser.create(value).parseComponentValue();
            };
            Parser.parseValues = function (value) {
                return Parser.create(value).parseComponentValues();
            };
            Parser.prototype.parseComponentValue = function () {
                var token = this.consumeToken();
                while (token.type === TokenType.WHITESPACE_TOKEN) {
                    token = this.consumeToken();
                }
                if (token.type === TokenType.EOF_TOKEN) {
                    throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
                }
                this.reconsumeToken(token);
                var value = this.consumeComponentValue();
                do {
                    token = this.consumeToken();
                } while (token.type === TokenType.WHITESPACE_TOKEN);
                if (token.type === TokenType.EOF_TOKEN) {
                    return value;
                }
                throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
            };
            Parser.prototype.parseComponentValues = function () {
                var values = [];
                while (true) {
                    var value = this.consumeComponentValue();
                    if (value.type === TokenType.EOF_TOKEN) {
                        return values;
                    }
                    values.push(value);
                    values.push();
                }
            };
            Parser.prototype.consumeComponentValue = function () {
                var token = this.consumeToken();
                switch (token.type) {
                    case TokenType.LEFT_CURLY_BRACKET_TOKEN:
                    case TokenType.LEFT_SQUARE_BRACKET_TOKEN:
                    case TokenType.LEFT_PARENTHESIS_TOKEN:
                        return this.consumeSimpleBlock(token.type);
                    case TokenType.FUNCTION_TOKEN:
                        return this.consumeFunction(token);
                }
                return token;
            };
            Parser.prototype.consumeSimpleBlock = function (type) {
                var block = { type: type, values: [] };
                var token = this.consumeToken();
                while (true) {
                    if (token.type === TokenType.EOF_TOKEN || isEndingTokenFor(token, type)) {
                        return block;
                    }
                    this.reconsumeToken(token);
                    block.values.push(this.consumeComponentValue());
                    token = this.consumeToken();
                }
            };
            Parser.prototype.consumeFunction = function (functionToken) {
                var cssFunction = {
                    name: functionToken.value,
                    values: [],
                    type: TokenType.FUNCTION
                };
                while (true) {
                    var token = this.consumeToken();
                    if (token.type === TokenType.EOF_TOKEN || token.type === TokenType.RIGHT_PARENTHESIS_TOKEN) {
                        return cssFunction;
                    }
                    this.reconsumeToken(token);
                    cssFunction.values.push(this.consumeComponentValue());
                }
            };
            Parser.prototype.consumeToken = function () {
                var token = this._tokens.shift();
                return typeof token === 'undefined' ? EOF_TOKEN : token;
            };
            Parser.prototype.reconsumeToken = function (token) {
                this._tokens.unshift(token);
            };
            return Parser;
        }());
        var isDimensionToken = function (token) { return token.type === TokenType.DIMENSION_TOKEN; };
        var isNumberToken = function (token) { return token.type === TokenType.NUMBER_TOKEN; };
        var isIdentToken = function (token) { return token.type === TokenType.IDENT_TOKEN; };
        var isStringToken = function (token) { return token.type === TokenType.STRING_TOKEN; };
        var isIdentWithValue = function (token, value) {
            return isIdentToken(token) && token.value === value;
        };
        var nonWhiteSpace = function (token) { return token.type !== TokenType.WHITESPACE_TOKEN; };
        var nonFunctionArgSeparator = function (token) {
            return token.type !== TokenType.WHITESPACE_TOKEN && token.type !== TokenType.COMMA_TOKEN;
        };
        var parseFunctionArgs = function (tokens) {
            var args = [];
            var arg = [];
            tokens.forEach(function (token) {
                if (token.type === TokenType.COMMA_TOKEN) {
                    if (arg.length === 0) {
                        throw new Error("Error parsing function args, zero tokens for arg");
                    }
                    args.push(arg);
                    arg = [];
                    return;
                }
                if (token.type !== TokenType.WHITESPACE_TOKEN) {
                    arg.push(token);
                }
            });
            if (arg.length) {
                args.push(arg);
            }
            return args;
        };
        var isEndingTokenFor = function (token, type) {
            if (type === TokenType.LEFT_CURLY_BRACKET_TOKEN && token.type === TokenType.RIGHT_CURLY_BRACKET_TOKEN) {
                return true;
            }
            if (type === TokenType.LEFT_SQUARE_BRACKET_TOKEN && token.type === TokenType.RIGHT_SQUARE_BRACKET_TOKEN) {
                return true;
            }
            return type === TokenType.LEFT_PARENTHESIS_TOKEN && token.type === TokenType.RIGHT_PARENTHESIS_TOKEN;
        };

        var isLength = function (token) {
            return token.type === TokenType.NUMBER_TOKEN || token.type === TokenType.DIMENSION_TOKEN;
        };

        var isLengthPercentage = function (token) {
            return token.type === TokenType.PERCENTAGE_TOKEN || isLength(token);
        };
        var parseLengthPercentageTuple = function (tokens) {
            return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
        };
        var ZERO_LENGTH = {
            type: TokenType.NUMBER_TOKEN,
            number: 0,
            flags: FLAG_INTEGER
        };
        var FIFTY_PERCENT = {
            type: TokenType.PERCENTAGE_TOKEN,
            number: 50,
            flags: FLAG_INTEGER
        };
        var HUNDRED_PERCENT = {
            type: TokenType.PERCENTAGE_TOKEN,
            number: 100,
            flags: FLAG_INTEGER
        };
        var getAbsoluteValueForTuple = function (tuple, width, height) {
            var x = tuple[0], y = tuple[1];
            return [getAbsoluteValue(x, width), getAbsoluteValue(typeof y !== 'undefined' ? y : x, height)];
        };
        var getAbsoluteValue = function (token, parent) {
            if (token.type === TokenType.PERCENTAGE_TOKEN) {
                return (token.number / 100) * parent;
            }
            if (isDimensionToken(token)) {
                switch (token.unit) {
                    case 'rem':
                    case 'em':
                        return 16 * token.number; // TODO use correct font-size
                    case 'px':
                    default:
                        return token.number;
                }
            }
            return token.number;
        };

        var DEG = 'deg';
        var GRAD = 'grad';
        var RAD = 'rad';
        var TURN = 'turn';
        var angle = {
            name: 'angle',
            parse: function (value) {
                if (value.type === TokenType.DIMENSION_TOKEN) {
                    switch (value.unit) {
                        case DEG:
                            return (Math.PI * value.number) / 180;
                        case GRAD:
                            return (Math.PI / 200) * value.number;
                        case RAD:
                            return value.number;
                        case TURN:
                            return Math.PI * 2 * value.number;
                    }
                }
                throw new Error("Unsupported angle type");
            }
        };
        var isAngle = function (value) {
            if (value.type === TokenType.DIMENSION_TOKEN) {
                if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
                    return true;
                }
            }
            return false;
        };
        var parseNamedSide = function (tokens) {
            var sideOrCorner = tokens
                .filter(isIdentToken)
                .map(function (ident) { return ident.value; })
                .join(' ');
            switch (sideOrCorner) {
                case 'to bottom right':
                case 'to right bottom':
                case 'left top':
                case 'top left':
                    return [ZERO_LENGTH, ZERO_LENGTH];
                case 'to top':
                case 'bottom':
                    return deg(0);
                case 'to bottom left':
                case 'to left bottom':
                case 'right top':
                case 'top right':
                    return [ZERO_LENGTH, HUNDRED_PERCENT];
                case 'to right':
                case 'left':
                    return deg(90);
                case 'to top left':
                case 'to left top':
                case 'right bottom':
                case 'bottom right':
                    return [HUNDRED_PERCENT, HUNDRED_PERCENT];
                case 'to bottom':
                case 'top':
                    return deg(180);
                case 'to top right':
                case 'to right top':
                case 'left bottom':
                case 'bottom left':
                    return [HUNDRED_PERCENT, ZERO_LENGTH];
                case 'to left':
                case 'right':
                    return deg(270);
            }
            return 0;
        };
        var deg = function (deg) { return (Math.PI * deg) / 180; };

        var color = {
            name: 'color',
            parse: function (value) {
                if (value.type === TokenType.FUNCTION) {
                    var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
                    if (typeof colorFunction === 'undefined') {
                        throw new Error("Attempting to parse an unsupported color function \"" + value.name + "\"");
                    }
                    return colorFunction(value.values);
                }
                if (value.type === TokenType.HASH_TOKEN) {
                    if (value.value.length === 3) {
                        var r = value.value.substring(0, 1);
                        var g = value.value.substring(1, 2);
                        var b = value.value.substring(2, 3);
                        return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), 1);
                    }
                    if (value.value.length === 4) {
                        var r = value.value.substring(0, 1);
                        var g = value.value.substring(1, 2);
                        var b = value.value.substring(2, 3);
                        var a = value.value.substring(3, 4);
                        return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), parseInt(a + a, 16) / 255);
                    }
                    if (value.value.length === 6) {
                        var r = value.value.substring(0, 2);
                        var g = value.value.substring(2, 4);
                        var b = value.value.substring(4, 6);
                        return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1);
                    }
                    if (value.value.length === 8) {
                        var r = value.value.substring(0, 2);
                        var g = value.value.substring(2, 4);
                        var b = value.value.substring(4, 6);
                        var a = value.value.substring(6, 8);
                        return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), parseInt(a, 16) / 255);
                    }
                }
                if (value.type === TokenType.IDENT_TOKEN) {
                    var namedColor = COLORS[value.value.toUpperCase()];
                    if (typeof namedColor !== 'undefined') {
                        return namedColor;
                    }
                }
                return COLORS.TRANSPARENT;
            }
        };
        var isTransparent = function (color) { return (0xff & color) === 0; };
        var asString = function (color) {
            var alpha = 0xff & color;
            var blue = 0xff & (color >> 8);
            var green = 0xff & (color >> 16);
            var red = 0xff & (color >> 24);
            return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
        };
        var pack = function (r, g, b, a) {
            return ((r << 24) | (g << 16) | (b << 8) | (Math.round(a * 255) << 0)) >>> 0;
        };
        var getTokenColorValue = function (token, i) {
            if (token.type === TokenType.NUMBER_TOKEN) {
                return token.number;
            }
            if (token.type === TokenType.PERCENTAGE_TOKEN) {
                var max = i === 3 ? 1 : 255;
                return i === 3 ? (token.number / 100) * max : Math.round((token.number / 100) * max);
            }
            return 0;
        };
        var rgb = function (args) {
            var tokens = args.filter(nonFunctionArgSeparator);
            if (tokens.length === 3) {
                var _a = tokens.map(getTokenColorValue), r = _a[0], g = _a[1], b = _a[2];
                return pack(r, g, b, 1);
            }
            if (tokens.length === 4) {
                var _b = tokens.map(getTokenColorValue), r = _b[0], g = _b[1], b = _b[2], a = _b[3];
                return pack(r, g, b, a);
            }
            return 0;
        };
        function hue2rgb(t1, t2, hue) {
            if (hue < 0) {
                hue += 1;
            }
            if (hue >= 1) {
                hue -= 1;
            }
            if (hue < 1 / 6) {
                return (t2 - t1) * hue * 6 + t1;
            }
            else if (hue < 1 / 2) {
                return t2;
            }
            else if (hue < 2 / 3) {
                return (t2 - t1) * 6 * (2 / 3 - hue) + t1;
            }
            else {
                return t1;
            }
        }
        var hsl = function (args) {
            var tokens = args.filter(nonFunctionArgSeparator);
            var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
            var h = (hue.type === TokenType.NUMBER_TOKEN ? deg(hue.number) : angle.parse(hue)) / (Math.PI * 2);
            var s = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
            var l = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
            var a = typeof alpha !== 'undefined' && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
            if (s === 0) {
                return pack(l * 255, l * 255, l * 255, 1);
            }
            var t2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
            var t1 = l * 2 - t2;
            var r = hue2rgb(t1, t2, h + 1 / 3);
            var g = hue2rgb(t1, t2, h);
            var b = hue2rgb(t1, t2, h - 1 / 3);
            return pack(r * 255, g * 255, b * 255, a);
        };
        var SUPPORTED_COLOR_FUNCTIONS = {
            hsl: hsl,
            hsla: hsl,
            rgb: rgb,
            rgba: rgb
        };
        var COLORS = {
            ALICEBLUE: 0xf0f8ffff,
            ANTIQUEWHITE: 0xfaebd7ff,
            AQUA: 0x00ffffff,
            AQUAMARINE: 0x7fffd4ff,
            AZURE: 0xf0ffffff,
            BEIGE: 0xf5f5dcff,
            BISQUE: 0xffe4c4ff,
            BLACK: 0x000000ff,
            BLANCHEDALMOND: 0xffebcdff,
            BLUE: 0x0000ffff,
            BLUEVIOLET: 0x8a2be2ff,
            BROWN: 0xa52a2aff,
            BURLYWOOD: 0xdeb887ff,
            CADETBLUE: 0x5f9ea0ff,
            CHARTREUSE: 0x7fff00ff,
            CHOCOLATE: 0xd2691eff,
            CORAL: 0xff7f50ff,
            CORNFLOWERBLUE: 0x6495edff,
            CORNSILK: 0xfff8dcff,
            CRIMSON: 0xdc143cff,
            CYAN: 0x00ffffff,
            DARKBLUE: 0x00008bff,
            DARKCYAN: 0x008b8bff,
            DARKGOLDENROD: 0xb886bbff,
            DARKGRAY: 0xa9a9a9ff,
            DARKGREEN: 0x006400ff,
            DARKGREY: 0xa9a9a9ff,
            DARKKHAKI: 0xbdb76bff,
            DARKMAGENTA: 0x8b008bff,
            DARKOLIVEGREEN: 0x556b2fff,
            DARKORANGE: 0xff8c00ff,
            DARKORCHID: 0x9932ccff,
            DARKRED: 0x8b0000ff,
            DARKSALMON: 0xe9967aff,
            DARKSEAGREEN: 0x8fbc8fff,
            DARKSLATEBLUE: 0x483d8bff,
            DARKSLATEGRAY: 0x2f4f4fff,
            DARKSLATEGREY: 0x2f4f4fff,
            DARKTURQUOISE: 0x00ced1ff,
            DARKVIOLET: 0x9400d3ff,
            DEEPPINK: 0xff1493ff,
            DEEPSKYBLUE: 0x00bfffff,
            DIMGRAY: 0x696969ff,
            DIMGREY: 0x696969ff,
            DODGERBLUE: 0x1e90ffff,
            FIREBRICK: 0xb22222ff,
            FLORALWHITE: 0xfffaf0ff,
            FORESTGREEN: 0x228b22ff,
            FUCHSIA: 0xff00ffff,
            GAINSBORO: 0xdcdcdcff,
            GHOSTWHITE: 0xf8f8ffff,
            GOLD: 0xffd700ff,
            GOLDENROD: 0xdaa520ff,
            GRAY: 0x808080ff,
            GREEN: 0x008000ff,
            GREENYELLOW: 0xadff2fff,
            GREY: 0x808080ff,
            HONEYDEW: 0xf0fff0ff,
            HOTPINK: 0xff69b4ff,
            INDIANRED: 0xcd5c5cff,
            INDIGO: 0x4b0082ff,
            IVORY: 0xfffff0ff,
            KHAKI: 0xf0e68cff,
            LAVENDER: 0xe6e6faff,
            LAVENDERBLUSH: 0xfff0f5ff,
            LAWNGREEN: 0x7cfc00ff,
            LEMONCHIFFON: 0xfffacdff,
            LIGHTBLUE: 0xadd8e6ff,
            LIGHTCORAL: 0xf08080ff,
            LIGHTCYAN: 0xe0ffffff,
            LIGHTGOLDENRODYELLOW: 0xfafad2ff,
            LIGHTGRAY: 0xd3d3d3ff,
            LIGHTGREEN: 0x90ee90ff,
            LIGHTGREY: 0xd3d3d3ff,
            LIGHTPINK: 0xffb6c1ff,
            LIGHTSALMON: 0xffa07aff,
            LIGHTSEAGREEN: 0x20b2aaff,
            LIGHTSKYBLUE: 0x87cefaff,
            LIGHTSLATEGRAY: 0x778899ff,
            LIGHTSLATEGREY: 0x778899ff,
            LIGHTSTEELBLUE: 0xb0c4deff,
            LIGHTYELLOW: 0xffffe0ff,
            LIME: 0x00ff00ff,
            LIMEGREEN: 0x32cd32ff,
            LINEN: 0xfaf0e6ff,
            MAGENTA: 0xff00ffff,
            MAROON: 0x800000ff,
            MEDIUMAQUAMARINE: 0x66cdaaff,
            MEDIUMBLUE: 0x0000cdff,
            MEDIUMORCHID: 0xba55d3ff,
            MEDIUMPURPLE: 0x9370dbff,
            MEDIUMSEAGREEN: 0x3cb371ff,
            MEDIUMSLATEBLUE: 0x7b68eeff,
            MEDIUMSPRINGGREEN: 0x00fa9aff,
            MEDIUMTURQUOISE: 0x48d1ccff,
            MEDIUMVIOLETRED: 0xc71585ff,
            MIDNIGHTBLUE: 0x191970ff,
            MINTCREAM: 0xf5fffaff,
            MISTYROSE: 0xffe4e1ff,
            MOCCASIN: 0xffe4b5ff,
            NAVAJOWHITE: 0xffdeadff,
            NAVY: 0x000080ff,
            OLDLACE: 0xfdf5e6ff,
            OLIVE: 0x808000ff,
            OLIVEDRAB: 0x6b8e23ff,
            ORANGE: 0xffa500ff,
            ORANGERED: 0xff4500ff,
            ORCHID: 0xda70d6ff,
            PALEGOLDENROD: 0xeee8aaff,
            PALEGREEN: 0x98fb98ff,
            PALETURQUOISE: 0xafeeeeff,
            PALEVIOLETRED: 0xdb7093ff,
            PAPAYAWHIP: 0xffefd5ff,
            PEACHPUFF: 0xffdab9ff,
            PERU: 0xcd853fff,
            PINK: 0xffc0cbff,
            PLUM: 0xdda0ddff,
            POWDERBLUE: 0xb0e0e6ff,
            PURPLE: 0x800080ff,
            REBECCAPURPLE: 0x663399ff,
            RED: 0xff0000ff,
            ROSYBROWN: 0xbc8f8fff,
            ROYALBLUE: 0x4169e1ff,
            SADDLEBROWN: 0x8b4513ff,
            SALMON: 0xfa8072ff,
            SANDYBROWN: 0xf4a460ff,
            SEAGREEN: 0x2e8b57ff,
            SEASHELL: 0xfff5eeff,
            SIENNA: 0xa0522dff,
            SILVER: 0xc0c0c0ff,
            SKYBLUE: 0x87ceebff,
            SLATEBLUE: 0x6a5acdff,
            SLATEGRAY: 0x708090ff,
            SLATEGREY: 0x708090ff,
            SNOW: 0xfffafaff,
            SPRINGGREEN: 0x00ff7fff,
            STEELBLUE: 0x4682b4ff,
            TAN: 0xd2b48cff,
            TEAL: 0x008080ff,
            THISTLE: 0xd8bfd8ff,
            TOMATO: 0xff6347ff,
            TRANSPARENT: 0x00000000,
            TURQUOISE: 0x40e0d0ff,
            VIOLET: 0xee82eeff,
            WHEAT: 0xf5deb3ff,
            WHITE: 0xffffffff,
            WHITESMOKE: 0xf5f5f5ff,
            YELLOW: 0xffff00ff,
            YELLOWGREEN: 0x9acd32ff
        };

        var PropertyDescriptorParsingType;
        (function (PropertyDescriptorParsingType) {
            PropertyDescriptorParsingType[PropertyDescriptorParsingType["VALUE"] = 0] = "VALUE";
            PropertyDescriptorParsingType[PropertyDescriptorParsingType["LIST"] = 1] = "LIST";
            PropertyDescriptorParsingType[PropertyDescriptorParsingType["IDENT_VALUE"] = 2] = "IDENT_VALUE";
            PropertyDescriptorParsingType[PropertyDescriptorParsingType["TYPE_VALUE"] = 3] = "TYPE_VALUE";
            PropertyDescriptorParsingType[PropertyDescriptorParsingType["TOKEN_VALUE"] = 4] = "TOKEN_VALUE";
        })(PropertyDescriptorParsingType || (PropertyDescriptorParsingType = {}));

        var BACKGROUND_CLIP;
        (function (BACKGROUND_CLIP) {
            BACKGROUND_CLIP[BACKGROUND_CLIP["BORDER_BOX"] = 0] = "BORDER_BOX";
            BACKGROUND_CLIP[BACKGROUND_CLIP["PADDING_BOX"] = 1] = "PADDING_BOX";
            BACKGROUND_CLIP[BACKGROUND_CLIP["CONTENT_BOX"] = 2] = "CONTENT_BOX";
        })(BACKGROUND_CLIP || (BACKGROUND_CLIP = {}));
        var backgroundClip = {
            name: 'background-clip',
            initialValue: 'border-box',
            prefix: false,
            type: PropertyDescriptorParsingType.LIST,
            parse: function (tokens) {
                return tokens.map(function (token) {
                    if (isIdentToken(token)) {
                        switch (token.value) {
                            case 'padding-box':
                                return BACKGROUND_CLIP.PADDING_BOX;
                            case 'content-box':
                                return BACKGROUND_CLIP.CONTENT_BOX;
                        }
                    }
                    return BACKGROUND_CLIP.BORDER_BOX;
                });
            }
        };

        var backgroundColor = {
            name: "background-color",
            initialValue: 'transparent',
            prefix: false,
            type: PropertyDescriptorParsingType.TYPE_VALUE,
            format: 'color'
        };

        var parseColorStop = function (args) {
            var color$1 = color.parse(args[0]);
            var stop = args[1];
            return stop && isLengthPercentage(stop) ? { color: color$1, stop: stop } : { color: color$1, stop: null };
        };
        var processColorStops = function (stops, lineLength) {
            var first = stops[0];
            var last = stops[stops.length - 1];
            if (first.stop === null) {
                first.stop = ZERO_LENGTH;
            }
            if (last.stop === null) {
                last.stop = HUNDRED_PERCENT;
            }
            var processStops = [];
            var previous = 0;
            for (var i = 0; i < stops.length; i++) {
                var stop_1 = stops[i].stop;
                if (stop_1 !== null) {
                    var absoluteValue = getAbsoluteValue(stop_1, lineLength);
                    if (absoluteValue > previous) {
                        processStops.push(absoluteValue);
                    }
                    else {
                        processStops.push(previous);
                    }
                    previous = absoluteValue;
                }
                else {
                    processStops.push(null);
                }
            }
            var gapBegin = null;
            for (var i = 0; i < processStops.length; i++) {
                var stop_2 = processStops[i];
                if (stop_2 === null) {
                    if (gapBegin === null) {
                        gapBegin = i;
                    }
                }
                else if (gapBegin !== null) {
                    var gapLength = i - gapBegin;
                    var beforeGap = processStops[gapBegin - 1];
                    var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
                    for (var g = 1; g <= gapLength; g++) {
                        processStops[gapBegin + g - 1] = gapValue * g;
                    }
                    gapBegin = null;
                }
            }
            return stops.map(function (_a, i) {
                var color = _a.color;
                return { color: color, stop: Math.max(Math.min(1, processStops[i] / lineLength), 0) };
            });
        };
        var getAngleFromCorner = function (corner, width, height) {
            var centerX = width / 2;
            var centerY = height / 2;
            var x = getAbsoluteValue(corner[0], width) - centerX;
            var y = centerY - getAbsoluteValue(corner[1], height);
            return (Math.atan2(y, x) + Math.PI * 2) % (Math.PI * 2);
        };
        var calculateGradientDirection = function (angle, width, height) {
            var radian = typeof angle === 'number' ? angle : getAngleFromCorner(angle, width, height);
            var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
            var halfWidth = width / 2;
            var halfHeight = height / 2;
            var halfLineLength = lineLength / 2;
            var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
            var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
            return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
        };
        var distance = function (a, b) { return Math.sqrt(a * a + b * b); };
        var findCorner = function (width, height, x, y, closest) {
            var corners = [[0, 0], [0, height], [width, 0], [width, height]];
            return corners.reduce(function (stat, corner) {
                var cx = corner[0], cy = corner[1];
                var d = distance(x - cx, y - cy);
                if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {
                    return {
                        optimumCorner: corner,
                        optimumDistance: d
                    };
                }
                return stat;
            }, {
                optimumDistance: closest ? Infinity : -Infinity,
                optimumCorner: null
            }).optimumCorner;
        };
        var calculateRadius = function (gradient, x, y, width, height) {
            var rx = 0;
            var ry = 0;
            switch (gradient.size) {
                case CSSRadialExtent.CLOSEST_SIDE:
                    // The ending shape is sized so that that it exactly meets the side of the gradient box closest to the gradient’s center.
                    // If the shape is an ellipse, it exactly meets the closest side in each dimension.
                    if (gradient.shape === CSSRadialShape.CIRCLE) {
                        rx = ry = Math.min(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
                    }
                    else if (gradient.shape === CSSRadialShape.ELLIPSE) {
                        rx = Math.min(Math.abs(x), Math.abs(x - width));
                        ry = Math.min(Math.abs(y), Math.abs(y - height));
                    }
                    break;
                case CSSRadialExtent.CLOSEST_CORNER:
                    // The ending shape is sized so that that it passes through the corner of the gradient box closest to the gradient’s center.
                    // If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.
                    if (gradient.shape === CSSRadialShape.CIRCLE) {
                        rx = ry = Math.min(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
                    }
                    else if (gradient.shape === CSSRadialShape.ELLIPSE) {
                        // Compute the ratio ry/rx (which is to be the same as for "closest-side")
                        var c = Math.min(Math.abs(y), Math.abs(y - height)) / Math.min(Math.abs(x), Math.abs(x - width));
                        var _a = findCorner(width, height, x, y, true), cx = _a[0], cy = _a[1];
                        rx = distance(cx - x, (cy - y) / c);
                        ry = c * rx;
                    }
                    break;
                case CSSRadialExtent.FARTHEST_SIDE:
                    // Same as closest-side, except the ending shape is sized based on the farthest side(s)
                    if (gradient.shape === CSSRadialShape.CIRCLE) {
                        rx = ry = Math.max(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
                    }
                    else if (gradient.shape === CSSRadialShape.ELLIPSE) {
                        rx = Math.max(Math.abs(x), Math.abs(x - width));
                        ry = Math.max(Math.abs(y), Math.abs(y - height));
                    }
                    break;
                case CSSRadialExtent.FARTHEST_CORNER:
                    // Same as closest-corner, except the ending shape is sized based on the farthest corner.
                    // If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.
                    if (gradient.shape === CSSRadialShape.CIRCLE) {
                        rx = ry = Math.max(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
                    }
                    else if (gradient.shape === CSSRadialShape.ELLIPSE) {
                        // Compute the ratio ry/rx (which is to be the same as for "farthest-side")
                        var c = Math.max(Math.abs(y), Math.abs(y - height)) / Math.max(Math.abs(x), Math.abs(x - width));
                        var _b = findCorner(width, height, x, y, false), cx = _b[0], cy = _b[1];
                        rx = distance(cx - x, (cy - y) / c);
                        ry = c * rx;
                    }
                    break;
            }
            if (Array.isArray(gradient.size)) {
                rx = getAbsoluteValue(gradient.size[0], width);
                ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
            }
            return [rx, ry];
        };

        var linearGradient = function (tokens) {
            var angle$1 = deg(180);
            var stops = [];
            parseFunctionArgs(tokens).forEach(function (arg, i) {
                if (i === 0) {
                    var firstToken = arg[0];
                    if (firstToken.type === TokenType.IDENT_TOKEN && firstToken.value === 'to') {
                        angle$1 = parseNamedSide(arg);
                        return;
                    }
                    else if (isAngle(firstToken)) {
                        angle$1 = angle.parse(firstToken);
                        return;
                    }
                }
                var colorStop = parseColorStop(arg);
                stops.push(colorStop);
            });
            return { angle: angle$1, stops: stops, type: CSSImageType.LINEAR_GRADIENT };
        };

        var prefixLinearGradient = function (tokens) {
            var angle$1 = deg(180);
            var stops = [];
            parseFunctionArgs(tokens).forEach(function (arg, i) {
                if (i === 0) {
                    var firstToken = arg[0];
                    if (firstToken.type === TokenType.IDENT_TOKEN &&
                        ['top', 'left', 'right', 'bottom'].indexOf(firstToken.value) !== -1) {
                        angle$1 = parseNamedSide(arg);
                        return;
                    }
                    else if (isAngle(firstToken)) {
                        angle$1 = (angle.parse(firstToken) + deg(270)) % deg(360);
                        return;
                    }
                }
                var colorStop = parseColorStop(arg);
                stops.push(colorStop);
            });
            return {
                angle: angle$1,
                stops: stops,
                type: CSSImageType.LINEAR_GRADIENT
            };
        };

        var testRangeBounds = function (document) {
            var TEST_HEIGHT = 123;
            if (document.createRange) {
                var range = document.createRange();
                if (range.getBoundingClientRect) {
                    var testElement = document.createElement('boundtest');
                    testElement.style.height = TEST_HEIGHT + "px";
                    testElement.style.display = 'block';
                    document.body.appendChild(testElement);
                    range.selectNode(testElement);
                    var rangeBounds = range.getBoundingClientRect();
                    var rangeHeight = Math.round(rangeBounds.height);
                    document.body.removeChild(testElement);
                    if (rangeHeight === TEST_HEIGHT) {
                        return true;
                    }
                }
            }
            return false;
        };
        var testCORS = function () { return typeof new Image().crossOrigin !== 'undefined'; };
        var testResponseType = function () { return typeof new XMLHttpRequest().responseType === 'string'; };
        var testSVG = function (document) {
            var img = new Image();
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            if (!ctx) {
                return false;
            }
            img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
            try {
                ctx.drawImage(img, 0, 0);
                canvas.toDataURL();
            }
            catch (e) {
                return false;
            }
            return true;
        };
        var isGreenPixel = function (data) {
            return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
        };
        var testForeignObject = function (document) {
            var canvas = document.createElement('canvas');
            var size = 100;
            canvas.width = size;
            canvas.height = size;
            var ctx = canvas.getContext('2d');
            if (!ctx) {
                return Promise.reject(false);
            }
            ctx.fillStyle = 'rgb(0, 255, 0)';
            ctx.fillRect(0, 0, size, size);
            var img = new Image();
            var greenImageSrc = canvas.toDataURL();
            img.src = greenImageSrc;
            var svg = createForeignObjectSVG(size, size, 0, 0, img);
            ctx.fillStyle = 'red';
            ctx.fillRect(0, 0, size, size);
            return loadSerializedSVG(svg)
                .then(function (img) {
                ctx.drawImage(img, 0, 0);
                var data = ctx.getImageData(0, 0, size, size).data;
                ctx.fillStyle = 'red';
                ctx.fillRect(0, 0, size, size);
                var node = document.createElement('div');
                node.style.backgroundImage = "url(" + greenImageSrc + ")";
                node.style.height = size + "px";
                // Firefox 55 does not render inline <img /> tags
                return isGreenPixel(data)
                    ? loadSerializedSVG(createForeignObjectSVG(size, size, 0, 0, node))
                    : Promise.reject(false);
            })
                .then(function (img) {
                ctx.drawImage(img, 0, 0);
                // Edge does not render background-images
                return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
            })
                .catch(function () { return false; });
        };
        var createForeignObjectSVG = function (width, height, x, y, node) {
            var xmlns = 'http://www.w3.org/2000/svg';
            var svg = document.createElementNS(xmlns, 'svg');
            var foreignObject = document.createElementNS(xmlns, 'foreignObject');
            svg.setAttributeNS(null, 'width', width.toString());
            svg.setAttributeNS(null, 'height', height.toString());
            foreignObject.setAttributeNS(null, 'width', '100%');
            foreignObject.setAttributeNS(null, 'height', '100%');
            foreignObject.setAttributeNS(null, 'x', x.toString());
            foreignObject.setAttributeNS(null, 'y', y.toString());
            foreignObject.setAttributeNS(null, 'externalResourcesRequired', 'true');
            svg.appendChild(foreignObject);
            foreignObject.appendChild(node);
            return svg;
        };
        var loadSerializedSVG = function (svg) {
            return new Promise(function (resolve, reject) {
                var img = new Image();
                img.onload = function () { return resolve(img); };
                img.onerror = reject;
                img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
            });
        };
        var FEATURES = {
            get SUPPORT_RANGE_BOUNDS() {
                var value = testRangeBounds(document);
                Object.defineProperty(FEATURES, 'SUPPORT_RANGE_BOUNDS', { value: value });
                return value;
            },
            get SUPPORT_SVG_DRAWING() {
                var value = testSVG(document);
                Object.defineProperty(FEATURES, 'SUPPORT_SVG_DRAWING', { value: value });
                return value;
            },
            get SUPPORT_FOREIGNOBJECT_DRAWING() {
                var value = typeof Array.from === 'function' && typeof window.fetch === 'function'
                    ? testForeignObject(document)
                    : Promise.resolve(false);
                Object.defineProperty(FEATURES, 'SUPPORT_FOREIGNOBJECT_DRAWING', { value: value });
                return value;
            },
            get SUPPORT_CORS_IMAGES() {
                var value = testCORS();
                Object.defineProperty(FEATURES, 'SUPPORT_CORS_IMAGES', { value: value });
                return value;
            },
            get SUPPORT_RESPONSE_TYPE() {
                var value = testResponseType();
                Object.defineProperty(FEATURES, 'SUPPORT_RESPONSE_TYPE', { value: value });
                return value;
            },
            get SUPPORT_CORS_XHR() {
                var value = 'withCredentials' in new XMLHttpRequest();
                Object.defineProperty(FEATURES, 'SUPPORT_CORS_XHR', { value: value });
                return value;
            }
        };

        var Logger = /** @class */ (function () {
            function Logger(_a) {
                var id = _a.id, enabled = _a.enabled;
                this.id = id;
                this.enabled = enabled;
                this.start = Date.now();
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            Logger.prototype.debug = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (this.enabled) {
                    // eslint-disable-next-line no-console
                    if (typeof window !== 'undefined' && window.console && typeof console.debug === 'function') {
                        // eslint-disable-next-line no-console
                        console.debug.apply(console, [this.id, this.getTime() + "ms"].concat(args));
                    }
                    else {
                        this.info.apply(this, args);
                    }
                }
            };
            Logger.prototype.getTime = function () {
                return Date.now() - this.start;
            };
            Logger.create = function (options) {
                Logger.instances[options.id] = new Logger(options);
            };
            Logger.destroy = function (id) {
                delete Logger.instances[id];
            };
            Logger.getInstance = function (id) {
                var instance = Logger.instances[id];
                if (typeof instance === 'undefined') {
                    throw new Error("No logger instance found with id " + id);
                }
                return instance;
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            Logger.prototype.info = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (this.enabled) {
                    // eslint-disable-next-line no-console
                    if (typeof window !== 'undefined' && window.console && typeof console.info === 'function') {
                        // eslint-disable-next-line no-console
                        console.info.apply(console, [this.id, this.getTime() + "ms"].concat(args));
                    }
                }
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            Logger.prototype.error = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (this.enabled) {
                    // eslint-disable-next-line no-console
                    if (typeof window !== 'undefined' && window.console && typeof console.error === 'function') {
                        // eslint-disable-next-line no-console
                        console.error.apply(console, [this.id, this.getTime() + "ms"].concat(args));
                    }
                    else {
                        this.info.apply(this, args);
                    }
                }
            };
            Logger.instances = {};
            return Logger;
        }());

        var CacheStorage = /** @class */ (function () {
            function CacheStorage() {
            }
            CacheStorage.create = function (name, options) {
                return (CacheStorage._caches[name] = new Cache(name, options));
            };
            CacheStorage.destroy = function (name) {
                delete CacheStorage._caches[name];
            };
            CacheStorage.open = function (name) {
                var cache = CacheStorage._caches[name];
                if (typeof cache !== 'undefined') {
                    return cache;
                }
                throw new Error("Cache with key \"" + name + "\" not found");
            };
            CacheStorage.getOrigin = function (url) {
                var link = CacheStorage._link;
                if (!link) {
                    return 'about:blank';
                }
                link.href = url;
                link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/
                return link.protocol + link.hostname + link.port;
            };
            CacheStorage.isSameOrigin = function (src) {
                return CacheStorage.getOrigin(src) === CacheStorage._origin;
            };
            CacheStorage.setContext = function (window) {
                CacheStorage._link = window.document.createElement('a');
                CacheStorage._origin = CacheStorage.getOrigin(window.location.href);
            };
            CacheStorage.getInstance = function () {
                var current = CacheStorage._current;
                if (current === null) {
                    throw new Error("No cache instance attached");
                }
                return current;
            };
            CacheStorage.attachInstance = function (cache) {
                CacheStorage._current = cache;
            };
            CacheStorage.detachInstance = function () {
                CacheStorage._current = null;
            };
            CacheStorage._caches = {};
            CacheStorage._origin = 'about:blank';
            CacheStorage._current = null;
            return CacheStorage;
        }());
        var Cache = /** @class */ (function () {
            function Cache(id, options) {
                this.id = id;
                this._options = options;
                this._cache = {};
            }
            Cache.prototype.addImage = function (src) {
                var result = Promise.resolve();
                if (this.has(src)) {
                    return result;
                }
                if (isBlobImage(src) || isRenderable(src)) {
                    this._cache[src] = this.loadImage(src);
                    return result;
                }
                return result;
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            Cache.prototype.match = function (src) {
                return this._cache[src];
            };
            Cache.prototype.loadImage = function (key) {
                return __awaiter(this, void 0, void 0, function () {
                    var isSameOrigin, useCORS, useProxy, src;
                    var _this = this;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                isSameOrigin = CacheStorage.isSameOrigin(key);
                                useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
                                useProxy = !isInlineImage(key) &&
                                    !isSameOrigin &&
                                    typeof this._options.proxy === 'string' &&
                                    FEATURES.SUPPORT_CORS_XHR &&
                                    !useCORS;
                                if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !useProxy && !useCORS) {
                                    return [2 /*return*/];
                                }
                                src = key;
                                if (!useProxy) return [3 /*break*/, 2];
                                return [4 /*yield*/, this.proxy(src)];
                            case 1:
                                src = _a.sent();
                                _a.label = 2;
                            case 2:
                                Logger.getInstance(this.id).debug("Added image " + key.substring(0, 256));
                                return [4 /*yield*/, new Promise(function (resolve, reject) {
                                        var img = new Image();
                                        img.onload = function () { return resolve(img); };
                                        img.onerror = reject;
                                        //ios safari 10.3 taints canvas with data urls unless crossOrigin is set to anonymous
                                        if (isInlineBase64Image(src) || useCORS) {
                                            img.crossOrigin = 'anonymous';
                                        }
                                        img.src = src;
                                        if (img.complete === true) {
                                            // Inline XML images may fail to parse, throwing an Error later on
                                            setTimeout(function () { return resolve(img); }, 500);
                                        }
                                        if (_this._options.imageTimeout > 0) {
                                            setTimeout(function () { return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image"); }, _this._options.imageTimeout);
                                        }
                                    })];
                            case 3: return [2 /*return*/, _a.sent()];
                        }
                    });
                });
            };
            Cache.prototype.has = function (key) {
                return typeof this._cache[key] !== 'undefined';
            };
            Cache.prototype.keys = function () {
                return Promise.resolve(Object.keys(this._cache));
            };
            Cache.prototype.proxy = function (src) {
                var _this = this;
                var proxy = this._options.proxy;
                if (!proxy) {
                    throw new Error('No proxy defined');
                }
                var key = src.substring(0, 256);
                return new Promise(function (resolve, reject) {
                    var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? 'blob' : 'text';
                    var xhr = new XMLHttpRequest();
                    xhr.onload = function () {
                        if (xhr.status === 200) {
                            if (responseType === 'text') {
                                resolve(xhr.response);
                            }
                            else {
                                var reader_1 = new FileReader();
                                reader_1.addEventListener('load', function () { return resolve(reader_1.result); }, false);
                                reader_1.addEventListener('error', function (e) { return reject(e); }, false);
                                reader_1.readAsDataURL(xhr.response);
                            }
                        }
                        else {
                            reject("Failed to proxy resource " + key + " with status code " + xhr.status);
                        }
                    };
                    xhr.onerror = reject;
                    xhr.open('GET', proxy + "?url=" + encodeURIComponent(src) + "&responseType=" + responseType);
                    if (responseType !== 'text' && xhr instanceof XMLHttpRequest) {
                        xhr.responseType = responseType;
                    }
                    if (_this._options.imageTimeout) {
                        var timeout_1 = _this._options.imageTimeout;
                        xhr.timeout = timeout_1;
                        xhr.ontimeout = function () { return reject("Timed out (" + timeout_1 + "ms) proxying " + key); };
                    }
                    xhr.send();
                });
            };
            return Cache;
        }());
        var INLINE_SVG = /^data:image\/svg\+xml/i;
        var INLINE_BASE64 = /^data:image\/.*;base64,/i;
        var INLINE_IMG = /^data:image\/.*/i;
        var isRenderable = function (src) { return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src); };
        var isInlineImage = function (src) { return INLINE_IMG.test(src); };
        var isInlineBase64Image = function (src) { return INLINE_BASE64.test(src); };
        var isBlobImage = function (src) { return src.substr(0, 4) === 'blob'; };
        var isSVG = function (src) { return src.substr(-3).toLowerCase() === 'svg' || INLINE_SVG.test(src); };

        var webkitGradient = function (tokens) {
            var angle = deg(180);
            var stops = [];
            var type = CSSImageType.LINEAR_GRADIENT;
            var shape = CSSRadialShape.CIRCLE;
            var size = CSSRadialExtent.FARTHEST_CORNER;
            var position = [];
            parseFunctionArgs(tokens).forEach(function (arg, i) {
                var firstToken = arg[0];
                if (i === 0) {
                    if (isIdentToken(firstToken) && firstToken.value === 'linear') {
                        type = CSSImageType.LINEAR_GRADIENT;
                        return;
                    }
                    else if (isIdentToken(firstToken) && firstToken.value === 'radial') {
                        type = CSSImageType.RADIAL_GRADIENT;
                        return;
                    }
                }
                if (firstToken.type === TokenType.FUNCTION) {
                    if (firstToken.name === 'from') {
                        var color$1 = color.parse(firstToken.values[0]);
                        stops.push({ stop: ZERO_LENGTH, color: color$1 });
                    }
                    else if (firstToken.name === 'to') {
                        var color$1 = color.parse(firstToken.values[0]);
                        stops.push({ stop: HUNDRED_PERCENT, color: color$1 });
                    }
                    else if (firstToken.name === 'color-stop') {
                        var values = firstToken.values.filter(nonFunctionArgSeparator);
                        if (values.length === 2) {
                            var color$1 = color.parse(values[1]);
                            var stop_1 = values[0];
                            if (isNumberToken(stop_1)) {
                                stops.push({
                                    stop: { type: TokenType.PERCENTAGE_TOKEN, number: stop_1.number * 100, flags: stop_1.flags },
                                    color: color$1
                                });
                            }
                        }
                    }
                }
            });
            return type === CSSImageType.LINEAR_GRADIENT
                ? {
                    angle: (angle + deg(180)) % deg(360),
                    stops: stops,
                    type: type
                }
                : { size: size, shape: shape, stops: stops, position: position, type: type };
        };

        var CLOSEST_SIDE = 'closest-side';
        var FARTHEST_SIDE = 'farthest-side';
        var CLOSEST_CORNER = 'closest-corner';
        var FARTHEST_CORNER = 'farthest-corner';
        var CIRCLE = 'circle';
        var ELLIPSE = 'ellipse';
        var COVER = 'cover';
        var CONTAIN = 'contain';
        var radialGradient = function (tokens) {
            var shape = CSSRadialShape.CIRCLE;
            var size = CSSRadialExtent.FARTHEST_CORNER;
            var stops = [];
            var position = [];
            parseFunctionArgs(tokens).forEach(function (arg, i) {
                var isColorStop = true;
                if (i === 0) {
                    var isAtPosition_1 = false;
                    isColorStop = arg.reduce(function (acc, token) {
                        if (isAtPosition_1) {
                            if (isIdentToken(token)) {
                                switch (token.value) {
                                    case 'center':
                                        position.push(FIFTY_PERCENT);
                                        return acc;
                                    case 'top':
                                    case 'left':
                                        position.push(ZERO_LENGTH);
                                        return acc;
                                    case 'right':
                                    case 'bottom':
                                        position.push(HUNDRED_PERCENT);
                                        return acc;
                                }
                            }
                            else if (isLengthPercentage(token) || isLength(token)) {
                                position.push(token);
                            }
                        }
                        else if (isIdentToken(token)) {
                            switch (token.value) {
                                case CIRCLE:
                                    shape = CSSRadialShape.CIRCLE;
                                    return false;
                                case ELLIPSE:
                                    shape = CSSRadialShape.ELLIPSE;
                                    return false;
                                case 'at':
                                    isAtPosition_1 = true;
                                    return false;
                                case CLOSEST_SIDE:
                                    size = CSSRadialExtent.CLOSEST_SIDE;
                                    return false;
                                case COVER:
                                case FARTHEST_SIDE:
                                    size = CSSRadialExtent.FARTHEST_SIDE;
                                    return false;
                                case CONTAIN:
                                case CLOSEST_CORNER:
                                    size = CSSRadialExtent.CLOSEST_CORNER;
                                    return false;
                                case FARTHEST_CORNER:
                                    size = CSSRadialExtent.FARTHEST_CORNER;
                                    return false;
                            }
                        }
                        else if (isLength(token) || isLengthPercentage(token)) {
                            if (!Array.isArray(size)) {
                                size = [];
                            }
                            size.push(token);
                            return false;
                        }
                        return acc;
                    }, isColorStop);
                }
                if (isColorStop) {
                    var colorStop = parseColorStop(arg);
                    stops.push(colorStop);
                }
            });
            return { size: size, shape: shape, stops: stops, position: position, type: CSSImageType.RADIAL_GRADIENT };
        };

        var prefixRadialGradient = function (tokens) {
            var shape = CSSRadialShape.CIRCLE;
            var size = CSSRadialExtent.FARTHEST_CORNER;
            var stops = [];
            var position = [];
            parseFunctionArgs(tokens).forEach(function (arg, i) {
                var isColorStop = true;
                if (i === 0) {
                    isColorStop = arg.reduce(function (acc, token) {
                        if (isIdentToken(token)) {
                            switch (token.value) {
                                case 'center':
                                    position.push(FIFTY_PERCENT);
                                    return false;
                                case 'top':
                                case 'left':
                                    position.push(ZERO_LENGTH);
                                    return false;
                                case 'right':
                                case 'bottom':
                                    position.push(HUNDRED_PERCENT);
                                    return false;
                            }
                        }
                        else if (isLengthPercentage(token) || isLength(token)) {
                            position.push(token);
                            return false;
                        }
                        return acc;
                    }, isColorStop);
                }
                else if (i === 1) {
                    isColorStop = arg.reduce(function (acc, token) {
                        if (isIdentToken(token)) {
                            switch (token.value) {
                                case CIRCLE:
                                    shape = CSSRadialShape.CIRCLE;
                                    return false;
                                case ELLIPSE:
                                    shape = CSSRadialShape.ELLIPSE;
                                    return false;
                                case CONTAIN:
                                case CLOSEST_SIDE:
                                    size = CSSRadialExtent.CLOSEST_SIDE;
                                    return false;
                                case FARTHEST_SIDE:
                                    size = CSSRadialExtent.FARTHEST_SIDE;
                                    return false;
                                case CLOSEST_CORNER:
                                    size = CSSRadialExtent.CLOSEST_CORNER;
                                    return false;
                                case COVER:
                                case FARTHEST_CORNER:
                                    size = CSSRadialExtent.FARTHEST_CORNER;
                                    return false;
                            }
                        }
                        else if (isLength(token) || isLengthPercentage(token)) {
                            if (!Array.isArray(size)) {
                                size = [];
                            }
                            size.push(token);
                            return false;
                        }
                        return acc;
                    }, isColorStop);
                }
                if (isColorStop) {
                    var colorStop = parseColorStop(arg);
                    stops.push(colorStop);
                }
            });
            return { size: size, shape: shape, stops: stops, position: position, type: CSSImageType.RADIAL_GRADIENT };
        };

        var CSSImageType;
        (function (CSSImageType) {
            CSSImageType[CSSImageType["URL"] = 0] = "URL";
            CSSImageType[CSSImageType["LINEAR_GRADIENT"] = 1] = "LINEAR_GRADIENT";
            CSSImageType[CSSImageType["RADIAL_GRADIENT"] = 2] = "RADIAL_GRADIENT";
        })(CSSImageType || (CSSImageType = {}));
        var isLinearGradient = function (background) {
            return background.type === CSSImageType.LINEAR_GRADIENT;
        };
        var isRadialGradient = function (background) {
            return background.type === CSSImageType.RADIAL_GRADIENT;
        };
        var CSSRadialShape;
        (function (CSSRadialShape) {
            CSSRadialShape[CSSRadialShape["CIRCLE"] = 0] = "CIRCLE";
            CSSRadialShape[CSSRadialShape["ELLIPSE"] = 1] = "ELLIPSE";
        })(CSSRadialShape || (CSSRadialShape = {}));
        var CSSRadialExtent;
        (function (CSSRadialExtent) {
            CSSRadialExtent[CSSRadialExtent["CLOSEST_SIDE"] = 0] = "CLOSEST_SIDE";
            CSSRadialExtent[CSSRadialExtent["FARTHEST_SIDE"] = 1] = "FARTHEST_SIDE";
            CSSRadialExtent[CSSRadialExtent["CLOSEST_CORNER"] = 2] = "CLOSEST_CORNER";
            CSSRadialExtent[CSSRadialExtent["FARTHEST_CORNER"] = 3] = "FARTHEST_CORNER";
        })(CSSRadialExtent || (CSSRadialExtent = {}));
        var image = {
            name: 'image',
            parse: function (value) {
                if (value.type === TokenType.URL_TOKEN) {
                    var image_1 = { url: value.value, type: CSSImageType.URL };
                    CacheStorage.getInstance().addImage(value.value);
                    return image_1;
                }
                if (value.type === TokenType.FUNCTION) {
                    var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
                    if (typeof imageFunction === 'undefined') {
                        throw new Error("Attempting to parse an unsupported image function \"" + value.name + "\"");
                    }
                    return imageFunction(value.values);
                }
                throw new Error("Unsupported image type");
            }
        };
        function isSupportedImage(value) {
            return value.type !== TokenType.FUNCTION || SUPPORTED_IMAGE_FUNCTIONS[value.name];
        }
        var SUPPORTED_IMAGE_FUNCTIONS = {
            'linear-gradient': linearGradient,
            '-moz-linear-gradient': prefixLinearGradient,
            '-ms-linear-gradient': prefixLinearGradient,
            '-o-linear-gradient': prefixLinearGradient,
            '-webkit-linear-gradient': prefixLinearGradient,
            'radial-gradient': radialGradient,
            '-moz-radial-gradient': prefixRadialGradient,
            '-ms-radial-gradient': prefixRadialGradient,
            '-o-radial-gradient': prefixRadialGradient,
            '-webkit-radial-gradient': prefixRadialGradient,
            '-webkit-gradient': webkitGradient
        };

        var backgroundImage = {
            name: 'background-image',
            initialValue: 'none',
            type: PropertyDescriptorParsingType.LIST,
            prefix: false,
            parse: function (tokens) {
                if (tokens.length === 0) {
                    return [];
                }
                var first = tokens[0];
                if (first.type === TokenType.IDENT_TOKEN && first.value === 'none') {
                    return [];
                }
                return tokens.filter(function (value) { return nonFunctionArgSeparator(value) && isSupportedImage(value); }).map(image.parse);
            }
        };

        var backgroundOrigin = {
            name: 'background-origin',
            initialValue: 'border-box',
            prefix: false,
            type: PropertyDescriptorParsingType.LIST,
            parse: function (tokens) {
                return tokens.map(function (token) {
                    if (isIdentToken(token)) {
                        switch (token.value) {
                            case 'padding-box':
                                return 1 /* PADDING_BOX */;
                            case 'content-box':
                                return 2 /* CONTENT_BOX */;
                        }
                    }
                    return 0 /* BORDER_BOX */;
                });
            }
        };

        var backgroundPosition = {
            name: 'background-position',
            initialValue: '0% 0%',
            type: PropertyDescriptorParsingType.LIST,
            prefix: false,
            parse: function (tokens) {
                return parseFunctionArgs(tokens)
                    .map(function (values) { return values.filter(isLengthPercentage); })
                    .map(parseLengthPercentageTuple);
            }
        };

        var BACKGROUND_REPEAT;
        (function (BACKGROUND_REPEAT) {
            BACKGROUND_REPEAT[BACKGROUND_REPEAT["REPEAT"] = 0] = "REPEAT";
            BACKGROUND_REPEAT[BACKGROUND_REPEAT["NO_REPEAT"] = 1] = "NO_REPEAT";
            BACKGROUND_REPEAT[BACKGROUND_REPEAT["REPEAT_X"] = 2] = "REPEAT_X";
            BACKGROUND_REPEAT[BACKGROUND_REPEAT["REPEAT_Y"] = 3] = "REPEAT_Y";
        })(BACKGROUND_REPEAT || (BACKGROUND_REPEAT = {}));
        var backgroundRepeat = {
            name: 'background-repeat',
            initialValue: 'repeat',
            prefix: false,
            type: PropertyDescriptorParsingType.LIST,
            parse: function (tokens) {
                return parseFunctionArgs(tokens)
                    .map(function (values) {
                    return values
                        .filter(isIdentToken)
                        .map(function (token) { return token.value; })
                        .join(' ');
                })
                    .map(parseBackgroundRepeat);
            }
        };
        var parseBackgroundRepeat = function (value) {
            switch (value) {
                case 'no-repeat':
                    return BACKGROUND_REPEAT.NO_REPEAT;
                case 'repeat-x':
                case 'repeat no-repeat':
                    return BACKGROUND_REPEAT.REPEAT_X;
                case 'repeat-y':
                case 'no-repeat repeat':
                    return BACKGROUND_REPEAT.REPEAT_Y;
                case 'repeat':
                default:
                    return BACKGROUND_REPEAT.REPEAT;
            }
        };

        var BACKGROUND_SIZE;
        (function (BACKGROUND_SIZE) {
            BACKGROUND_SIZE["AUTO"] = "auto";
            BACKGROUND_SIZE["CONTAIN"] = "contain";
            BACKGROUND_SIZE["COVER"] = "cover";
        })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
        var backgroundSize = {
            name: 'background-size',
            initialValue: '0',
            prefix: false,
            type: PropertyDescriptorParsingType.LIST,
            parse: function (tokens) {
                return parseFunctionArgs(tokens).map(function (values) { return values.filter(isBackgroundSizeInfoToken); });
            }
        };
        var isBackgroundSizeInfoToken = function (value) {
            return isIdentToken(value) || isLengthPercentage(value);
        };

        var borderColorForSide = function (side) { return ({
            name: "border-" + side + "-color",
            initialValue: 'transparent',
            prefix: false,
            type: PropertyDescriptorParsingType.TYPE_VALUE,
            format: 'color'
        }); };
        var borderTopColor = borderColorForSide('top');
        var borderRightColor = borderColorForSide('right');
        var borderBottomColor = borderColorForSide('bottom');
        var borderLeftColor = borderColorForSide('left');

        var borderRadiusForSide = function (side) { return ({
            name: "border-radius-" + side,
            initialValue: '0 0',
            prefix: false,
            type: PropertyDescriptorParsingType.LIST,
            parse: function (tokens) { return parseLengthPercentageTuple(tokens.filter(isLengthPercentage)); }
        }); };
        var borderTopLeftRadius = borderRadiusForSide('top-left');
        var borderTopRightRadius = borderRadiusForSide('top-right');
        var borderBottomRightRadius = borderRadiusForSide('bottom-right');
        var borderBottomLeftRadius = borderRadiusForSide('bottom-left');

        var BORDER_STYLE;
        (function (BORDER_STYLE) {
            BORDER_STYLE[BORDER_STYLE["NONE"] = 0] = "NONE";
            BORDER_STYLE[BORDER_STYLE["SOLID"] = 1] = "SOLID";
        })(BORDER_STYLE || (BORDER_STYLE = {}));
        var borderStyleForSide = function (side) { return ({
            name: "border-" + side + "-style",
            initialValue: 'solid',
            prefix: false,
            type: PropertyDescriptorParsingType.IDENT_VALUE,
            parse: function (style) {
                switch (style) {
                    case 'none':
                        return BORDER_STYLE.NONE;
                }
                return BORDER_STYLE.SOLID;
            }
        }); };
        var borderTopStyle = borderStyleForSide('top');
        var borderRightStyle = borderStyleForSide('right');
        var borderBottomStyle = borderStyleForSide('bottom');
        var borderLeftStyle = borderStyleForSide('left');

        var borderWidthForSide = function (side) { return ({
            name: "border-" + side + "-width",
            initialValue: '0',
            type: PropertyDescriptorParsingType.VALUE,
            prefix: false,
            parse: function (token) {
                if (isDimensionToken(token)) {
                    return token.number;
                }
                return 0;
            }
        }); };
        var borderTopWidth = borderWidthForSide('top');
        var borderRightWidth = borderWidthForSide('right');
        var borderBottomWidth = borderWidthForSide('bottom');
        var borderLeftWidth = borderWidthForSide('left');

        var color$1 = {
            name: "color",
            initialValue: 'transparent',
            prefix: false,
            type: PropertyDescriptorParsingType.TYPE_VALUE,
            format: 'color'
        };

        var display = {
            name: 'display',
            initialValue: 'inline-block',
            prefix: false,
            type: PropertyDescriptorParsingType.LIST,
            parse: function (tokens) {
                return tokens.filter(isIdentToken).reduce(function (bit, token) {
                    return bit | parseDisplayValue(token.value);
                }, 0 /* NONE */);
            }
        };
        var parseDisplayValue = function (display) {
            switch (display) {
                case 'block':
                    return 2 /* BLOCK */;
                case 'inline':
                    return 4 /* INLINE */;
                case 'run-in':
                    return 8 /* RUN_IN */;
                case 'flow':
                    return 16 /* FLOW */;
                case 'flow-root':
                    return 32 /* FLOW_ROOT */;
                case 'table':
                    return 64 /* TABLE */;
                case 'flex':
                case '-webkit-flex':
                    return 128 /* FLEX */;
                case 'grid':
                case '-ms-grid':
                    return 256 /* GRID */;
                case 'ruby':
                    return 512 /* RUBY */;
                case 'subgrid':
                    return 1024 /* SUBGRID */;
                case 'list-item':
                    return 2048 /* LIST_ITEM */;
                case 'table-row-group':
                    return 4096 /* TABLE_ROW_GROUP */;
                case 'table-header-group':
                    return 8192 /* TABLE_HEADER_GROUP */;
                case 'table-footer-group':
                    return 16384 /* TABLE_FOOTER_GROUP */;
                case 'table-row':
                    return 32768 /* TABLE_ROW */;
                case 'table-cell':
                    return 65536 /* TABLE_CELL */;
                case 'table-column-group':
                    return 131072 /* TABLE_COLUMN_GROUP */;
                case 'table-column':
                    return 262144 /* TABLE_COLUMN */;
                case 'table-caption':
                    return 524288 /* TABLE_CAPTION */;
                case 'ruby-base':
                    return 1048576 /* RUBY_BASE */;
                case 'ruby-text':
                    return 2097152 /* RUBY_TEXT */;
                case 'ruby-base-container':
                    return 4194304 /* RUBY_BASE_CONTAINER */;
                case 'ruby-text-container':
                    return 8388608 /* RUBY_TEXT_CONTAINER */;
                case 'contents':
                    return 16777216 /* CONTENTS */;
                case 'inline-block':
                    return 33554432 /* INLINE_BLOCK */;
                case 'inline-list-item':
                    return 67108864 /* INLINE_LIST_ITEM */;
                case 'inline-table':
                    return 134217728 /* INLINE_TABLE */;
                case 'inline-flex':
                    return 268435456 /* INLINE_FLEX */;
                case 'inline-grid':
                    return 536870912 /* INLINE_GRID */;
            }
            return 0 /* NONE */;
        };

        var FLOAT;
        (function (FLOAT) {
            FLOAT[FLOAT["NONE"] = 0] = "NONE";
            FLOAT[FLOAT["LEFT"] = 1] = "LEFT";
            FLOAT[FLOAT["RIGHT"] = 2] = "RIGHT";
            FLOAT[FLOAT["INLINE_START"] = 3] = "INLINE_START";
            FLOAT[FLOAT["INLINE_END"] = 4] = "INLINE_END";
        })(FLOAT || (FLOAT = {}));
        var float = {
            name: 'float',
            initialValue: 'none',
            prefix: false,
            type: PropertyDescriptorParsingType.IDENT_VALUE,
            parse: function (float) {
                switch (float) {
                    case 'left':
                        return FLOAT.LEFT;
                    case 'right':
                        return FLOAT.RIGHT;
                    case 'inline-start':
                        return FLOAT.INLINE_START;
                    case 'inline-end':
                        return FLOAT.INLINE_END;
                }
                return FLOAT.NONE;
            }
        };

        var letterSpacing = {
            name: 'letter-spacing',
            initialValue: '0',
            prefix: false,
            type: PropertyDescriptorParsingType.VALUE,
            parse: function (token) {
                if (token.type === TokenType.IDENT_TOKEN && token.value === 'normal') {
                    return 0;
                }
                if (token.type === TokenType.NUMBER_TOKEN) {
                    return token.number;
                }
                if (token.type === TokenType.DIMENSION_TOKEN) {
                    return token.number;
                }
                return 0;
            }
        };

        var LINE_BREAK;
        (function (LINE_BREAK) {
            LINE_BREAK["NORMAL"] = "normal";
            LINE_BREAK["STRICT"] = "strict";
        })(LINE_BREAK || (LINE_BREAK = {}));
        var lineBreak = {
            name: 'line-break',
            initialValue: 'normal',
            prefix: false,
            type: PropertyDescriptorParsingType.IDENT_VALUE,
            parse: function (lineBreak) {
                switch (lineBreak) {
                    case 'strict':
                        return LINE_BREAK.STRICT;
                    case 'normal':
                    default:
                        return LINE_BREAK.NORMAL;
                }
            }
        };

        var lineHeight = {
            name: 'line-height',
            initialValue: 'normal',
            prefix: false,
            type: PropertyDescriptorParsingType.TOKEN_VALUE
        };
        var computeLineHeight = function (token, fontSize) {
            if (isIdentToken(token) && token.value === 'normal') {
                return 1.2 * fontSize;
            }
            else if (token.type === TokenType.NUMBER_TOKEN) {
                return fontSize * token.number;
            }
            else if (isLengthPercentage(token)) {
                return getAbsoluteValue(token, fontSize);
            }
            return fontSize;
        };

        var listStyleImage = {
            name: 'list-style-image',
            initialValue: 'none',
            type: PropertyDescriptorParsingType.VALUE,
            prefix: false,
            parse: function (token) {
                if (token.type === TokenType.IDENT_TOKEN && token.value === 'none') {
                    return null;
                }
                return image.parse(token);
            }
        };

        var LIST_STYLE_POSITION;
        (function (LIST_STYLE_POSITION) {
            LIST_STYLE_POSITION[LIST_STYLE_POSITION["INSIDE"] = 0] = "INSIDE";
            LIST_STYLE_POSITION[LIST_STYLE_POSITION["OUTSIDE"] = 1] = "OUTSIDE";
        })(LIST_STYLE_POSITION || (LIST_STYLE_POSITION = {}));
        var listStylePosition = {
            name: 'list-style-position',
            initialValue: 'outside',
            prefix: false,
            type: PropertyDescriptorParsingType.IDENT_VALUE,
            parse: function (position) {
                switch (position) {
                    case 'inside':
                        return LIST_STYLE_POSITION.INSIDE;
                    case 'outside':
                    default:
                        return LIST_STYLE_POSITION.OUTSIDE;
                }
            }
        };

        var LIST_STYLE_TYPE;
        (function (LIST_STYLE_TYPE) {
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["NONE"] = -1] = "NONE";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["DISC"] = 0] = "DISC";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["CIRCLE"] = 1] = "CIRCLE";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["SQUARE"] = 2] = "SQUARE";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["DECIMAL"] = 3] = "DECIMAL";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["CJK_DECIMAL"] = 4] = "CJK_DECIMAL";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["DECIMAL_LEADING_ZERO"] = 5] = "DECIMAL_LEADING_ZERO";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["LOWER_ROMAN"] = 6] = "LOWER_ROMAN";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["UPPER_ROMAN"] = 7] = "UPPER_ROMAN";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["LOWER_GREEK"] = 8] = "LOWER_GREEK";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["LOWER_ALPHA"] = 9] = "LOWER_ALPHA";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["UPPER_ALPHA"] = 10] = "UPPER_ALPHA";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["ARABIC_INDIC"] = 11] = "ARABIC_INDIC";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["ARMENIAN"] = 12] = "ARMENIAN";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["BENGALI"] = 13] = "BENGALI";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["CAMBODIAN"] = 14] = "CAMBODIAN";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["CJK_EARTHLY_BRANCH"] = 15] = "CJK_EARTHLY_BRANCH";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["CJK_HEAVENLY_STEM"] = 16] = "CJK_HEAVENLY_STEM";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["CJK_IDEOGRAPHIC"] = 17] = "CJK_IDEOGRAPHIC";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["DEVANAGARI"] = 18] = "DEVANAGARI";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["ETHIOPIC_NUMERIC"] = 19] = "ETHIOPIC_NUMERIC";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["GEORGIAN"] = 20] = "GEORGIAN";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["GUJARATI"] = 21] = "GUJARATI";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["GURMUKHI"] = 22] = "GURMUKHI";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["HEBREW"] = 22] = "HEBREW";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["HIRAGANA"] = 23] = "HIRAGANA";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["HIRAGANA_IROHA"] = 24] = "HIRAGANA_IROHA";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["JAPANESE_FORMAL"] = 25] = "JAPANESE_FORMAL";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["JAPANESE_INFORMAL"] = 26] = "JAPANESE_INFORMAL";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["KANNADA"] = 27] = "KANNADA";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["KATAKANA"] = 28] = "KATAKANA";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["KATAKANA_IROHA"] = 29] = "KATAKANA_IROHA";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["KHMER"] = 30] = "KHMER";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["KOREAN_HANGUL_FORMAL"] = 31] = "KOREAN_HANGUL_FORMAL";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["KOREAN_HANJA_FORMAL"] = 32] = "KOREAN_HANJA_FORMAL";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["KOREAN_HANJA_INFORMAL"] = 33] = "KOREAN_HANJA_INFORMAL";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["LAO"] = 34] = "LAO";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["LOWER_ARMENIAN"] = 35] = "LOWER_ARMENIAN";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["MALAYALAM"] = 36] = "MALAYALAM";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["MONGOLIAN"] = 37] = "MONGOLIAN";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["MYANMAR"] = 38] = "MYANMAR";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["ORIYA"] = 39] = "ORIYA";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["PERSIAN"] = 40] = "PERSIAN";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["SIMP_CHINESE_FORMAL"] = 41] = "SIMP_CHINESE_FORMAL";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["SIMP_CHINESE_INFORMAL"] = 42] = "SIMP_CHINESE_INFORMAL";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["TAMIL"] = 43] = "TAMIL";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["TELUGU"] = 44] = "TELUGU";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["THAI"] = 45] = "THAI";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["TIBETAN"] = 46] = "TIBETAN";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["TRAD_CHINESE_FORMAL"] = 47] = "TRAD_CHINESE_FORMAL";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["TRAD_CHINESE_INFORMAL"] = 48] = "TRAD_CHINESE_INFORMAL";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["UPPER_ARMENIAN"] = 49] = "UPPER_ARMENIAN";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["DISCLOSURE_OPEN"] = 50] = "DISCLOSURE_OPEN";
            LIST_STYLE_TYPE[LIST_STYLE_TYPE["DISCLOSURE_CLOSED"] = 51] = "DISCLOSURE_CLOSED";
        })(LIST_STYLE_TYPE || (LIST_STYLE_TYPE = {}));
        var listStyleType = {
            name: 'list-style-type',
            initialValue: 'none',
            prefix: false,
            type: PropertyDescriptorParsingType.IDENT_VALUE,
            parse: function (type) {
                switch (type) {
                    case 'disc':
                        return LIST_STYLE_TYPE.DISC;
                    case 'circle':
                        return LIST_STYLE_TYPE.CIRCLE;
                    case 'square':
                        return LIST_STYLE_TYPE.SQUARE;
                    case 'decimal':
                        return LIST_STYLE_TYPE.DECIMAL;
                    case 'cjk-decimal':
                        return LIST_STYLE_TYPE.CJK_DECIMAL;
                    case 'decimal-leading-zero':
                        return LIST_STYLE_TYPE.DECIMAL_LEADING_ZERO;
                    case 'lower-roman':
                        return LIST_STYLE_TYPE.LOWER_ROMAN;
                    case 'upper-roman':
                        return LIST_STYLE_TYPE.UPPER_ROMAN;
                    case 'lower-greek':
                        return LIST_STYLE_TYPE.LOWER_GREEK;
                    case 'lower-alpha':
                        return LIST_STYLE_TYPE.LOWER_ALPHA;
                    case 'upper-alpha':
                        return LIST_STYLE_TYPE.UPPER_ALPHA;
                    case 'arabic-indic':
                        return LIST_STYLE_TYPE.ARABIC_INDIC;
                    case 'armenian':
                        return LIST_STYLE_TYPE.ARMENIAN;
                    case 'bengali':
                        return LIST_STYLE_TYPE.BENGALI;
                    case 'cambodian':
                        return LIST_STYLE_TYPE.CAMBODIAN;
                    case 'cjk-earthly-branch':
                        return LIST_STYLE_TYPE.CJK_EARTHLY_BRANCH;
                    case 'cjk-heavenly-stem':
                        return LIST_STYLE_TYPE.CJK_HEAVENLY_STEM;
                    case 'cjk-ideographic':
                        return LIST_STYLE_TYPE.CJK_IDEOGRAPHIC;
                    case 'devanagari':
                        return LIST_STYLE_TYPE.DEVANAGARI;
                    case 'ethiopic-numeric':
                        return LIST_STYLE_TYPE.ETHIOPIC_NUMERIC;
                    case 'georgian':
                        return LIST_STYLE_TYPE.GEORGIAN;
                    case 'gujarati':
                        return LIST_STYLE_TYPE.GUJARATI;
                    case 'gurmukhi':
                        return LIST_STYLE_TYPE.GURMUKHI;
                    case 'hebrew':
                        return LIST_STYLE_TYPE.HEBREW;
                    case 'hiragana':
                        return LIST_STYLE_TYPE.HIRAGANA;
                    case 'hiragana-iroha':
                        return LIST_STYLE_TYPE.HIRAGANA_IROHA;
                    case 'japanese-formal':
                        return LIST_STYLE_TYPE.JAPANESE_FORMAL;
                    case 'japanese-informal':
                        return LIST_STYLE_TYPE.JAPANESE_INFORMAL;
                    case 'kannada':
                        return LIST_STYLE_TYPE.KANNADA;
                    case 'katakana':
                        return LIST_STYLE_TYPE.KATAKANA;
                    case 'katakana-iroha':
                        return LIST_STYLE_TYPE.KATAKANA_IROHA;
                    case 'khmer':
                        return LIST_STYLE_TYPE.KHMER;
                    case 'korean-hangul-formal':
                        return LIST_STYLE_TYPE.KOREAN_HANGUL_FORMAL;
                    case 'korean-hanja-formal':
                        return LIST_STYLE_TYPE.KOREAN_HANJA_FORMAL;
                    case 'korean-hanja-informal':
                        return LIST_STYLE_TYPE.KOREAN_HANJA_INFORMAL;
                    case 'lao':
                        return LIST_STYLE_TYPE.LAO;
                    case 'lower-armenian':
                        return LIST_STYLE_TYPE.LOWER_ARMENIAN;
                    case 'malayalam':
                        return LIST_STYLE_TYPE.MALAYALAM;
                    case 'mongolian':
                        return LIST_STYLE_TYPE.MONGOLIAN;
                    case 'myanmar':
                        return LIST_STYLE_TYPE.MYANMAR;
                    case 'oriya':
                        return LIST_STYLE_TYPE.ORIYA;
                    case 'persian':
                        return LIST_STYLE_TYPE.PERSIAN;
                    case 'simp-chinese-formal':
                        return LIST_STYLE_TYPE.SIMP_CHINESE_FORMAL;
                    case 'simp-chinese-informal':
                        return LIST_STYLE_TYPE.SIMP_CHINESE_INFORMAL;
                    case 'tamil':
                        return LIST_STYLE_TYPE.TAMIL;
                    case 'telugu':
                        return LIST_STYLE_TYPE.TELUGU;
                    case 'thai':
                        return LIST_STYLE_TYPE.THAI;
                    case 'tibetan':
                        return LIST_STYLE_TYPE.TIBETAN;
                    case 'trad-chinese-formal':
                        return LIST_STYLE_TYPE.TRAD_CHINESE_FORMAL;
                    case 'trad-chinese-informal':
                        return LIST_STYLE_TYPE.TRAD_CHINESE_INFORMAL;
                    case 'upper-armenian':
                        return LIST_STYLE_TYPE.UPPER_ARMENIAN;
                    case 'disclosure-open':
                        return LIST_STYLE_TYPE.DISCLOSURE_OPEN;
                    case 'disclosure-closed':
                        return LIST_STYLE_TYPE.DISCLOSURE_CLOSED;
                    case 'none':
                    default:
                        return LIST_STYLE_TYPE.NONE;
                }
            }
        };

        var marginForSide = function (side) { return ({
            name: "margin-" + side,
            initialValue: '0',
            prefix: false,
            type: PropertyDescriptorParsingType.TOKEN_VALUE
        }); };
        var marginTop = marginForSide('top');
        var marginRight = marginForSide('right');
        var marginBottom = marginForSide('bottom');
        var marginLeft = marginForSide('left');

        var OVERFLOW;
        (function (OVERFLOW) {
            OVERFLOW[OVERFLOW["VISIBLE"] = 0] = "VISIBLE";
            OVERFLOW[OVERFLOW["HIDDEN"] = 1] = "HIDDEN";
            OVERFLOW[OVERFLOW["SCROLL"] = 2] = "SCROLL";
            OVERFLOW[OVERFLOW["AUTO"] = 3] = "AUTO";
        })(OVERFLOW || (OVERFLOW = {}));
        var overflow = {
            name: 'overflow',
            initialValue: 'visible',
            prefix: false,
            type: PropertyDescriptorParsingType.LIST,
            parse: function (tokens) {
                return tokens.filter(isIdentToken).map(function (overflow) {
                    switch (overflow.value) {
                        case 'hidden':
                            return OVERFLOW.HIDDEN;
                        case 'scroll':
                            return OVERFLOW.SCROLL;
                        case 'auto':
                            return OVERFLOW.AUTO;
                        case 'visible':
                        default:
                            return OVERFLOW.VISIBLE;
                    }
                });
            }
        };

        var OVERFLOW_WRAP;
        (function (OVERFLOW_WRAP) {
            OVERFLOW_WRAP["NORMAL"] = "normal";
            OVERFLOW_WRAP["BREAK_WORD"] = "break-word";
        })(OVERFLOW_WRAP || (OVERFLOW_WRAP = {}));
        var overflowWrap = {
            name: 'overflow-wrap',
            initialValue: 'normal',
            prefix: false,
            type: PropertyDescriptorParsingType.IDENT_VALUE,
            parse: function (overflow) {
                switch (overflow) {
                    case 'break-word':
                        return OVERFLOW_WRAP.BREAK_WORD;
                    case 'normal':
                    default:
                        return OVERFLOW_WRAP.NORMAL;
                }
            }
        };

        var paddingForSide = function (side) { return ({
            name: "padding-" + side,
            initialValue: '0',
            prefix: false,
            type: PropertyDescriptorParsingType.TYPE_VALUE,
            format: 'length-percentage'
        }); };
        var paddingTop = paddingForSide('top');
        var paddingRight = paddingForSide('right');
        var paddingBottom = paddingForSide('bottom');
        var paddingLeft = paddingForSide('left');

        var TEXT_ALIGN;
        (function (TEXT_ALIGN) {
            TEXT_ALIGN[TEXT_ALIGN["LEFT"] = 0] = "LEFT";
            TEXT_ALIGN[TEXT_ALIGN["CENTER"] = 1] = "CENTER";
            TEXT_ALIGN[TEXT_ALIGN["RIGHT"] = 2] = "RIGHT";
        })(TEXT_ALIGN || (TEXT_ALIGN = {}));
        var textAlign = {
            name: 'text-align',
            initialValue: 'left',
            prefix: false,
            type: PropertyDescriptorParsingType.IDENT_VALUE,
            parse: function (textAlign) {
                switch (textAlign) {
                    case 'right':
                        return TEXT_ALIGN.RIGHT;
                    case 'center':
                    case 'justify':
                        return TEXT_ALIGN.CENTER;
                    case 'left':
                    default:
                        return TEXT_ALIGN.LEFT;
                }
            }
        };

        var POSITION;
        (function (POSITION) {
            POSITION[POSITION["STATIC"] = 0] = "STATIC";
            POSITION[POSITION["RELATIVE"] = 1] = "RELATIVE";
            POSITION[POSITION["ABSOLUTE"] = 2] = "ABSOLUTE";
            POSITION[POSITION["FIXED"] = 3] = "FIXED";
            POSITION[POSITION["STICKY"] = 4] = "STICKY";
        })(POSITION || (POSITION = {}));
        var position = {
            name: 'position',
            initialValue: 'static',
            prefix: false,
            type: PropertyDescriptorParsingType.IDENT_VALUE,
            parse: function (position) {
                switch (position) {
                    case 'relative':
                        return POSITION.RELATIVE;
                    case 'absolute':
                        return POSITION.ABSOLUTE;
                    case 'fixed':
                        return POSITION.FIXED;
                    case 'sticky':
                        return POSITION.STICKY;
                }
                return POSITION.STATIC;
            }
        };

        var textShadow = {
            name: 'text-shadow',
            initialValue: 'none',
            type: PropertyDescriptorParsingType.LIST,
            prefix: false,
            parse: function (tokens) {
                if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {
                    return [];
                }
                return parseFunctionArgs(tokens).map(function (values) {
                    var shadow = {
                        color: COLORS.TRANSPARENT,
                        offsetX: ZERO_LENGTH,
                        offsetY: ZERO_LENGTH,
                        blur: ZERO_LENGTH
                    };
                    var c = 0;
                    for (var i = 0; i < values.length; i++) {
                        var token = values[i];
                        if (isLength(token)) {
                            if (c === 0) {
                                shadow.offsetX = token;
                            }
                            else if (c === 1) {
                                shadow.offsetY = token;
                            }
                            else {
                                shadow.blur = token;
                            }
                            c++;
                        }
                        else {
                            shadow.color = color.parse(token);
                        }
                    }
                    return shadow;
                });
            }
        };

        var TEXT_TRANSFORM;
        (function (TEXT_TRANSFORM) {
            TEXT_TRANSFORM[TEXT_TRANSFORM["NONE"] = 0] = "NONE";
            TEXT_TRANSFORM[TEXT_TRANSFORM["LOWERCASE"] = 1] = "LOWERCASE";
            TEXT_TRANSFORM[TEXT_TRANSFORM["UPPERCASE"] = 2] = "UPPERCASE";
            TEXT_TRANSFORM[TEXT_TRANSFORM["CAPITALIZE"] = 3] = "CAPITALIZE";
        })(TEXT_TRANSFORM || (TEXT_TRANSFORM = {}));
        var textTransform = {
            name: 'text-transform',
            initialValue: 'none',
            prefix: false,
            type: PropertyDescriptorParsingType.IDENT_VALUE,
            parse: function (textTransform) {
                switch (textTransform) {
                    case 'uppercase':
                        return TEXT_TRANSFORM.UPPERCASE;
                    case 'lowercase':
                        return TEXT_TRANSFORM.LOWERCASE;
                    case 'capitalize':
                        return TEXT_TRANSFORM.CAPITALIZE;
                }
                return TEXT_TRANSFORM.NONE;
            }
        };

        var transform = {
            name: 'transform',
            initialValue: 'none',
            prefix: true,
            type: PropertyDescriptorParsingType.VALUE,
            parse: function (token) {
                if (token.type === TokenType.IDENT_TOKEN && token.value === 'none') {
                    return null;
                }
                if (token.type === TokenType.FUNCTION) {
                    var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
                    if (typeof transformFunction === 'undefined') {
                        throw new Error("Attempting to parse an unsupported transform function \"" + token.name + "\"");
                    }
                    return transformFunction(token.values);
                }
                return null;
            }
        };
        var matrix = function (args) {
            var values = args.filter(function (arg) { return arg.type === TokenType.NUMBER_TOKEN; }).map(function (arg) { return arg.number; });
            return values.length === 6 ? values : null;
        };
        // doesn't support 3D transforms at the moment
        var matrix3d = function (args) {
            var values = args.filter(function (arg) { return arg.type === TokenType.NUMBER_TOKEN; }).map(function (arg) { return arg.number; });
            var a1 = values[0], b1 = values[1]; values[2]; values[3]; var a2 = values[4], b2 = values[5]; values[6]; values[7]; values[8]; values[9]; values[10]; values[11]; var a4 = values[12], b4 = values[13]; values[14]; values[15];
            return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
        };
        var SUPPORTED_TRANSFORM_FUNCTIONS = {
            matrix: matrix,
            matrix3d: matrix3d
        };

        var DEFAULT_VALUE = {
            type: TokenType.PERCENTAGE_TOKEN,
            number: 50,
            flags: FLAG_INTEGER
        };
        var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
        var transformOrigin = {
            name: 'transform-origin',
            initialValue: '50% 50%',
            prefix: true,
            type: PropertyDescriptorParsingType.LIST,
            parse: function (tokens) {
                var origins = tokens.filter(isLengthPercentage);
                if (origins.length !== 2) {
                    return DEFAULT;
                }
                return [origins[0], origins[1]];
            }
        };

        var VISIBILITY;
        (function (VISIBILITY) {
            VISIBILITY[VISIBILITY["VISIBLE"] = 0] = "VISIBLE";
            VISIBILITY[VISIBILITY["HIDDEN"] = 1] = "HIDDEN";
            VISIBILITY[VISIBILITY["COLLAPSE"] = 2] = "COLLAPSE";
        })(VISIBILITY || (VISIBILITY = {}));
        var visibility = {
            name: 'visible',
            initialValue: 'none',
            prefix: false,
            type: PropertyDescriptorParsingType.IDENT_VALUE,
            parse: function (visibility) {
                switch (visibility) {
                    case 'hidden':
                        return VISIBILITY.HIDDEN;
                    case 'collapse':
                        return VISIBILITY.COLLAPSE;
                    case 'visible':
                    default:
                        return VISIBILITY.VISIBLE;
                }
            }
        };

        var WORD_BREAK;
        (function (WORD_BREAK) {
            WORD_BREAK["NORMAL"] = "normal";
            WORD_BREAK["BREAK_ALL"] = "break-all";
            WORD_BREAK["KEEP_ALL"] = "keep-all";
        })(WORD_BREAK || (WORD_BREAK = {}));
        var wordBreak = {
            name: 'word-break',
            initialValue: 'normal',
            prefix: false,
            type: PropertyDescriptorParsingType.IDENT_VALUE,
            parse: function (wordBreak) {
                switch (wordBreak) {
                    case 'break-all':
                        return WORD_BREAK.BREAK_ALL;
                    case 'keep-all':
                        return WORD_BREAK.KEEP_ALL;
                    case 'normal':
                    default:
                        return WORD_BREAK.NORMAL;
                }
            }
        };

        var zIndex = {
            name: 'z-index',
            initialValue: 'auto',
            prefix: false,
            type: PropertyDescriptorParsingType.VALUE,
            parse: function (token) {
                if (token.type === TokenType.IDENT_TOKEN) {
                    return { auto: true, order: 0 };
                }
                if (isNumberToken(token)) {
                    return { auto: false, order: token.number };
                }
                throw new Error("Invalid z-index number parsed");
            }
        };

        var opacity = {
            name: 'opacity',
            initialValue: '1',
            type: PropertyDescriptorParsingType.VALUE,
            prefix: false,
            parse: function (token) {
                if (isNumberToken(token)) {
                    return token.number;
                }
                return 1;
            }
        };

        var textDecorationColor = {
            name: "text-decoration-color",
            initialValue: 'transparent',
            prefix: false,
            type: PropertyDescriptorParsingType.TYPE_VALUE,
            format: 'color'
        };

        var textDecorationLine = {
            name: 'text-decoration-line',
            initialValue: 'none',
            prefix: false,
            type: PropertyDescriptorParsingType.LIST,
            parse: function (tokens) {
                return tokens
                    .filter(isIdentToken)
                    .map(function (token) {
                    switch (token.value) {
                        case 'underline':
                            return 1 /* UNDERLINE */;
                        case 'overline':
                            return 2 /* OVERLINE */;
                        case 'line-through':
                            return 3 /* LINE_THROUGH */;
                        case 'none':
                            return 4 /* BLINK */;
                    }
                    return 0 /* NONE */;
                })
                    .filter(function (line) { return line !== 0 /* NONE */; });
            }
        };

        var fontFamily = {
            name: "font-family",
            initialValue: '',
            prefix: false,
            type: PropertyDescriptorParsingType.LIST,
            parse: function (tokens) {
                var accumulator = [];
                var results = [];
                tokens.forEach(function (token) {
                    switch (token.type) {
                        case TokenType.IDENT_TOKEN:
                        case TokenType.STRING_TOKEN:
                            accumulator.push(token.value);
                            break;
                        case TokenType.NUMBER_TOKEN:
                            accumulator.push(token.number.toString());
                            break;
                        case TokenType.COMMA_TOKEN:
                            results.push(accumulator.join(' '));
                            accumulator.length = 0;
                            break;
                    }
                });
                if (accumulator.length) {
                    results.push(accumulator.join(' '));
                }
                return results.map(function (result) { return (result.indexOf(' ') === -1 ? result : "'" + result + "'"); });
            }
        };

        var fontSize = {
            name: "font-size",
            initialValue: '0',
            prefix: false,
            type: PropertyDescriptorParsingType.TYPE_VALUE,
            format: 'length'
        };

        var fontWeight = {
            name: 'font-weight',
            initialValue: 'normal',
            type: PropertyDescriptorParsingType.VALUE,
            prefix: false,
            parse: function (token) {
                if (isNumberToken(token)) {
                    return token.number;
                }
                if (isIdentToken(token)) {
                    switch (token.value) {
                        case 'bold':
                            return 700;
                        case 'normal':
                        default:
                            return 400;
                    }
                }
                return 400;
            }
        };

        var fontVariant = {
            name: 'font-variant',
            initialValue: 'none',
            type: PropertyDescriptorParsingType.LIST,
            prefix: false,
            parse: function (tokens) {
                return tokens.filter(isIdentToken).map(function (token) { return token.value; });
            }
        };

        var FONT_STYLE;
        (function (FONT_STYLE) {
            FONT_STYLE["NORMAL"] = "normal";
            FONT_STYLE["ITALIC"] = "italic";
            FONT_STYLE["OBLIQUE"] = "oblique";
        })(FONT_STYLE || (FONT_STYLE = {}));
        var fontStyle = {
            name: 'font-style',
            initialValue: 'normal',
            prefix: false,
            type: PropertyDescriptorParsingType.IDENT_VALUE,
            parse: function (overflow) {
                switch (overflow) {
                    case 'oblique':
                        return FONT_STYLE.OBLIQUE;
                    case 'italic':
                        return FONT_STYLE.ITALIC;
                    case 'normal':
                    default:
                        return FONT_STYLE.NORMAL;
                }
            }
        };

        var contains = function (bit, value) { return (bit & value) !== 0; };

        var content = {
            name: 'content',
            initialValue: 'none',
            type: PropertyDescriptorParsingType.LIST,
            prefix: false,
            parse: function (tokens) {
                if (tokens.length === 0) {
                    return [];
                }
                var first = tokens[0];
                if (first.type === TokenType.IDENT_TOKEN && first.value === 'none') {
                    return [];
                }
                return tokens;
            }
        };

        var counterIncrement = {
            name: 'counter-increment',
            initialValue: 'none',
            prefix: true,
            type: PropertyDescriptorParsingType.LIST,
            parse: function (tokens) {
                if (tokens.length === 0) {
                    return null;
                }
                var first = tokens[0];
                if (first.type === TokenType.IDENT_TOKEN && first.value === 'none') {
                    return null;
                }
                var increments = [];
                var filtered = tokens.filter(nonWhiteSpace);
                for (var i = 0; i < filtered.length; i++) {
                    var counter = filtered[i];
                    var next = filtered[i + 1];
                    if (counter.type === TokenType.IDENT_TOKEN) {
                        var increment = next && isNumberToken(next) ? next.number : 1;
                        increments.push({ counter: counter.value, increment: increment });
                    }
                }
                return increments;
            }
        };

        var counterReset = {
            name: 'counter-reset',
            initialValue: 'none',
            prefix: true,
            type: PropertyDescriptorParsingType.LIST,
            parse: function (tokens) {
                if (tokens.length === 0) {
                    return [];
                }
                var resets = [];
                var filtered = tokens.filter(nonWhiteSpace);
                for (var i = 0; i < filtered.length; i++) {
                    var counter = filtered[i];
                    var next = filtered[i + 1];
                    if (isIdentToken(counter) && counter.value !== 'none') {
                        var reset = next && isNumberToken(next) ? next.number : 0;
                        resets.push({ counter: counter.value, reset: reset });
                    }
                }
                return resets;
            }
        };

        var quotes = {
            name: 'quotes',
            initialValue: 'none',
            prefix: true,
            type: PropertyDescriptorParsingType.LIST,
            parse: function (tokens) {
                if (tokens.length === 0) {
                    return null;
                }
                var first = tokens[0];
                if (first.type === TokenType.IDENT_TOKEN && first.value === 'none') {
                    return null;
                }
                var quotes = [];
                var filtered = tokens.filter(isStringToken);
                if (filtered.length % 2 !== 0) {
                    return null;
                }
                for (var i = 0; i < filtered.length; i += 2) {
                    var open_1 = filtered[i].value;
                    var close_1 = filtered[i + 1].value;
                    quotes.push({ open: open_1, close: close_1 });
                }
                return quotes;
            }
        };
        var getQuote = function (quotes, depth, open) {
            if (!quotes) {
                return '';
            }
            var quote = quotes[Math.min(depth, quotes.length - 1)];
            if (!quote) {
                return '';
            }
            return open ? quote.open : quote.close;
        };

        var boxShadow = {
            name: 'box-shadow',
            initialValue: 'none',
            type: PropertyDescriptorParsingType.LIST,
            prefix: false,
            parse: function (tokens) {
                if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {
                    return [];
                }
                return parseFunctionArgs(tokens).map(function (values) {
                    var shadow = {
                        color: 0x000000ff,
                        offsetX: ZERO_LENGTH,
                        offsetY: ZERO_LENGTH,
                        blur: ZERO_LENGTH,
                        spread: ZERO_LENGTH,
                        inset: false
                    };
                    var c = 0;
                    for (var i = 0; i < values.length; i++) {
                        var token = values[i];
                        if (isIdentWithValue(token, 'inset')) {
                            shadow.inset = true;
                        }
                        else if (isLength(token)) {
                            if (c === 0) {
                                shadow.offsetX = token;
                            }
                            else if (c === 1) {
                                shadow.offsetY = token;
                            }
                            else if (c === 2) {
                                shadow.blur = token;
                            }
                            else {
                                shadow.spread = token;
                            }
                            c++;
                        }
                        else {
                            shadow.color = color.parse(token);
                        }
                    }
                    return shadow;
                });
            }
        };

        var CSSParsedDeclaration = /** @class */ (function () {
            function CSSParsedDeclaration(declaration) {
                this.backgroundClip = parse(backgroundClip, declaration.backgroundClip);
                this.backgroundColor = parse(backgroundColor, declaration.backgroundColor);
                this.backgroundImage = parse(backgroundImage, declaration.backgroundImage);
                this.backgroundOrigin = parse(backgroundOrigin, declaration.backgroundOrigin);
                this.backgroundPosition = parse(backgroundPosition, declaration.backgroundPosition);
                this.backgroundRepeat = parse(backgroundRepeat, declaration.backgroundRepeat);
                this.backgroundSize = parse(backgroundSize, declaration.backgroundSize);
                this.borderTopColor = parse(borderTopColor, declaration.borderTopColor);
                this.borderRightColor = parse(borderRightColor, declaration.borderRightColor);
                this.borderBottomColor = parse(borderBottomColor, declaration.borderBottomColor);
                this.borderLeftColor = parse(borderLeftColor, declaration.borderLeftColor);
                this.borderTopLeftRadius = parse(borderTopLeftRadius, declaration.borderTopLeftRadius);
                this.borderTopRightRadius = parse(borderTopRightRadius, declaration.borderTopRightRadius);
                this.borderBottomRightRadius = parse(borderBottomRightRadius, declaration.borderBottomRightRadius);
                this.borderBottomLeftRadius = parse(borderBottomLeftRadius, declaration.borderBottomLeftRadius);
                this.borderTopStyle = parse(borderTopStyle, declaration.borderTopStyle);
                this.borderRightStyle = parse(borderRightStyle, declaration.borderRightStyle);
                this.borderBottomStyle = parse(borderBottomStyle, declaration.borderBottomStyle);
                this.borderLeftStyle = parse(borderLeftStyle, declaration.borderLeftStyle);
                this.borderTopWidth = parse(borderTopWidth, declaration.borderTopWidth);
                this.borderRightWidth = parse(borderRightWidth, declaration.borderRightWidth);
                this.borderBottomWidth = parse(borderBottomWidth, declaration.borderBottomWidth);
                this.borderLeftWidth = parse(borderLeftWidth, declaration.borderLeftWidth);
                this.boxShadow = parse(boxShadow, declaration.boxShadow);
                this.color = parse(color$1, declaration.color);
                this.display = parse(display, declaration.display);
                this.float = parse(float, declaration.cssFloat);
                this.fontFamily = parse(fontFamily, declaration.fontFamily);
                this.fontSize = parse(fontSize, declaration.fontSize);
                this.fontStyle = parse(fontStyle, declaration.fontStyle);
                this.fontVariant = parse(fontVariant, declaration.fontVariant);
                this.fontWeight = parse(fontWeight, declaration.fontWeight);
                this.letterSpacing = parse(letterSpacing, declaration.letterSpacing);
                this.lineBreak = parse(lineBreak, declaration.lineBreak);
                this.lineHeight = parse(lineHeight, declaration.lineHeight);
                this.listStyleImage = parse(listStyleImage, declaration.listStyleImage);
                this.listStylePosition = parse(listStylePosition, declaration.listStylePosition);
                this.listStyleType = parse(listStyleType, declaration.listStyleType);
                this.marginTop = parse(marginTop, declaration.marginTop);
                this.marginRight = parse(marginRight, declaration.marginRight);
                this.marginBottom = parse(marginBottom, declaration.marginBottom);
                this.marginLeft = parse(marginLeft, declaration.marginLeft);
                this.opacity = parse(opacity, declaration.opacity);
                var overflowTuple = parse(overflow, declaration.overflow);
                this.overflowX = overflowTuple[0];
                this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
                this.overflowWrap = parse(overflowWrap, declaration.overflowWrap);
                this.paddingTop = parse(paddingTop, declaration.paddingTop);
                this.paddingRight = parse(paddingRight, declaration.paddingRight);
                this.paddingBottom = parse(paddingBottom, declaration.paddingBottom);
                this.paddingLeft = parse(paddingLeft, declaration.paddingLeft);
                this.position = parse(position, declaration.position);
                this.textAlign = parse(textAlign, declaration.textAlign);
                this.textDecorationColor = parse(textDecorationColor, declaration.textDecorationColor || declaration.color);
                this.textDecorationLine = parse(textDecorationLine, declaration.textDecorationLine);
                this.textShadow = parse(textShadow, declaration.textShadow);
                this.textTransform = parse(textTransform, declaration.textTransform);
                this.transform = parse(transform, declaration.transform);
                this.transformOrigin = parse(transformOrigin, declaration.transformOrigin);
                this.visibility = parse(visibility, declaration.visibility);
                this.wordBreak = parse(wordBreak, declaration.wordBreak);
                this.zIndex = parse(zIndex, declaration.zIndex);
            }
            CSSParsedDeclaration.prototype.isVisible = function () {
                return this.display > 0 && this.opacity > 0 && this.visibility === VISIBILITY.VISIBLE;
            };
            CSSParsedDeclaration.prototype.isTransparent = function () {
                return isTransparent(this.backgroundColor);
            };
            CSSParsedDeclaration.prototype.isTransformed = function () {
                return this.transform !== null;
            };
            CSSParsedDeclaration.prototype.isPositioned = function () {
                return this.position !== POSITION.STATIC;
            };
            CSSParsedDeclaration.prototype.isPositionedWithZIndex = function () {
                return this.isPositioned() && !this.zIndex.auto;
            };
            CSSParsedDeclaration.prototype.isFloating = function () {
                return this.float !== FLOAT.NONE;
            };
            CSSParsedDeclaration.prototype.isInlineLevel = function () {
                return (contains(this.display, 4 /* INLINE */) ||
                    contains(this.display, 33554432 /* INLINE_BLOCK */) ||
                    contains(this.display, 268435456 /* INLINE_FLEX */) ||
                    contains(this.display, 536870912 /* INLINE_GRID */) ||
                    contains(this.display, 67108864 /* INLINE_LIST_ITEM */) ||
                    contains(this.display, 134217728 /* INLINE_TABLE */));
            };
            return CSSParsedDeclaration;
        }());
        var CSSParsedPseudoDeclaration = /** @class */ (function () {
            function CSSParsedPseudoDeclaration(declaration) {
                this.content = parse(content, declaration.content);
                this.quotes = parse(quotes, declaration.quotes);
            }
            return CSSParsedPseudoDeclaration;
        }());
        var CSSParsedCounterDeclaration = /** @class */ (function () {
            function CSSParsedCounterDeclaration(declaration) {
                this.counterIncrement = parse(counterIncrement, declaration.counterIncrement);
                this.counterReset = parse(counterReset, declaration.counterReset);
            }
            return CSSParsedCounterDeclaration;
        }());
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var parse = function (descriptor, style) {
            var tokenizer = new Tokenizer();
            var value = style !== null && typeof style !== 'undefined' ? style.toString() : descriptor.initialValue;
            tokenizer.write(value);
            var parser = new Parser(tokenizer.read());
            switch (descriptor.type) {
                case PropertyDescriptorParsingType.IDENT_VALUE:
                    var token = parser.parseComponentValue();
                    return descriptor.parse(isIdentToken(token) ? token.value : descriptor.initialValue);
                case PropertyDescriptorParsingType.VALUE:
                    return descriptor.parse(parser.parseComponentValue());
                case PropertyDescriptorParsingType.LIST:
                    return descriptor.parse(parser.parseComponentValues());
                case PropertyDescriptorParsingType.TOKEN_VALUE:
                    return parser.parseComponentValue();
                case PropertyDescriptorParsingType.TYPE_VALUE:
                    switch (descriptor.format) {
                        case 'angle':
                            return angle.parse(parser.parseComponentValue());
                        case 'color':
                            return color.parse(parser.parseComponentValue());
                        case 'image':
                            return image.parse(parser.parseComponentValue());
                        case 'length':
                            var length_1 = parser.parseComponentValue();
                            return isLength(length_1) ? length_1 : ZERO_LENGTH;
                        case 'length-percentage':
                            var value_1 = parser.parseComponentValue();
                            return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
                    }
            }
            throw new Error("Attempting to parse unsupported css format type " + descriptor.format);
        };

        var ElementContainer = /** @class */ (function () {
            function ElementContainer(element) {
                this.styles = new CSSParsedDeclaration(window.getComputedStyle(element, null));
                this.textNodes = [];
                this.elements = [];
                if (this.styles.transform !== null && isHTMLElementNode(element)) {
                    // getBoundingClientRect takes transforms into account
                    element.style.transform = 'none';
                }
                this.bounds = parseBounds(element);
                this.flags = 0;
            }
            return ElementContainer;
        }());

        var TextBounds = /** @class */ (function () {
            function TextBounds(text, bounds) {
                this.text = text;
                this.bounds = bounds;
            }
            return TextBounds;
        }());
        var parseTextBounds = function (value, styles, node) {
            var textList = breakText(value, styles);
            var textBounds = [];
            var offset = 0;
            textList.forEach(function (text) {
                if (styles.textDecorationLine.length || text.trim().length > 0) {
                    if (FEATURES.SUPPORT_RANGE_BOUNDS) {
                        textBounds.push(new TextBounds(text, getRangeBounds(node, offset, text.length)));
                    }
                    else {
                        var replacementNode = node.splitText(text.length);
                        textBounds.push(new TextBounds(text, getWrapperBounds(node)));
                        node = replacementNode;
                    }
                }
                else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
                    node = node.splitText(text.length);
                }
                offset += text.length;
            });
            return textBounds;
        };
        var getWrapperBounds = function (node) {
            var ownerDocument = node.ownerDocument;
            if (ownerDocument) {
                var wrapper = ownerDocument.createElement('html2canvaswrapper');
                wrapper.appendChild(node.cloneNode(true));
                var parentNode = node.parentNode;
                if (parentNode) {
                    parentNode.replaceChild(wrapper, node);
                    var bounds = parseBounds(wrapper);
                    if (wrapper.firstChild) {
                        parentNode.replaceChild(wrapper.firstChild, wrapper);
                    }
                    return bounds;
                }
            }
            return new Bounds(0, 0, 0, 0);
        };
        var getRangeBounds = function (node, offset, length) {
            var ownerDocument = node.ownerDocument;
            if (!ownerDocument) {
                throw new Error('Node has no owner document');
            }
            var range = ownerDocument.createRange();
            range.setStart(node, offset);
            range.setEnd(node, offset + length);
            return Bounds.fromClientRect(range.getBoundingClientRect());
        };
        var breakText = function (value, styles) {
            return styles.letterSpacing !== 0 ? toCodePoints(value).map(function (i) { return fromCodePoint(i); }) : breakWords(value, styles);
        };
        var breakWords = function (str, styles) {
            var breaker = LineBreaker(str, {
                lineBreak: styles.lineBreak,
                wordBreak: styles.overflowWrap === OVERFLOW_WRAP.BREAK_WORD ? 'break-word' : styles.wordBreak
            });
            var words = [];
            var bk;
            while (!(bk = breaker.next()).done) {
                if (bk.value) {
                    words.push(bk.value.slice());
                }
            }
            return words;
        };

        var TextContainer = /** @class */ (function () {
            function TextContainer(node, styles) {
                this.text = transform$1(node.data, styles.textTransform);
                this.textBounds = parseTextBounds(this.text, styles, node);
            }
            return TextContainer;
        }());
        var transform$1 = function (text, transform) {
            switch (transform) {
                case TEXT_TRANSFORM.LOWERCASE:
                    return text.toLowerCase();
                case TEXT_TRANSFORM.CAPITALIZE:
                    return text.replace(CAPITALIZE, capitalize);
                case TEXT_TRANSFORM.UPPERCASE:
                    return text.toUpperCase();
                default:
                    return text;
            }
        };
        var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
        var capitalize = function (m, p1, p2) {
            if (m.length > 0) {
                return p1 + p2.toUpperCase();
            }
            return m;
        };

        var ImageElementContainer = /** @class */ (function (_super) {
            __extends(ImageElementContainer, _super);
            function ImageElementContainer(img) {
                var _this = _super.call(this, img) || this;
                _this.src = img.currentSrc || img.src;
                _this.intrinsicWidth = img.naturalWidth;
                _this.intrinsicHeight = img.naturalHeight;
                CacheStorage.getInstance().addImage(_this.src);
                return _this;
            }
            return ImageElementContainer;
        }(ElementContainer));

        var CanvasElementContainer = /** @class */ (function (_super) {
            __extends(CanvasElementContainer, _super);
            function CanvasElementContainer(canvas) {
                var _this = _super.call(this, canvas) || this;
                _this.canvas = canvas;
                _this.intrinsicWidth = canvas.width;
                _this.intrinsicHeight = canvas.height;
                return _this;
            }
            return CanvasElementContainer;
        }(ElementContainer));

        var SVGElementContainer = /** @class */ (function (_super) {
            __extends(SVGElementContainer, _super);
            function SVGElementContainer(img) {
                var _this = _super.call(this, img) || this;
                var s = new XMLSerializer();
                _this.svg = "data:image/svg+xml," + encodeURIComponent(s.serializeToString(img));
                _this.intrinsicWidth = img.width.baseVal.value;
                _this.intrinsicHeight = img.height.baseVal.value;
                CacheStorage.getInstance().addImage(_this.svg);
                return _this;
            }
            return SVGElementContainer;
        }(ElementContainer));

        var LIElementContainer = /** @class */ (function (_super) {
            __extends(LIElementContainer, _super);
            function LIElementContainer(element) {
                var _this = _super.call(this, element) || this;
                _this.value = element.value;
                return _this;
            }
            return LIElementContainer;
        }(ElementContainer));

        var OLElementContainer = /** @class */ (function (_super) {
            __extends(OLElementContainer, _super);
            function OLElementContainer(element) {
                var _this = _super.call(this, element) || this;
                _this.start = element.start;
                _this.reversed = typeof element.reversed === 'boolean' && element.reversed === true;
                return _this;
            }
            return OLElementContainer;
        }(ElementContainer));

        var CHECKBOX_BORDER_RADIUS = [
            {
                type: TokenType.DIMENSION_TOKEN,
                flags: 0,
                unit: 'px',
                number: 3
            }
        ];
        var RADIO_BORDER_RADIUS = [
            {
                type: TokenType.PERCENTAGE_TOKEN,
                flags: 0,
                number: 50
            }
        ];
        var reformatInputBounds = function (bounds) {
            if (bounds.width > bounds.height) {
                return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
            }
            else if (bounds.width < bounds.height) {
                return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
            }
            return bounds;
        };
        var getInputValue = function (node) {
            var value = node.type === PASSWORD ? new Array(node.value.length + 1).join('\u2022') : node.value;
            return value.length === 0 ? node.placeholder || '' : value;
        };
        var CHECKBOX = 'checkbox';
        var RADIO = 'radio';
        var PASSWORD = 'password';
        var INPUT_COLOR = 0x2a2a2aff;
        var InputElementContainer = /** @class */ (function (_super) {
            __extends(InputElementContainer, _super);
            function InputElementContainer(input) {
                var _this = _super.call(this, input) || this;
                _this.type = input.type.toLowerCase();
                _this.checked = input.checked;
                _this.value = getInputValue(input);
                if (_this.type === CHECKBOX || _this.type === RADIO) {
                    _this.styles.backgroundColor = 0xdededeff;
                    _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 0xa5a5a5ff;
                    _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
                    _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle =
                        BORDER_STYLE.SOLID;
                    _this.styles.backgroundClip = [BACKGROUND_CLIP.BORDER_BOX];
                    _this.styles.backgroundOrigin = [0 /* BORDER_BOX */];
                    _this.bounds = reformatInputBounds(_this.bounds);
                }
                switch (_this.type) {
                    case CHECKBOX:
                        _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
                        break;
                    case RADIO:
                        _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
                        break;
                }
                return _this;
            }
            return InputElementContainer;
        }(ElementContainer));

        var SelectElementContainer = /** @class */ (function (_super) {
            __extends(SelectElementContainer, _super);
            function SelectElementContainer(element) {
                var _this = _super.call(this, element) || this;
                var option = element.options[element.selectedIndex || 0];
                _this.value = option ? option.text || '' : '';
                return _this;
            }
            return SelectElementContainer;
        }(ElementContainer));

        var TextareaElementContainer = /** @class */ (function (_super) {
            __extends(TextareaElementContainer, _super);
            function TextareaElementContainer(element) {
                var _this = _super.call(this, element) || this;
                _this.value = element.value;
                return _this;
            }
            return TextareaElementContainer;
        }(ElementContainer));

        var parseColor = function (value) { return color.parse(Parser.create(value).parseComponentValue()); };
        var IFrameElementContainer = /** @class */ (function (_super) {
            __extends(IFrameElementContainer, _super);
            function IFrameElementContainer(iframe) {
                var _this = _super.call(this, iframe) || this;
                _this.src = iframe.src;
                _this.width = parseInt(iframe.width, 10) || 0;
                _this.height = parseInt(iframe.height, 10) || 0;
                _this.backgroundColor = _this.styles.backgroundColor;
                try {
                    if (iframe.contentWindow &&
                        iframe.contentWindow.document &&
                        iframe.contentWindow.document.documentElement) {
                        _this.tree = parseTree(iframe.contentWindow.document.documentElement);
                        // http://www.w3.org/TR/css3-background/#special-backgrounds
                        var documentBackgroundColor = iframe.contentWindow.document.documentElement
                            ? parseColor(getComputedStyle(iframe.contentWindow.document.documentElement)
                                .backgroundColor)
                            : COLORS.TRANSPARENT;
                        var bodyBackgroundColor = iframe.contentWindow.document.body
                            ? parseColor(getComputedStyle(iframe.contentWindow.document.body).backgroundColor)
                            : COLORS.TRANSPARENT;
                        _this.backgroundColor = isTransparent(documentBackgroundColor)
                            ? isTransparent(bodyBackgroundColor)
                                ? _this.styles.backgroundColor
                                : bodyBackgroundColor
                            : documentBackgroundColor;
                    }
                }
                catch (e) { }
                return _this;
            }
            return IFrameElementContainer;
        }(ElementContainer));

        var LIST_OWNERS = ['OL', 'UL', 'MENU'];
        var parseNodeTree = function (node, parent, root) {
            for (var childNode = node.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
                nextNode = childNode.nextSibling;
                if (isTextNode(childNode) && childNode.data.trim().length > 0) {
                    parent.textNodes.push(new TextContainer(childNode, parent.styles));
                }
                else if (isElementNode(childNode)) {
                    var container = createContainer(childNode);
                    if (container.styles.isVisible()) {
                        if (createsRealStackingContext(childNode, container, root)) {
                            container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;
                        }
                        else if (createsStackingContext(container.styles)) {
                            container.flags |= 2 /* CREATES_STACKING_CONTEXT */;
                        }
                        if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
                            container.flags |= 8 /* IS_LIST_OWNER */;
                        }
                        parent.elements.push(container);
                        if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
                            parseNodeTree(childNode, container, root);
                        }
                    }
                }
            }
        };
        var createContainer = function (element) {
            if (isImageElement(element)) {
                return new ImageElementContainer(element);
            }
            if (isCanvasElement(element)) {
                return new CanvasElementContainer(element);
            }
            if (isSVGElement(element)) {
                return new SVGElementContainer(element);
            }
            if (isLIElement(element)) {
                return new LIElementContainer(element);
            }
            if (isOLElement(element)) {
                return new OLElementContainer(element);
            }
            if (isInputElement(element)) {
                return new InputElementContainer(element);
            }
            if (isSelectElement(element)) {
                return new SelectElementContainer(element);
            }
            if (isTextareaElement(element)) {
                return new TextareaElementContainer(element);
            }
            if (isIFrameElement(element)) {
                return new IFrameElementContainer(element);
            }
            return new ElementContainer(element);
        };
        var parseTree = function (element) {
            var container = createContainer(element);
            container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;
            parseNodeTree(element, container, container);
            return container;
        };
        var createsRealStackingContext = function (node, container, root) {
            return (container.styles.isPositionedWithZIndex() ||
                container.styles.opacity < 1 ||
                container.styles.isTransformed() ||
                (isBodyElement(node) && root.styles.isTransparent()));
        };
        var createsStackingContext = function (styles) { return styles.isPositioned() || styles.isFloating(); };
        var isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
        var isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
        var isHTMLElementNode = function (node) {
            return isElementNode(node) && typeof node.style !== 'undefined' && !isSVGElementNode(node);
        };
        var isSVGElementNode = function (element) {
            return typeof element.className === 'object';
        };
        var isLIElement = function (node) { return node.tagName === 'LI'; };
        var isOLElement = function (node) { return node.tagName === 'OL'; };
        var isInputElement = function (node) { return node.tagName === 'INPUT'; };
        var isHTMLElement = function (node) { return node.tagName === 'HTML'; };
        var isSVGElement = function (node) { return node.tagName === 'svg'; };
        var isBodyElement = function (node) { return node.tagName === 'BODY'; };
        var isCanvasElement = function (node) { return node.tagName === 'CANVAS'; };
        var isImageElement = function (node) { return node.tagName === 'IMG'; };
        var isIFrameElement = function (node) { return node.tagName === 'IFRAME'; };
        var isStyleElement = function (node) { return node.tagName === 'STYLE'; };
        var isScriptElement = function (node) { return node.tagName === 'SCRIPT'; };
        var isTextareaElement = function (node) { return node.tagName === 'TEXTAREA'; };
        var isSelectElement = function (node) { return node.tagName === 'SELECT'; };

        var CounterState = /** @class */ (function () {
            function CounterState() {
                this.counters = {};
            }
            CounterState.prototype.getCounterValue = function (name) {
                var counter = this.counters[name];
                if (counter && counter.length) {
                    return counter[counter.length - 1];
                }
                return 1;
            };
            CounterState.prototype.getCounterValues = function (name) {
                var counter = this.counters[name];
                return counter ? counter : [];
            };
            CounterState.prototype.pop = function (counters) {
                var _this = this;
                counters.forEach(function (counter) { return _this.counters[counter].pop(); });
            };
            CounterState.prototype.parse = function (style) {
                var _this = this;
                var counterIncrement = style.counterIncrement;
                var counterReset = style.counterReset;
                var canReset = true;
                if (counterIncrement !== null) {
                    counterIncrement.forEach(function (entry) {
                        var counter = _this.counters[entry.counter];
                        if (counter && entry.increment !== 0) {
                            canReset = false;
                            counter[Math.max(0, counter.length - 1)] += entry.increment;
                        }
                    });
                }
                var counterNames = [];
                if (canReset) {
                    counterReset.forEach(function (entry) {
                        var counter = _this.counters[entry.counter];
                        counterNames.push(entry.counter);
                        if (!counter) {
                            counter = _this.counters[entry.counter] = [];
                        }
                        counter.push(entry.reset);
                    });
                }
                return counterNames;
            };
            return CounterState;
        }());
        var ROMAN_UPPER = {
            integers: [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
            values: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']
        };
        var ARMENIAN = {
            integers: [
                9000,
                8000,
                7000,
                6000,
                5000,
                4000,
                3000,
                2000,
                1000,
                900,
                800,
                700,
                600,
                500,
                400,
                300,
                200,
                100,
                90,
                80,
                70,
                60,
                50,
                40,
                30,
                20,
                10,
                9,
                8,
                7,
                6,
                5,
                4,
                3,
                2,
                1
            ],
            values: [
                'Ք',
                'Փ',
                'Ւ',
                'Ց',
                'Ր',
                'Տ',
                'Վ',
                'Ս',
                'Ռ',
                'Ջ',
                'Պ',
                'Չ',
                'Ո',
                'Շ',
                'Ն',
                'Յ',
                'Մ',
                'Ճ',
                'Ղ',
                'Ձ',
                'Հ',
                'Կ',
                'Ծ',
                'Խ',
                'Լ',
                'Ի',
                'Ժ',
                'Թ',
                'Ը',
                'Է',
                'Զ',
                'Ե',
                'Դ',
                'Գ',
                'Բ',
                'Ա'
            ]
        };
        var HEBREW = {
            integers: [
                10000,
                9000,
                8000,
                7000,
                6000,
                5000,
                4000,
                3000,
                2000,
                1000,
                400,
                300,
                200,
                100,
                90,
                80,
                70,
                60,
                50,
                40,
                30,
                20,
                19,
                18,
                17,
                16,
                15,
                10,
                9,
                8,
                7,
                6,
                5,
                4,
                3,
                2,
                1
            ],
            values: [
                'י׳',
                'ט׳',
                'ח׳',
                'ז׳',
                'ו׳',
                'ה׳',
                'ד׳',
                'ג׳',
                'ב׳',
                'א׳',
                'ת',
                'ש',
                'ר',
                'ק',
                'צ',
                'פ',
                'ע',
                'ס',
                'נ',
                'מ',
                'ל',
                'כ',
                'יט',
                'יח',
                'יז',
                'טז',
                'טו',
                'י',
                'ט',
                'ח',
                'ז',
                'ו',
                'ה',
                'ד',
                'ג',
                'ב',
                'א'
            ]
        };
        var GEORGIAN = {
            integers: [
                10000,
                9000,
                8000,
                7000,
                6000,
                5000,
                4000,
                3000,
                2000,
                1000,
                900,
                800,
                700,
                600,
                500,
                400,
                300,
                200,
                100,
                90,
                80,
                70,
                60,
                50,
                40,
                30,
                20,
                10,
                9,
                8,
                7,
                6,
                5,
                4,
                3,
                2,
                1
            ],
            values: [
                'ჵ',
                'ჰ',
                'ჯ',
                'ჴ',
                'ხ',
                'ჭ',
                'წ',
                'ძ',
                'ც',
                'ჩ',
                'შ',
                'ყ',
                'ღ',
                'ქ',
                'ფ',
                'ჳ',
                'ტ',
                'ს',
                'რ',
                'ჟ',
                'პ',
                'ო',
                'ჲ',
                'ნ',
                'მ',
                'ლ',
                'კ',
                'ი',
                'თ',
                'ჱ',
                'ზ',
                'ვ',
                'ე',
                'დ',
                'გ',
                'ბ',
                'ა'
            ]
        };
        var createAdditiveCounter = function (value, min, max, symbols, fallback, suffix) {
            if (value < min || value > max) {
                return createCounterText(value, fallback, suffix.length > 0);
            }
            return (symbols.integers.reduce(function (string, integer, index) {
                while (value >= integer) {
                    value -= integer;
                    string += symbols.values[index];
                }
                return string;
            }, '') + suffix);
        };
        var createCounterStyleWithSymbolResolver = function (value, codePointRangeLength, isNumeric, resolver) {
            var string = '';
            do {
                if (!isNumeric) {
                    value--;
                }
                string = resolver(value) + string;
                value /= codePointRangeLength;
            } while (value * codePointRangeLength >= codePointRangeLength);
            return string;
        };
        var createCounterStyleFromRange = function (value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
            var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
            return ((value < 0 ? '-' : '') +
                (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function (codePoint) {
                    return fromCodePoint(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
                }) +
                    suffix));
        };
        var createCounterStyleFromSymbols = function (value, symbols, suffix) {
            if (suffix === void 0) { suffix = '. '; }
            var codePointRangeLength = symbols.length;
            return (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function (codePoint) { return symbols[Math.floor(codePoint % codePointRangeLength)]; }) + suffix);
        };
        var CJK_ZEROS = 1 << 0;
        var CJK_TEN_COEFFICIENTS = 1 << 1;
        var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
        var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
        var createCJKCounter = function (value, numbers, multipliers, negativeSign, suffix, flags) {
            if (value < -9999 || value > 9999) {
                return createCounterText(value, LIST_STYLE_TYPE.CJK_DECIMAL, suffix.length > 0);
            }
            var tmp = Math.abs(value);
            var string = suffix;
            if (tmp === 0) {
                return numbers[0] + string;
            }
            for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
                var coefficient = tmp % 10;
                if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== '') {
                    string = numbers[coefficient] + string;
                }
                else if (coefficient > 1 ||
                    (coefficient === 1 && digit === 0) ||
                    (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS)) ||
                    (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100) ||
                    (coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS))) {
                    string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : '') + string;
                }
                else if (coefficient === 1 && digit > 0) {
                    string = multipliers[digit - 1] + string;
                }
                tmp = Math.floor(tmp / 10);
            }
            return (value < 0 ? negativeSign : '') + string;
        };
        var CHINESE_INFORMAL_MULTIPLIERS = '十百千萬';
        var CHINESE_FORMAL_MULTIPLIERS = '拾佰仟萬';
        var JAPANESE_NEGATIVE = 'マイナス';
        var KOREAN_NEGATIVE = '마이너스';
        var createCounterText = function (value, type, appendSuffix) {
            var defaultSuffix = appendSuffix ? '. ' : '';
            var cjkSuffix = appendSuffix ? '、' : '';
            var koreanSuffix = appendSuffix ? ', ' : '';
            var spaceSuffix = appendSuffix ? ' ' : '';
            switch (type) {
                case LIST_STYLE_TYPE.DISC:
                    return '•' + spaceSuffix;
                case LIST_STYLE_TYPE.CIRCLE:
                    return '◦' + spaceSuffix;
                case LIST_STYLE_TYPE.SQUARE:
                    return '◾' + spaceSuffix;
                case LIST_STYLE_TYPE.DECIMAL_LEADING_ZERO:
                    var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
                    return string.length < 4 ? "0" + string : string;
                case LIST_STYLE_TYPE.CJK_DECIMAL:
                    return createCounterStyleFromSymbols(value, '〇一二三四五六七八九', cjkSuffix);
                case LIST_STYLE_TYPE.LOWER_ROMAN:
                    return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, LIST_STYLE_TYPE.DECIMAL, defaultSuffix).toLowerCase();
                case LIST_STYLE_TYPE.UPPER_ROMAN:
                    return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
                case LIST_STYLE_TYPE.LOWER_GREEK:
                    return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
                case LIST_STYLE_TYPE.LOWER_ALPHA:
                    return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
                case LIST_STYLE_TYPE.UPPER_ALPHA:
                    return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
                case LIST_STYLE_TYPE.ARABIC_INDIC:
                    return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
                case LIST_STYLE_TYPE.ARMENIAN:
                case LIST_STYLE_TYPE.UPPER_ARMENIAN:
                    return createAdditiveCounter(value, 1, 9999, ARMENIAN, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
                case LIST_STYLE_TYPE.LOWER_ARMENIAN:
                    return createAdditiveCounter(value, 1, 9999, ARMENIAN, LIST_STYLE_TYPE.DECIMAL, defaultSuffix).toLowerCase();
                case LIST_STYLE_TYPE.BENGALI:
                    return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
                case LIST_STYLE_TYPE.CAMBODIAN:
                case LIST_STYLE_TYPE.KHMER:
                    return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
                case LIST_STYLE_TYPE.CJK_EARTHLY_BRANCH:
                    return createCounterStyleFromSymbols(value, '子丑寅卯辰巳午未申酉戌亥', cjkSuffix);
                case LIST_STYLE_TYPE.CJK_HEAVENLY_STEM:
                    return createCounterStyleFromSymbols(value, '甲乙丙丁戊己庚辛壬癸', cjkSuffix);
                case LIST_STYLE_TYPE.CJK_IDEOGRAPHIC:
                case LIST_STYLE_TYPE.TRAD_CHINESE_INFORMAL:
                    return createCJKCounter(value, '零一二三四五六七八九', CHINESE_INFORMAL_MULTIPLIERS, '負', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
                case LIST_STYLE_TYPE.TRAD_CHINESE_FORMAL:
                    return createCJKCounter(value, '零壹貳參肆伍陸柒捌玖', CHINESE_FORMAL_MULTIPLIERS, '負', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
                case LIST_STYLE_TYPE.SIMP_CHINESE_INFORMAL:
                    return createCJKCounter(value, '零一二三四五六七八九', CHINESE_INFORMAL_MULTIPLIERS, '负', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
                case LIST_STYLE_TYPE.SIMP_CHINESE_FORMAL:
                    return createCJKCounter(value, '零壹贰叁肆伍陆柒捌玖', CHINESE_FORMAL_MULTIPLIERS, '负', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
                case LIST_STYLE_TYPE.JAPANESE_INFORMAL:
                    return createCJKCounter(value, '〇一二三四五六七八九', '十百千万', JAPANESE_NEGATIVE, cjkSuffix, 0);
                case LIST_STYLE_TYPE.JAPANESE_FORMAL:
                    return createCJKCounter(value, '零壱弐参四伍六七八九', '拾百千万', JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
                case LIST_STYLE_TYPE.KOREAN_HANGUL_FORMAL:
                    return createCJKCounter(value, '영일이삼사오육칠팔구', '십백천만', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
                case LIST_STYLE_TYPE.KOREAN_HANJA_INFORMAL:
                    return createCJKCounter(value, '零一二三四五六七八九', '十百千萬', KOREAN_NEGATIVE, koreanSuffix, 0);
                case LIST_STYLE_TYPE.KOREAN_HANJA_FORMAL:
                    return createCJKCounter(value, '零壹貳參四五六七八九', '拾百千', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
                case LIST_STYLE_TYPE.DEVANAGARI:
                    return createCounterStyleFromRange(value, 0x966, 0x96f, true, defaultSuffix);
                case LIST_STYLE_TYPE.GEORGIAN:
                    return createAdditiveCounter(value, 1, 19999, GEORGIAN, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
                case LIST_STYLE_TYPE.GUJARATI:
                    return createCounterStyleFromRange(value, 0xae6, 0xaef, true, defaultSuffix);
                case LIST_STYLE_TYPE.GURMUKHI:
                    return createCounterStyleFromRange(value, 0xa66, 0xa6f, true, defaultSuffix);
                case LIST_STYLE_TYPE.HEBREW:
                    return createAdditiveCounter(value, 1, 10999, HEBREW, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
                case LIST_STYLE_TYPE.HIRAGANA:
                    return createCounterStyleFromSymbols(value, 'あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをん');
                case LIST_STYLE_TYPE.HIRAGANA_IROHA:
                    return createCounterStyleFromSymbols(value, 'いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす');
                case LIST_STYLE_TYPE.KANNADA:
                    return createCounterStyleFromRange(value, 0xce6, 0xcef, true, defaultSuffix);
                case LIST_STYLE_TYPE.KATAKANA:
                    return createCounterStyleFromSymbols(value, 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲン', cjkSuffix);
                case LIST_STYLE_TYPE.KATAKANA_IROHA:
                    return createCounterStyleFromSymbols(value, 'イロハニホヘトチリヌルヲワカヨタレソツネナラムウヰノオクヤマケフコエテアサキユメミシヱヒモセス', cjkSuffix);
                case LIST_STYLE_TYPE.LAO:
                    return createCounterStyleFromRange(value, 0xed0, 0xed9, true, defaultSuffix);
                case LIST_STYLE_TYPE.MONGOLIAN:
                    return createCounterStyleFromRange(value, 0x1810, 0x1819, true, defaultSuffix);
                case LIST_STYLE_TYPE.MYANMAR:
                    return createCounterStyleFromRange(value, 0x1040, 0x1049, true, defaultSuffix);
                case LIST_STYLE_TYPE.ORIYA:
                    return createCounterStyleFromRange(value, 0xb66, 0xb6f, true, defaultSuffix);
                case LIST_STYLE_TYPE.PERSIAN:
                    return createCounterStyleFromRange(value, 0x6f0, 0x6f9, true, defaultSuffix);
                case LIST_STYLE_TYPE.TAMIL:
                    return createCounterStyleFromRange(value, 0xbe6, 0xbef, true, defaultSuffix);
                case LIST_STYLE_TYPE.TELUGU:
                    return createCounterStyleFromRange(value, 0xc66, 0xc6f, true, defaultSuffix);
                case LIST_STYLE_TYPE.THAI:
                    return createCounterStyleFromRange(value, 0xe50, 0xe59, true, defaultSuffix);
                case LIST_STYLE_TYPE.TIBETAN:
                    return createCounterStyleFromRange(value, 0xf20, 0xf29, true, defaultSuffix);
                case LIST_STYLE_TYPE.DECIMAL:
                default:
                    return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
            }
        };

        var IGNORE_ATTRIBUTE = 'data-html2canvas-ignore';
        var DocumentCloner = /** @class */ (function () {
            function DocumentCloner(element, options) {
                this.options = options;
                this.scrolledElements = [];
                this.referenceElement = element;
                this.counters = new CounterState();
                this.quoteDepth = 0;
                if (!element.ownerDocument) {
                    throw new Error('Cloned element does not have an owner document');
                }
                this.documentElement = this.cloneNode(element.ownerDocument.documentElement);
            }
            DocumentCloner.prototype.toIFrame = function (ownerDocument, windowSize) {
                var _this = this;
                var iframe = createIFrameContainer(ownerDocument, windowSize);
                if (!iframe.contentWindow) {
                    return Promise.reject("Unable to find iframe window");
                }
                var scrollX = ownerDocument.defaultView.pageXOffset;
                var scrollY = ownerDocument.defaultView.pageYOffset;
                var cloneWindow = iframe.contentWindow;
                var documentClone = cloneWindow.document;
                /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle
                 if window url is about:blank, we can assign the url to current by writing onto the document
                 */
                var iframeLoad = iframeLoader(iframe).then(function () { return __awaiter(_this, void 0, void 0, function () {
                    var onclone;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                this.scrolledElements.forEach(restoreNodeScroll);
                                if (cloneWindow) {
                                    cloneWindow.scrollTo(windowSize.left, windowSize.top);
                                    if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) &&
                                        (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                                        documentClone.documentElement.style.top = -windowSize.top + 'px';
                                        documentClone.documentElement.style.left = -windowSize.left + 'px';
                                        documentClone.documentElement.style.position = 'absolute';
                                    }
                                }
                                onclone = this.options.onclone;
                                if (typeof this.clonedReferenceElement === 'undefined') {
                                    return [2 /*return*/, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                                }
                                if (!(documentClone.fonts && documentClone.fonts.ready)) return [3 /*break*/, 2];
                                return [4 /*yield*/, documentClone.fonts.ready];
                            case 1:
                                _a.sent();
                                _a.label = 2;
                            case 2:
                                if (typeof onclone === 'function') {
                                    return [2 /*return*/, Promise.resolve()
                                            .then(function () { return onclone(documentClone); })
                                            .then(function () { return iframe; })];
                                }
                                return [2 /*return*/, iframe];
                        }
                    });
                }); });
                documentClone.open();
                documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
                // Chrome scrolls the parent document for some reason after the write to the cloned window???
                restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
                documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
                documentClone.close();
                return iframeLoad;
            };
            DocumentCloner.prototype.createElementClone = function (node) {
                if (isCanvasElement(node)) {
                    return this.createCanvasClone(node);
                }
                /*
                if (isIFrameElement(node)) {
                    return this.createIFrameClone(node);
                }
        */
                if (isStyleElement(node)) {
                    return this.createStyleClone(node);
                }
                var clone = node.cloneNode(false);
                // @ts-ignore
                if (isImageElement(clone) && clone.loading === 'lazy') {
                    // @ts-ignore
                    clone.loading = 'eager';
                }
                return clone;
            };
            DocumentCloner.prototype.createStyleClone = function (node) {
                try {
                    var sheet = node.sheet;
                    if (sheet && sheet.cssRules) {
                        var css = [].slice.call(sheet.cssRules, 0).reduce(function (css, rule) {
                            if (rule && typeof rule.cssText === 'string') {
                                return css + rule.cssText;
                            }
                            return css;
                        }, '');
                        var style = node.cloneNode(false);
                        style.textContent = css;
                        return style;
                    }
                }
                catch (e) {
                    // accessing node.sheet.cssRules throws a DOMException
                    Logger.getInstance(this.options.id).error('Unable to access cssRules property', e);
                    if (e.name !== 'SecurityError') {
                        throw e;
                    }
                }
                return node.cloneNode(false);
            };
            DocumentCloner.prototype.createCanvasClone = function (canvas) {
                if (this.options.inlineImages && canvas.ownerDocument) {
                    var img = canvas.ownerDocument.createElement('img');
                    try {
                        img.src = canvas.toDataURL();
                        return img;
                    }
                    catch (e) {
                        Logger.getInstance(this.options.id).info("Unable to clone canvas contents, canvas is tainted");
                    }
                }
                var clonedCanvas = canvas.cloneNode(false);
                try {
                    clonedCanvas.width = canvas.width;
                    clonedCanvas.height = canvas.height;
                    var ctx = canvas.getContext('2d');
                    var clonedCtx = clonedCanvas.getContext('2d');
                    if (clonedCtx) {
                        if (ctx) {
                            clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
                        }
                        else {
                            clonedCtx.drawImage(canvas, 0, 0);
                        }
                    }
                    return clonedCanvas;
                }
                catch (e) { }
                return clonedCanvas;
            };
            /*
            createIFrameClone(iframe: HTMLIFrameElement) {
                const tempIframe = <HTMLIFrameElement>iframe.cloneNode(false);
                const iframeKey = generateIframeKey();
                tempIframe.setAttribute('data-html2canvas-internal-iframe-key', iframeKey);

                const {width, height} = parseBounds(iframe);

                this.resourceLoader.cache[iframeKey] = getIframeDocumentElement(iframe, this.options)
                    .then(documentElement => {
                        return this.renderer(
                            documentElement,
                            {
                                allowTaint: this.options.allowTaint,
                                backgroundColor: '#ffffff',
                                canvas: null,
                                imageTimeout: this.options.imageTimeout,
                                logging: this.options.logging,
                                proxy: this.options.proxy,
                                removeContainer: this.options.removeContainer,
                                scale: this.options.scale,
                                foreignObjectRendering: this.options.foreignObjectRendering,
                                useCORS: this.options.useCORS,
                                target: new CanvasRenderer(),
                                width,
                                height,
                                x: 0,
                                y: 0,
                                windowWidth: documentElement.ownerDocument.defaultView.innerWidth,
                                windowHeight: documentElement.ownerDocument.defaultView.innerHeight,
                                scrollX: documentElement.ownerDocument.defaultView.pageXOffset,
                                scrollY: documentElement.ownerDocument.defaultView.pageYOffset
                            },
                        );
                    })
                    .then(
                        (canvas: HTMLCanvasElement) =>
                            new Promise((resolve, reject) => {
                                const iframeCanvas = document.createElement('img');
                                iframeCanvas.onload = () => resolve(canvas);
                                iframeCanvas.onerror = (event) => {
                                    // Empty iframes may result in empty "data:," URLs, which are invalid from the <img>'s point of view
                                    // and instead of `onload` cause `onerror` and unhandled rejection warnings
                                    // https://github.com/niklasvh/html2canvas/issues/1502
                                    iframeCanvas.src == 'data:,' ? resolve(canvas) : reject(event);
                                };
                                iframeCanvas.src = canvas.toDataURL();
                                if (tempIframe.parentNode && iframe.ownerDocument && iframe.ownerDocument.defaultView) {
                                    tempIframe.parentNode.replaceChild(
                                        copyCSSStyles(
                                            iframe.ownerDocument.defaultView.getComputedStyle(iframe),
                                            iframeCanvas
                                        ),
                                        tempIframe
                                    );
                                }
                            })
                    );
                return tempIframe;
            }
        */
            DocumentCloner.prototype.cloneNode = function (node) {
                if (isTextNode(node)) {
                    return document.createTextNode(node.data);
                }
                if (!node.ownerDocument) {
                    return node.cloneNode(false);
                }
                var window = node.ownerDocument.defaultView;
                if (window && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {
                    var clone = this.createElementClone(node);
                    var style = window.getComputedStyle(node);
                    var styleBefore = window.getComputedStyle(node, ':before');
                    var styleAfter = window.getComputedStyle(node, ':after');
                    if (this.referenceElement === node && isHTMLElementNode(clone)) {
                        this.clonedReferenceElement = clone;
                    }
                    if (isBodyElement(clone)) {
                        createPseudoHideStyles(clone);
                    }
                    var counters = this.counters.parse(new CSSParsedCounterDeclaration(style));
                    var before = this.resolvePseudoContent(node, clone, styleBefore, PseudoElementType.BEFORE);
                    for (var child = node.firstChild; child; child = child.nextSibling) {
                        if (!isElementNode(child) ||
                            (!isScriptElement(child) &&
                                !child.hasAttribute(IGNORE_ATTRIBUTE) &&
                                (typeof this.options.ignoreElements !== 'function' || !this.options.ignoreElements(child)))) {
                            if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
                                clone.appendChild(this.cloneNode(child));
                            }
                        }
                    }
                    if (before) {
                        clone.insertBefore(before, clone.firstChild);
                    }
                    var after = this.resolvePseudoContent(node, clone, styleAfter, PseudoElementType.AFTER);
                    if (after) {
                        clone.appendChild(after);
                    }
                    this.counters.pop(counters);
                    if (style && (this.options.copyStyles || isSVGElementNode(node)) && !isIFrameElement(node)) {
                        copyCSSStyles(style, clone);
                    }
                    //this.inlineAllImages(clone);
                    if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
                        this.scrolledElements.push([clone, node.scrollLeft, node.scrollTop]);
                    }
                    if ((isTextareaElement(node) || isSelectElement(node)) &&
                        (isTextareaElement(clone) || isSelectElement(clone))) {
                        clone.value = node.value;
                    }
                    return clone;
                }
                return node.cloneNode(false);
            };
            DocumentCloner.prototype.resolvePseudoContent = function (node, clone, style, pseudoElt) {
                var _this = this;
                if (!style) {
                    return;
                }
                var value = style.content;
                var document = clone.ownerDocument;
                if (!document || !value || value === 'none' || value === '-moz-alt-content' || style.display === 'none') {
                    return;
                }
                this.counters.parse(new CSSParsedCounterDeclaration(style));
                var declaration = new CSSParsedPseudoDeclaration(style);
                var anonymousReplacedElement = document.createElement('html2canvaspseudoelement');
                copyCSSStyles(style, anonymousReplacedElement);
                declaration.content.forEach(function (token) {
                    if (token.type === TokenType.STRING_TOKEN) {
                        anonymousReplacedElement.appendChild(document.createTextNode(token.value));
                    }
                    else if (token.type === TokenType.URL_TOKEN) {
                        var img = document.createElement('img');
                        img.src = token.value;
                        img.style.opacity = '1';
                        anonymousReplacedElement.appendChild(img);
                    }
                    else if (token.type === TokenType.FUNCTION) {
                        if (token.name === 'attr') {
                            var attr = token.values.filter(isIdentToken);
                            if (attr.length) {
                                anonymousReplacedElement.appendChild(document.createTextNode(node.getAttribute(attr[0].value) || ''));
                            }
                        }
                        else if (token.name === 'counter') {
                            var _a = token.values.filter(nonFunctionArgSeparator), counter = _a[0], counterStyle = _a[1];
                            if (counter && isIdentToken(counter)) {
                                var counterState = _this.counters.getCounterValue(counter.value);
                                var counterType = counterStyle && isIdentToken(counterStyle)
                                    ? listStyleType.parse(counterStyle.value)
                                    : LIST_STYLE_TYPE.DECIMAL;
                                anonymousReplacedElement.appendChild(document.createTextNode(createCounterText(counterState, counterType, false)));
                            }
                        }
                        else if (token.name === 'counters') {
                            var _b = token.values.filter(nonFunctionArgSeparator), counter = _b[0], delim = _b[1], counterStyle = _b[2];
                            if (counter && isIdentToken(counter)) {
                                var counterStates = _this.counters.getCounterValues(counter.value);
                                var counterType_1 = counterStyle && isIdentToken(counterStyle)
                                    ? listStyleType.parse(counterStyle.value)
                                    : LIST_STYLE_TYPE.DECIMAL;
                                var separator = delim && delim.type === TokenType.STRING_TOKEN ? delim.value : '';
                                var text = counterStates
                                    .map(function (value) { return createCounterText(value, counterType_1, false); })
                                    .join(separator);
                                anonymousReplacedElement.appendChild(document.createTextNode(text));
                            }
                        }
                    }
                    else if (token.type === TokenType.IDENT_TOKEN) {
                        switch (token.value) {
                            case 'open-quote':
                                anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
                                break;
                            case 'close-quote':
                                anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
                                break;
                            default:
                                // safari doesn't parse string tokens correctly because of lack of quotes
                                anonymousReplacedElement.appendChild(document.createTextNode(token.value));
                        }
                    }
                });
                anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
                var newClassName = pseudoElt === PseudoElementType.BEFORE
                    ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE
                    : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
                if (isSVGElementNode(clone)) {
                    clone.className.baseValue += newClassName;
                }
                else {
                    clone.className += newClassName;
                }
                return anonymousReplacedElement;
            };
            DocumentCloner.destroy = function (container) {
                if (container.parentNode) {
                    container.parentNode.removeChild(container);
                    return true;
                }
                return false;
            };
            return DocumentCloner;
        }());
        var PseudoElementType;
        (function (PseudoElementType) {
            PseudoElementType[PseudoElementType["BEFORE"] = 0] = "BEFORE";
            PseudoElementType[PseudoElementType["AFTER"] = 1] = "AFTER";
        })(PseudoElementType || (PseudoElementType = {}));
        var createIFrameContainer = function (ownerDocument, bounds) {
            var cloneIframeContainer = ownerDocument.createElement('iframe');
            cloneIframeContainer.className = 'html2canvas-container';
            cloneIframeContainer.style.visibility = 'hidden';
            cloneIframeContainer.style.position = 'fixed';
            cloneIframeContainer.style.left = '-10000px';
            cloneIframeContainer.style.top = '0px';
            cloneIframeContainer.style.border = '0';
            cloneIframeContainer.width = bounds.width.toString();
            cloneIframeContainer.height = bounds.height.toString();
            cloneIframeContainer.scrolling = 'no'; // ios won't scroll without it
            cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, 'true');
            ownerDocument.body.appendChild(cloneIframeContainer);
            return cloneIframeContainer;
        };
        var iframeLoader = function (iframe) {
            return new Promise(function (resolve, reject) {
                var cloneWindow = iframe.contentWindow;
                if (!cloneWindow) {
                    return reject("No window assigned for iframe");
                }
                var documentClone = cloneWindow.document;
                cloneWindow.onload = iframe.onload = documentClone.onreadystatechange = function () {
                    cloneWindow.onload = iframe.onload = documentClone.onreadystatechange = null;
                    var interval = setInterval(function () {
                        if (documentClone.body.childNodes.length > 0 && documentClone.readyState === 'complete') {
                            clearInterval(interval);
                            resolve(iframe);
                        }
                    }, 50);
                };
            });
        };
        var copyCSSStyles = function (style, target) {
            // Edge does not provide value for cssText
            for (var i = style.length - 1; i >= 0; i--) {
                var property = style.item(i);
                // Safari shows pseudoelements if content is set
                if (property !== 'content') {
                    target.style.setProperty(property, style.getPropertyValue(property));
                }
            }
            return target;
        };
        var serializeDoctype = function (doctype) {
            var str = '';
            if (doctype) {
                str += '<!DOCTYPE ';
                if (doctype.name) {
                    str += doctype.name;
                }
                if (doctype.internalSubset) {
                    str += doctype.internalSubset;
                }
                if (doctype.publicId) {
                    str += "\"" + doctype.publicId + "\"";
                }
                if (doctype.systemId) {
                    str += "\"" + doctype.systemId + "\"";
                }
                str += '>';
            }
            return str;
        };
        var restoreOwnerScroll = function (ownerDocument, x, y) {
            if (ownerDocument &&
                ownerDocument.defaultView &&
                (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
                ownerDocument.defaultView.scrollTo(x, y);
            }
        };
        var restoreNodeScroll = function (_a) {
            var element = _a[0], x = _a[1], y = _a[2];
            element.scrollLeft = x;
            element.scrollTop = y;
        };
        var PSEUDO_BEFORE = ':before';
        var PSEUDO_AFTER = ':after';
        var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = '___html2canvas___pseudoelement_before';
        var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = '___html2canvas___pseudoelement_after';
        var PSEUDO_HIDE_ELEMENT_STYLE = "{\n    content: \"\" !important;\n    display: none !important;\n}";
        var createPseudoHideStyles = function (body) {
            createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
        };
        var createStyles = function (body, styles) {
            var document = body.ownerDocument;
            if (document) {
                var style = document.createElement('style');
                style.textContent = styles;
                body.appendChild(style);
            }
        };

        var PathType;
        (function (PathType) {
            PathType[PathType["VECTOR"] = 0] = "VECTOR";
            PathType[PathType["BEZIER_CURVE"] = 1] = "BEZIER_CURVE";
        })(PathType || (PathType = {}));
        var equalPath = function (a, b) {
            if (a.length === b.length) {
                return a.some(function (v, i) { return v === b[i]; });
            }
            return false;
        };
        var transformPath = function (path, deltaX, deltaY, deltaW, deltaH) {
            return path.map(function (point, index) {
                switch (index) {
                    case 0:
                        return point.add(deltaX, deltaY);
                    case 1:
                        return point.add(deltaX + deltaW, deltaY);
                    case 2:
                        return point.add(deltaX + deltaW, deltaY + deltaH);
                    case 3:
                        return point.add(deltaX, deltaY + deltaH);
                }
                return point;
            });
        };

        var Vector = /** @class */ (function () {
            function Vector(x, y) {
                this.type = PathType.VECTOR;
                this.x = x;
                this.y = y;
            }
            Vector.prototype.add = function (deltaX, deltaY) {
                return new Vector(this.x + deltaX, this.y + deltaY);
            };
            return Vector;
        }());

        var lerp = function (a, b, t) {
            return new Vector(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t);
        };
        var BezierCurve = /** @class */ (function () {
            function BezierCurve(start, startControl, endControl, end) {
                this.type = PathType.BEZIER_CURVE;
                this.start = start;
                this.startControl = startControl;
                this.endControl = endControl;
                this.end = end;
            }
            BezierCurve.prototype.subdivide = function (t, firstHalf) {
                var ab = lerp(this.start, this.startControl, t);
                var bc = lerp(this.startControl, this.endControl, t);
                var cd = lerp(this.endControl, this.end, t);
                var abbc = lerp(ab, bc, t);
                var bccd = lerp(bc, cd, t);
                var dest = lerp(abbc, bccd, t);
                return firstHalf ? new BezierCurve(this.start, ab, abbc, dest) : new BezierCurve(dest, bccd, cd, this.end);
            };
            BezierCurve.prototype.add = function (deltaX, deltaY) {
                return new BezierCurve(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
            };
            BezierCurve.prototype.reverse = function () {
                return new BezierCurve(this.end, this.endControl, this.startControl, this.start);
            };
            return BezierCurve;
        }());
        var isBezierCurve = function (path) { return path.type === PathType.BEZIER_CURVE; };

        var BoundCurves = /** @class */ (function () {
            function BoundCurves(element) {
                var styles = element.styles;
                var bounds = element.bounds;
                var _a = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a[0], tlv = _a[1];
                var _b = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b[0], trv = _b[1];
                var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
                var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
                var factors = [];
                factors.push((tlh + trh) / bounds.width);
                factors.push((blh + brh) / bounds.width);
                factors.push((tlv + blv) / bounds.height);
                factors.push((trv + brv) / bounds.height);
                var maxFactor = Math.max.apply(Math, factors);
                if (maxFactor > 1) {
                    tlh /= maxFactor;
                    tlv /= maxFactor;
                    trh /= maxFactor;
                    trv /= maxFactor;
                    brh /= maxFactor;
                    brv /= maxFactor;
                    blh /= maxFactor;
                    blv /= maxFactor;
                }
                var topWidth = bounds.width - trh;
                var rightHeight = bounds.height - brv;
                var bottomWidth = bounds.width - brh;
                var leftHeight = bounds.height - blv;
                var borderTopWidth = styles.borderTopWidth;
                var borderRightWidth = styles.borderRightWidth;
                var borderBottomWidth = styles.borderBottomWidth;
                var borderLeftWidth = styles.borderLeftWidth;
                var paddingTop = getAbsoluteValue(styles.paddingTop, element.bounds.width);
                var paddingRight = getAbsoluteValue(styles.paddingRight, element.bounds.width);
                var paddingBottom = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
                var paddingLeft = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
                this.topLeftBorderBox =
                    tlh > 0 || tlv > 0
                        ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT)
                        : new Vector(bounds.left, bounds.top);
                this.topRightBorderBox =
                    trh > 0 || trv > 0
                        ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT)
                        : new Vector(bounds.left + bounds.width, bounds.top);
                this.bottomRightBorderBox =
                    brh > 0 || brv > 0
                        ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT)
                        : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
                this.bottomLeftBorderBox =
                    blh > 0 || blv > 0
                        ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT)
                        : new Vector(bounds.left, bounds.top + bounds.height);
                this.topLeftPaddingBox =
                    tlh > 0 || tlv > 0
                        ? getCurvePoints(bounds.left + borderLeftWidth, bounds.top + borderTopWidth, Math.max(0, tlh - borderLeftWidth), Math.max(0, tlv - borderTopWidth), CORNER.TOP_LEFT)
                        : new Vector(bounds.left + borderLeftWidth, bounds.top + borderTopWidth);
                this.topRightPaddingBox =
                    trh > 0 || trv > 0
                        ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth), bounds.top + borderTopWidth, topWidth > bounds.width + borderLeftWidth ? 0 : trh - borderLeftWidth, trv - borderTopWidth, CORNER.TOP_RIGHT)
                        : new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + borderTopWidth);
                this.bottomRightPaddingBox =
                    brh > 0 || brv > 0
                        ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth), Math.max(0, brh - borderRightWidth), brv - borderBottomWidth, CORNER.BOTTOM_RIGHT)
                        : new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + bounds.height - borderBottomWidth);
                this.bottomLeftPaddingBox =
                    blh > 0 || blv > 0
                        ? getCurvePoints(bounds.left + borderLeftWidth, bounds.top + leftHeight, Math.max(0, blh - borderLeftWidth), blv - borderBottomWidth, CORNER.BOTTOM_LEFT)
                        : new Vector(bounds.left + borderLeftWidth, bounds.top + bounds.height - borderBottomWidth);
                this.topLeftContentBox =
                    tlh > 0 || tlv > 0
                        ? getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop, Math.max(0, tlh - (borderLeftWidth + paddingLeft)), Math.max(0, tlv - (borderTopWidth + paddingTop)), CORNER.TOP_LEFT)
                        : new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop);
                this.topRightContentBox =
                    trh > 0 || trv > 0
                        ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth + paddingLeft), bounds.top + borderTopWidth + paddingTop, topWidth > bounds.width + borderLeftWidth + paddingLeft ? 0 : trh - borderLeftWidth + paddingLeft, trv - (borderTopWidth + paddingTop), CORNER.TOP_RIGHT)
                        : new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + borderTopWidth + paddingTop);
                this.bottomRightContentBox =
                    brh > 0 || brv > 0
                        ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth + paddingLeft)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth + paddingTop), Math.max(0, brh - (borderRightWidth + paddingRight)), brv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_RIGHT)
                        : new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + bounds.height - (borderBottomWidth + paddingBottom));
                this.bottomLeftContentBox =
                    blh > 0 || blv > 0
                        ? getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth + paddingLeft)), blv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_LEFT)
                        : new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + bounds.height - (borderBottomWidth + paddingBottom));
            }
            return BoundCurves;
        }());
        var CORNER;
        (function (CORNER) {
            CORNER[CORNER["TOP_LEFT"] = 0] = "TOP_LEFT";
            CORNER[CORNER["TOP_RIGHT"] = 1] = "TOP_RIGHT";
            CORNER[CORNER["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
            CORNER[CORNER["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
        })(CORNER || (CORNER = {}));
        var getCurvePoints = function (x, y, r1, r2, position) {
            var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
            var ox = r1 * kappa; // control point offset horizontal
            var oy = r2 * kappa; // control point offset vertical
            var xm = x + r1; // x-middle
            var ym = y + r2; // y-middle
            switch (position) {
                case CORNER.TOP_LEFT:
                    return new BezierCurve(new Vector(x, ym), new Vector(x, ym - oy), new Vector(xm - ox, y), new Vector(xm, y));
                case CORNER.TOP_RIGHT:
                    return new BezierCurve(new Vector(x, y), new Vector(x + ox, y), new Vector(xm, ym - oy), new Vector(xm, ym));
                case CORNER.BOTTOM_RIGHT:
                    return new BezierCurve(new Vector(xm, y), new Vector(xm, y + oy), new Vector(x + ox, ym), new Vector(x, ym));
                case CORNER.BOTTOM_LEFT:
                default:
                    return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x, y + oy), new Vector(x, y));
            }
        };
        var calculateBorderBoxPath = function (curves) {
            return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
        };
        var calculateContentBoxPath = function (curves) {
            return [
                curves.topLeftContentBox,
                curves.topRightContentBox,
                curves.bottomRightContentBox,
                curves.bottomLeftContentBox
            ];
        };
        var calculatePaddingBoxPath = function (curves) {
            return [
                curves.topLeftPaddingBox,
                curves.topRightPaddingBox,
                curves.bottomRightPaddingBox,
                curves.bottomLeftPaddingBox
            ];
        };

        var TransformEffect = /** @class */ (function () {
            function TransformEffect(offsetX, offsetY, matrix) {
                this.type = 0 /* TRANSFORM */;
                this.offsetX = offsetX;
                this.offsetY = offsetY;
                this.matrix = matrix;
                this.target = 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */;
            }
            return TransformEffect;
        }());
        var ClipEffect = /** @class */ (function () {
            function ClipEffect(path, target) {
                this.type = 1 /* CLIP */;
                this.target = target;
                this.path = path;
            }
            return ClipEffect;
        }());
        var isTransformEffect = function (effect) {
            return effect.type === 0 /* TRANSFORM */;
        };
        var isClipEffect = function (effect) { return effect.type === 1 /* CLIP */; };

        var StackingContext = /** @class */ (function () {
            function StackingContext(container) {
                this.element = container;
                this.inlineLevel = [];
                this.nonInlineLevel = [];
                this.negativeZIndex = [];
                this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
                this.positiveZIndex = [];
                this.nonPositionedFloats = [];
                this.nonPositionedInlineLevel = [];
            }
            return StackingContext;
        }());
        var ElementPaint = /** @class */ (function () {
            function ElementPaint(element, parentStack) {
                this.container = element;
                this.effects = parentStack.slice(0);
                this.curves = new BoundCurves(element);
                if (element.styles.transform !== null) {
                    var offsetX = element.bounds.left + element.styles.transformOrigin[0].number;
                    var offsetY = element.bounds.top + element.styles.transformOrigin[1].number;
                    var matrix = element.styles.transform;
                    this.effects.push(new TransformEffect(offsetX, offsetY, matrix));
                }
                if (element.styles.overflowX !== OVERFLOW.VISIBLE) {
                    var borderBox = calculateBorderBoxPath(this.curves);
                    var paddingBox = calculatePaddingBoxPath(this.curves);
                    if (equalPath(borderBox, paddingBox)) {
                        this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));
                    }
                    else {
                        this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */));
                        this.effects.push(new ClipEffect(paddingBox, 4 /* CONTENT */));
                    }
                }
            }
            ElementPaint.prototype.getParentEffects = function () {
                var effects = this.effects.slice(0);
                if (this.container.styles.overflowX !== OVERFLOW.VISIBLE) {
                    var borderBox = calculateBorderBoxPath(this.curves);
                    var paddingBox = calculatePaddingBoxPath(this.curves);
                    if (!equalPath(borderBox, paddingBox)) {
                        effects.push(new ClipEffect(paddingBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));
                    }
                }
                return effects;
            };
            return ElementPaint;
        }());
        var parseStackTree = function (parent, stackingContext, realStackingContext, listItems) {
            parent.container.elements.forEach(function (child) {
                var treatAsRealStackingContext = contains(child.flags, 4 /* CREATES_REAL_STACKING_CONTEXT */);
                var createsStackingContext = contains(child.flags, 2 /* CREATES_STACKING_CONTEXT */);
                var paintContainer = new ElementPaint(child, parent.getParentEffects());
                if (contains(child.styles.display, 2048 /* LIST_ITEM */)) {
                    listItems.push(paintContainer);
                }
                var listOwnerItems = contains(child.flags, 8 /* IS_LIST_OWNER */) ? [] : listItems;
                if (treatAsRealStackingContext || createsStackingContext) {
                    var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
                    var stack = new StackingContext(paintContainer);
                    if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
                        var order_1 = child.styles.zIndex.order;
                        if (order_1 < 0) {
                            var index_1 = 0;
                            parentStack.negativeZIndex.some(function (current, i) {
                                if (order_1 > current.element.container.styles.zIndex.order) {
                                    index_1 = i;
                                    return false;
                                }
                                else if (index_1 > 0) {
                                    return true;
                                }
                                return false;
                            });
                            parentStack.negativeZIndex.splice(index_1, 0, stack);
                        }
                        else if (order_1 > 0) {
                            var index_2 = 0;
                            parentStack.positiveZIndex.some(function (current, i) {
                                if (order_1 >= current.element.container.styles.zIndex.order) {
                                    index_2 = i + 1;
                                    return false;
                                }
                                else if (index_2 > 0) {
                                    return true;
                                }
                                return false;
                            });
                            parentStack.positiveZIndex.splice(index_2, 0, stack);
                        }
                        else {
                            parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
                        }
                    }
                    else {
                        if (child.styles.isFloating()) {
                            parentStack.nonPositionedFloats.push(stack);
                        }
                        else {
                            parentStack.nonPositionedInlineLevel.push(stack);
                        }
                    }
                    parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
                }
                else {
                    if (child.styles.isInlineLevel()) {
                        stackingContext.inlineLevel.push(paintContainer);
                    }
                    else {
                        stackingContext.nonInlineLevel.push(paintContainer);
                    }
                    parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
                }
                if (contains(child.flags, 8 /* IS_LIST_OWNER */)) {
                    processListItems(child, listOwnerItems);
                }
            });
        };
        var processListItems = function (owner, elements) {
            var numbering = owner instanceof OLElementContainer ? owner.start : 1;
            var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
            for (var i = 0; i < elements.length; i++) {
                var item = elements[i];
                if (item.container instanceof LIElementContainer &&
                    typeof item.container.value === 'number' &&
                    item.container.value !== 0) {
                    numbering = item.container.value;
                }
                item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
                numbering += reversed ? -1 : 1;
            }
        };
        var parseStackingContexts = function (container) {
            var paintContainer = new ElementPaint(container, []);
            var root = new StackingContext(paintContainer);
            var listItems = [];
            parseStackTree(paintContainer, root, root, listItems);
            processListItems(paintContainer.container, listItems);
            return root;
        };

        var parsePathForBorder = function (curves, borderSide) {
            switch (borderSide) {
                case 0:
                    return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
                case 1:
                    return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
                case 2:
                    return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
                case 3:
                default:
                    return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
            }
        };
        var createPathFromCurves = function (outer1, inner1, outer2, inner2) {
            var path = [];
            if (isBezierCurve(outer1)) {
                path.push(outer1.subdivide(0.5, false));
            }
            else {
                path.push(outer1);
            }
            if (isBezierCurve(outer2)) {
                path.push(outer2.subdivide(0.5, true));
            }
            else {
                path.push(outer2);
            }
            if (isBezierCurve(inner2)) {
                path.push(inner2.subdivide(0.5, true).reverse());
            }
            else {
                path.push(inner2);
            }
            if (isBezierCurve(inner1)) {
                path.push(inner1.subdivide(0.5, false).reverse());
            }
            else {
                path.push(inner1);
            }
            return path;
        };

        var paddingBox = function (element) {
            var bounds = element.bounds;
            var styles = element.styles;
            return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
        };
        var contentBox = function (element) {
            var styles = element.styles;
            var bounds = element.bounds;
            var paddingLeft = getAbsoluteValue(styles.paddingLeft, bounds.width);
            var paddingRight = getAbsoluteValue(styles.paddingRight, bounds.width);
            var paddingTop = getAbsoluteValue(styles.paddingTop, bounds.width);
            var paddingBottom = getAbsoluteValue(styles.paddingBottom, bounds.width);
            return bounds.add(paddingLeft + styles.borderLeftWidth, paddingTop + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft + paddingRight), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop + paddingBottom));
        };

        var calculateBackgroundPositioningArea = function (backgroundOrigin, element) {
            if (backgroundOrigin === 0 /* BORDER_BOX */) {
                return element.bounds;
            }
            if (backgroundOrigin === 2 /* CONTENT_BOX */) {
                return contentBox(element);
            }
            return paddingBox(element);
        };
        var calculateBackgroundPaintingArea = function (backgroundClip, element) {
            if (backgroundClip === BACKGROUND_CLIP.BORDER_BOX) {
                return element.bounds;
            }
            if (backgroundClip === BACKGROUND_CLIP.CONTENT_BOX) {
                return contentBox(element);
            }
            return paddingBox(element);
        };
        var calculateBackgroundRendering = function (container, index, intrinsicSize) {
            var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index), container);
            var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index), container);
            var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index), intrinsicSize, backgroundPositioningArea);
            var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
            var position = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
            var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index), position, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
            var offsetX = Math.round(backgroundPositioningArea.left + position[0]);
            var offsetY = Math.round(backgroundPositioningArea.top + position[1]);
            return [path, offsetX, offsetY, sizeWidth, sizeHeight];
        };
        var isAuto = function (token) { return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO; };
        var hasIntrinsicValue = function (value) { return typeof value === 'number'; };
        var calculateBackgroundSize = function (size, _a, bounds) {
            var intrinsicWidth = _a[0], intrinsicHeight = _a[1], intrinsicProportion = _a[2];
            var first = size[0], second = size[1];
            if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
                return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
            }
            var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
            if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
                if (hasIntrinsicValue(intrinsicProportion)) {
                    var targetRatio = bounds.width / bounds.height;
                    return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER)
                        ? [bounds.width, bounds.width / intrinsicProportion]
                        : [bounds.height * intrinsicProportion, bounds.height];
                }
                return [bounds.width, bounds.height];
            }
            var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
            var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
            var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
            // If the background-size is auto or auto auto:
            if (isAuto(first) && (!second || isAuto(second))) {
                // If the image has both horizontal and vertical intrinsic dimensions, it's rendered at that size.
                if (hasIntrinsicWidth && hasIntrinsicHeight) {
                    return [intrinsicWidth, intrinsicHeight];
                }
                // If the image has no intrinsic dimensions and has no intrinsic proportions,
                // it's rendered at the size of the background positioning area.
                if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
                    return [bounds.width, bounds.height];
                }
                // TODO If the image has no intrinsic dimensions but has intrinsic proportions, it's rendered as if contain had been specified instead.
                // If the image has only one intrinsic dimension and has intrinsic proportions, it's rendered at the size corresponding to that one dimension.
                // The other dimension is computed using the specified dimension and the intrinsic proportions.
                if (hasIntrinsicDimensions && hasIntrinsicProportion) {
                    var width_1 = hasIntrinsicWidth
                        ? intrinsicWidth
                        : intrinsicHeight * intrinsicProportion;
                    var height_1 = hasIntrinsicHeight
                        ? intrinsicHeight
                        : intrinsicWidth / intrinsicProportion;
                    return [width_1, height_1];
                }
                // If the image has only one intrinsic dimension but has no intrinsic proportions,
                // it's rendered using the specified dimension and the other dimension of the background positioning area.
                var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
                var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
                return [width_2, height_2];
            }
            // If the image has intrinsic proportions, it's stretched to the specified dimension.
            // The unspecified dimension is computed using the specified dimension and the intrinsic proportions.
            if (hasIntrinsicProportion) {
                var width_3 = 0;
                var height_3 = 0;
                if (isLengthPercentage(first)) {
                    width_3 = getAbsoluteValue(first, bounds.width);
                }
                else if (isLengthPercentage(second)) {
                    height_3 = getAbsoluteValue(second, bounds.height);
                }
                if (isAuto(first)) {
                    width_3 = height_3 * intrinsicProportion;
                }
                else if (!second || isAuto(second)) {
                    height_3 = width_3 / intrinsicProportion;
                }
                return [width_3, height_3];
            }
            // If the image has no intrinsic proportions, it's stretched to the specified dimension.
            // The unspecified dimension is computed using the image's corresponding intrinsic dimension,
            // if there is one. If there is no such intrinsic dimension,
            // it becomes the corresponding dimension of the background positioning area.
            var width = null;
            var height = null;
            if (isLengthPercentage(first)) {
                width = getAbsoluteValue(first, bounds.width);
            }
            else if (second && isLengthPercentage(second)) {
                height = getAbsoluteValue(second, bounds.height);
            }
            if (width !== null && (!second || isAuto(second))) {
                height =
                    hasIntrinsicWidth && hasIntrinsicHeight
                        ? (width / intrinsicWidth) * intrinsicHeight
                        : bounds.height;
            }
            if (height !== null && isAuto(first)) {
                width =
                    hasIntrinsicWidth && hasIntrinsicHeight
                        ? (height / intrinsicHeight) * intrinsicWidth
                        : bounds.width;
            }
            if (width !== null && height !== null) {
                return [width, height];
            }
            throw new Error("Unable to calculate background-size for element");
        };
        var getBackgroundValueForIndex = function (values, index) {
            var value = values[index];
            if (typeof value === 'undefined') {
                return values[0];
            }
            return value;
        };
        var calculateBackgroundRepeatPath = function (repeat, _a, _b, backgroundPositioningArea, backgroundPaintingArea) {
            var x = _a[0], y = _a[1];
            var width = _b[0], height = _b[1];
            switch (repeat) {
                case BACKGROUND_REPEAT.REPEAT_X:
                    return [
                        new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y)),
                        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y)),
                        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y)),
                        new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y))
                    ];
                case BACKGROUND_REPEAT.REPEAT_Y:
                    return [
                        new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top)),
                        new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top)),
                        new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
                        new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
                    ];
                case BACKGROUND_REPEAT.NO_REPEAT:
                    return [
                        new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y)),
                        new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y)),
                        new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y + height)),
                        new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y + height))
                    ];
                default:
                    return [
                        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
                        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
                        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
                        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
                    ];
            }
        };

        var SMALL_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

        var SAMPLE_TEXT = 'Hidden Text';
        var FontMetrics = /** @class */ (function () {
            function FontMetrics(document) {
                this._data = {};
                this._document = document;
            }
            FontMetrics.prototype.parseMetrics = function (fontFamily, fontSize) {
                var container = this._document.createElement('div');
                var img = this._document.createElement('img');
                var span = this._document.createElement('span');
                var body = this._document.body;
                container.style.visibility = 'hidden';
                container.style.fontFamily = fontFamily;
                container.style.fontSize = fontSize;
                container.style.margin = '0';
                container.style.padding = '0';
                body.appendChild(container);
                img.src = SMALL_IMAGE;
                img.width = 1;
                img.height = 1;
                img.style.margin = '0';
                img.style.padding = '0';
                img.style.verticalAlign = 'baseline';
                span.style.fontFamily = fontFamily;
                span.style.fontSize = fontSize;
                span.style.margin = '0';
                span.style.padding = '0';
                span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
                container.appendChild(span);
                container.appendChild(img);
                var baseline = img.offsetTop - span.offsetTop + 2;
                container.removeChild(span);
                container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
                container.style.lineHeight = 'normal';
                img.style.verticalAlign = 'super';
                var middle = img.offsetTop - container.offsetTop + 2;
                body.removeChild(container);
                return { baseline: baseline, middle: middle };
            };
            FontMetrics.prototype.getMetrics = function (fontFamily, fontSize) {
                var key = fontFamily + " " + fontSize;
                if (typeof this._data[key] === 'undefined') {
                    this._data[key] = this.parseMetrics(fontFamily, fontSize);
                }
                return this._data[key];
            };
            return FontMetrics;
        }());

        var MASK_OFFSET = 10000;
        var CanvasRenderer = /** @class */ (function () {
            function CanvasRenderer(options) {
                this._activeEffects = [];
                this.canvas = options.canvas ? options.canvas : document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.options = options;
                if (!options.canvas) {
                    this.canvas.width = Math.floor(options.width * options.scale);
                    this.canvas.height = Math.floor(options.height * options.scale);
                    this.canvas.style.width = options.width + "px";
                    this.canvas.style.height = options.height + "px";
                }
                this.fontMetrics = new FontMetrics(document);
                this.ctx.scale(this.options.scale, this.options.scale);
                this.ctx.translate(-options.x + options.scrollX, -options.y + options.scrollY);
                this.ctx.textBaseline = 'bottom';
                this._activeEffects = [];
                Logger.getInstance(options.id).debug("Canvas renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
            }
            CanvasRenderer.prototype.applyEffects = function (effects, target) {
                var _this = this;
                while (this._activeEffects.length) {
                    this.popEffect();
                }
                effects.filter(function (effect) { return contains(effect.target, target); }).forEach(function (effect) { return _this.applyEffect(effect); });
            };
            CanvasRenderer.prototype.applyEffect = function (effect) {
                this.ctx.save();
                if (isTransformEffect(effect)) {
                    this.ctx.translate(effect.offsetX, effect.offsetY);
                    this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
                    this.ctx.translate(-effect.offsetX, -effect.offsetY);
                }
                if (isClipEffect(effect)) {
                    this.path(effect.path);
                    this.ctx.clip();
                }
                this._activeEffects.push(effect);
            };
            CanvasRenderer.prototype.popEffect = function () {
                this._activeEffects.pop();
                this.ctx.restore();
            };
            CanvasRenderer.prototype.renderStack = function (stack) {
                return __awaiter(this, void 0, void 0, function () {
                    var styles;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                styles = stack.element.container.styles;
                                if (!styles.isVisible()) return [3 /*break*/, 2];
                                this.ctx.globalAlpha = styles.opacity;
                                return [4 /*yield*/, this.renderStackContent(stack)];
                            case 1:
                                _a.sent();
                                _a.label = 2;
                            case 2: return [2 /*return*/];
                        }
                    });
                });
            };
            CanvasRenderer.prototype.renderNode = function (paint) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!paint.container.styles.isVisible()) return [3 /*break*/, 3];
                                return [4 /*yield*/, this.renderNodeBackgroundAndBorders(paint)];
                            case 1:
                                _a.sent();
                                return [4 /*yield*/, this.renderNodeContent(paint)];
                            case 2:
                                _a.sent();
                                _a.label = 3;
                            case 3: return [2 /*return*/];
                        }
                    });
                });
            };
            CanvasRenderer.prototype.renderTextWithLetterSpacing = function (text, letterSpacing) {
                var _this = this;
                if (letterSpacing === 0) {
                    this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + text.bounds.height);
                }
                else {
                    var letters = toCodePoints(text.text).map(function (i) { return fromCodePoint(i); });
                    letters.reduce(function (left, letter) {
                        _this.ctx.fillText(letter, left, text.bounds.top + text.bounds.height);
                        return left + _this.ctx.measureText(letter).width;
                    }, text.bounds.left);
                }
            };
            CanvasRenderer.prototype.createFontStyle = function (styles) {
                var fontVariant = styles.fontVariant
                    .filter(function (variant) { return variant === 'normal' || variant === 'small-caps'; })
                    .join('');
                var fontFamily = styles.fontFamily.join(', ');
                var fontSize = isDimensionToken(styles.fontSize)
                    ? "" + styles.fontSize.number + styles.fontSize.unit
                    : styles.fontSize.number + "px";
                return [
                    [styles.fontStyle, fontVariant, styles.fontWeight, fontSize, fontFamily].join(' '),
                    fontFamily,
                    fontSize
                ];
            };
            CanvasRenderer.prototype.renderTextNode = function (text, styles) {
                return __awaiter(this, void 0, void 0, function () {
                    var _a, font, fontFamily, fontSize;
                    var _this = this;
                    return __generator(this, function (_b) {
                        _a = this.createFontStyle(styles), font = _a[0], fontFamily = _a[1], fontSize = _a[2];
                        this.ctx.font = font;
                        text.textBounds.forEach(function (text) {
                            _this.ctx.fillStyle = asString(styles.color);
                            _this.renderTextWithLetterSpacing(text, styles.letterSpacing);
                            var textShadows = styles.textShadow;
                            if (textShadows.length && text.text.trim().length) {
                                textShadows
                                    .slice(0)
                                    .reverse()
                                    .forEach(function (textShadow) {
                                    _this.ctx.shadowColor = asString(textShadow.color);
                                    _this.ctx.shadowOffsetX = textShadow.offsetX.number * _this.options.scale;
                                    _this.ctx.shadowOffsetY = textShadow.offsetY.number * _this.options.scale;
                                    _this.ctx.shadowBlur = textShadow.blur.number;
                                    _this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + text.bounds.height);
                                });
                                _this.ctx.shadowColor = '';
                                _this.ctx.shadowOffsetX = 0;
                                _this.ctx.shadowOffsetY = 0;
                                _this.ctx.shadowBlur = 0;
                            }
                            if (styles.textDecorationLine.length) {
                                _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                                styles.textDecorationLine.forEach(function (textDecorationLine) {
                                    switch (textDecorationLine) {
                                        case 1 /* UNDERLINE */:
                                            // Draws a line at the baseline of the font
                                            // TODO As some browsers display the line as more than 1px if the font-size is big,
                                            // need to take that into account both in position and size
                                            var baseline = _this.fontMetrics.getMetrics(fontFamily, fontSize).baseline;
                                            _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top + baseline), text.bounds.width, 1);
                                            break;
                                        case 2 /* OVERLINE */:
                                            _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top), text.bounds.width, 1);
                                            break;
                                        case 3 /* LINE_THROUGH */:
                                            // TODO try and find exact position for line-through
                                            var middle = _this.fontMetrics.getMetrics(fontFamily, fontSize).middle;
                                            _this.ctx.fillRect(text.bounds.left, Math.ceil(text.bounds.top + middle), text.bounds.width, 1);
                                            break;
                                    }
                                });
                            }
                        });
                        return [2 /*return*/];
                    });
                });
            };
            CanvasRenderer.prototype.renderReplacedElement = function (container, curves, image) {
                if (image && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
                    var box = contentBox(container);
                    var path = calculatePaddingBoxPath(curves);
                    this.path(path);
                    this.ctx.save();
                    this.ctx.clip();
                    this.ctx.drawImage(image, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
                    this.ctx.restore();
                }
            };
            CanvasRenderer.prototype.renderNodeContent = function (paint) {
                return __awaiter(this, void 0, void 0, function () {
                    var container, curves, styles, _i, _a, child, image, image, iframeRenderer, canvas, size, bounds, x, textBounds, img, image, url, bounds;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                this.applyEffects(paint.effects, 4 /* CONTENT */);
                                container = paint.container;
                                curves = paint.curves;
                                styles = container.styles;
                                _i = 0, _a = container.textNodes;
                                _b.label = 1;
                            case 1:
                                if (!(_i < _a.length)) return [3 /*break*/, 4];
                                child = _a[_i];
                                return [4 /*yield*/, this.renderTextNode(child, styles)];
                            case 2:
                                _b.sent();
                                _b.label = 3;
                            case 3:
                                _i++;
                                return [3 /*break*/, 1];
                            case 4:
                                if (!(container instanceof ImageElementContainer)) return [3 /*break*/, 8];
                                _b.label = 5;
                            case 5:
                                _b.trys.push([5, 7, , 8]);
                                return [4 /*yield*/, this.options.cache.match(container.src)];
                            case 6:
                                image = _b.sent();
                                this.renderReplacedElement(container, curves, image);
                                return [3 /*break*/, 8];
                            case 7:
                                _b.sent();
                                Logger.getInstance(this.options.id).error("Error loading image " + container.src);
                                return [3 /*break*/, 8];
                            case 8:
                                if (container instanceof CanvasElementContainer) {
                                    this.renderReplacedElement(container, curves, container.canvas);
                                }
                                if (!(container instanceof SVGElementContainer)) return [3 /*break*/, 12];
                                _b.label = 9;
                            case 9:
                                _b.trys.push([9, 11, , 12]);
                                return [4 /*yield*/, this.options.cache.match(container.svg)];
                            case 10:
                                image = _b.sent();
                                this.renderReplacedElement(container, curves, image);
                                return [3 /*break*/, 12];
                            case 11:
                                _b.sent();
                                Logger.getInstance(this.options.id).error("Error loading svg " + container.svg.substring(0, 255));
                                return [3 /*break*/, 12];
                            case 12:
                                if (!(container instanceof IFrameElementContainer && container.tree)) return [3 /*break*/, 14];
                                iframeRenderer = new CanvasRenderer({
                                    id: this.options.id,
                                    scale: this.options.scale,
                                    backgroundColor: container.backgroundColor,
                                    x: 0,
                                    y: 0,
                                    scrollX: 0,
                                    scrollY: 0,
                                    width: container.width,
                                    height: container.height,
                                    cache: this.options.cache,
                                    windowWidth: container.width,
                                    windowHeight: container.height
                                });
                                return [4 /*yield*/, iframeRenderer.render(container.tree)];
                            case 13:
                                canvas = _b.sent();
                                if (container.width && container.height) {
                                    this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
                                }
                                _b.label = 14;
                            case 14:
                                if (container instanceof InputElementContainer) {
                                    size = Math.min(container.bounds.width, container.bounds.height);
                                    if (container.type === CHECKBOX) {
                                        if (container.checked) {
                                            this.ctx.save();
                                            this.path([
                                                new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                                                new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                                                new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                                                new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                                                new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                                                new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                                                new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
                                            ]);
                                            this.ctx.fillStyle = asString(INPUT_COLOR);
                                            this.ctx.fill();
                                            this.ctx.restore();
                                        }
                                    }
                                    else if (container.type === RADIO) {
                                        if (container.checked) {
                                            this.ctx.save();
                                            this.ctx.beginPath();
                                            this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                                            this.ctx.fillStyle = asString(INPUT_COLOR);
                                            this.ctx.fill();
                                            this.ctx.restore();
                                        }
                                    }
                                }
                                if (isTextInputElement(container) && container.value.length) {
                                    this.ctx.font = this.createFontStyle(styles)[0];
                                    this.ctx.fillStyle = asString(styles.color);
                                    this.ctx.textBaseline = 'middle';
                                    this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                                    bounds = contentBox(container);
                                    x = 0;
                                    switch (container.styles.textAlign) {
                                        case TEXT_ALIGN.CENTER:
                                            x += bounds.width / 2;
                                            break;
                                        case TEXT_ALIGN.RIGHT:
                                            x += bounds.width;
                                            break;
                                    }
                                    textBounds = bounds.add(x, 0, 0, -bounds.height / 2 + 1);
                                    this.ctx.save();
                                    this.path([
                                        new Vector(bounds.left, bounds.top),
                                        new Vector(bounds.left + bounds.width, bounds.top),
                                        new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                                        new Vector(bounds.left, bounds.top + bounds.height)
                                    ]);
                                    this.ctx.clip();
                                    this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing);
                                    this.ctx.restore();
                                    this.ctx.textBaseline = 'bottom';
                                    this.ctx.textAlign = 'left';
                                }
                                if (!contains(container.styles.display, 2048 /* LIST_ITEM */)) return [3 /*break*/, 20];
                                if (!(container.styles.listStyleImage !== null)) return [3 /*break*/, 19];
                                img = container.styles.listStyleImage;
                                if (!(img.type === CSSImageType.URL)) return [3 /*break*/, 18];
                                image = void 0;
                                url = img.url;
                                _b.label = 15;
                            case 15:
                                _b.trys.push([15, 17, , 18]);
                                return [4 /*yield*/, this.options.cache.match(url)];
                            case 16:
                                image = _b.sent();
                                this.ctx.drawImage(image, container.bounds.left - (image.width + 10), container.bounds.top);
                                return [3 /*break*/, 18];
                            case 17:
                                _b.sent();
                                Logger.getInstance(this.options.id).error("Error loading list-style-image " + url);
                                return [3 /*break*/, 18];
                            case 18: return [3 /*break*/, 20];
                            case 19:
                                if (paint.listValue && container.styles.listStyleType !== LIST_STYLE_TYPE.NONE) {
                                    this.ctx.font = this.createFontStyle(styles)[0];
                                    this.ctx.fillStyle = asString(styles.color);
                                    this.ctx.textBaseline = 'middle';
                                    this.ctx.textAlign = 'right';
                                    bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
                                    this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing);
                                    this.ctx.textBaseline = 'bottom';
                                    this.ctx.textAlign = 'left';
                                }
                                _b.label = 20;
                            case 20: return [2 /*return*/];
                        }
                    });
                });
            };
            CanvasRenderer.prototype.renderStackContent = function (stack) {
                return __awaiter(this, void 0, void 0, function () {
                    var _i, _a, child, _b, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
                    return __generator(this, function (_p) {
                        switch (_p.label) {
                            case 0: 
                            // https://www.w3.org/TR/css-position-3/#painting-order
                            // 1. the background and borders of the element forming the stacking context.
                            return [4 /*yield*/, this.renderNodeBackgroundAndBorders(stack.element)];
                            case 1:
                                // https://www.w3.org/TR/css-position-3/#painting-order
                                // 1. the background and borders of the element forming the stacking context.
                                _p.sent();
                                _i = 0, _a = stack.negativeZIndex;
                                _p.label = 2;
                            case 2:
                                if (!(_i < _a.length)) return [3 /*break*/, 5];
                                child = _a[_i];
                                return [4 /*yield*/, this.renderStack(child)];
                            case 3:
                                _p.sent();
                                _p.label = 4;
                            case 4:
                                _i++;
                                return [3 /*break*/, 2];
                            case 5: 
                            // 3. For all its in-flow, non-positioned, block-level descendants in tree order:
                            return [4 /*yield*/, this.renderNodeContent(stack.element)];
                            case 6:
                                // 3. For all its in-flow, non-positioned, block-level descendants in tree order:
                                _p.sent();
                                _b = 0, _c = stack.nonInlineLevel;
                                _p.label = 7;
                            case 7:
                                if (!(_b < _c.length)) return [3 /*break*/, 10];
                                child = _c[_b];
                                return [4 /*yield*/, this.renderNode(child)];
                            case 8:
                                _p.sent();
                                _p.label = 9;
                            case 9:
                                _b++;
                                return [3 /*break*/, 7];
                            case 10:
                                _d = 0, _e = stack.nonPositionedFloats;
                                _p.label = 11;
                            case 11:
                                if (!(_d < _e.length)) return [3 /*break*/, 14];
                                child = _e[_d];
                                return [4 /*yield*/, this.renderStack(child)];
                            case 12:
                                _p.sent();
                                _p.label = 13;
                            case 13:
                                _d++;
                                return [3 /*break*/, 11];
                            case 14:
                                _f = 0, _g = stack.nonPositionedInlineLevel;
                                _p.label = 15;
                            case 15:
                                if (!(_f < _g.length)) return [3 /*break*/, 18];
                                child = _g[_f];
                                return [4 /*yield*/, this.renderStack(child)];
                            case 16:
                                _p.sent();
                                _p.label = 17;
                            case 17:
                                _f++;
                                return [3 /*break*/, 15];
                            case 18:
                                _h = 0, _j = stack.inlineLevel;
                                _p.label = 19;
                            case 19:
                                if (!(_h < _j.length)) return [3 /*break*/, 22];
                                child = _j[_h];
                                return [4 /*yield*/, this.renderNode(child)];
                            case 20:
                                _p.sent();
                                _p.label = 21;
                            case 21:
                                _h++;
                                return [3 /*break*/, 19];
                            case 22:
                                _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
                                _p.label = 23;
                            case 23:
                                if (!(_k < _l.length)) return [3 /*break*/, 26];
                                child = _l[_k];
                                return [4 /*yield*/, this.renderStack(child)];
                            case 24:
                                _p.sent();
                                _p.label = 25;
                            case 25:
                                _k++;
                                return [3 /*break*/, 23];
                            case 26:
                                _m = 0, _o = stack.positiveZIndex;
                                _p.label = 27;
                            case 27:
                                if (!(_m < _o.length)) return [3 /*break*/, 30];
                                child = _o[_m];
                                return [4 /*yield*/, this.renderStack(child)];
                            case 28:
                                _p.sent();
                                _p.label = 29;
                            case 29:
                                _m++;
                                return [3 /*break*/, 27];
                            case 30: return [2 /*return*/];
                        }
                    });
                });
            };
            CanvasRenderer.prototype.mask = function (paths) {
                this.ctx.beginPath();
                this.ctx.moveTo(0, 0);
                this.ctx.lineTo(this.canvas.width, 0);
                this.ctx.lineTo(this.canvas.width, this.canvas.height);
                this.ctx.lineTo(0, this.canvas.height);
                this.ctx.lineTo(0, 0);
                this.formatPath(paths.slice(0).reverse());
                this.ctx.closePath();
            };
            CanvasRenderer.prototype.path = function (paths) {
                this.ctx.beginPath();
                this.formatPath(paths);
                this.ctx.closePath();
            };
            CanvasRenderer.prototype.formatPath = function (paths) {
                var _this = this;
                paths.forEach(function (point, index) {
                    var start = isBezierCurve(point) ? point.start : point;
                    if (index === 0) {
                        _this.ctx.moveTo(start.x, start.y);
                    }
                    else {
                        _this.ctx.lineTo(start.x, start.y);
                    }
                    if (isBezierCurve(point)) {
                        _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
                    }
                });
            };
            CanvasRenderer.prototype.renderRepeat = function (path, pattern, offsetX, offsetY) {
                this.path(path);
                this.ctx.fillStyle = pattern;
                this.ctx.translate(offsetX, offsetY);
                this.ctx.fill();
                this.ctx.translate(-offsetX, -offsetY);
            };
            CanvasRenderer.prototype.resizeImage = function (image, width, height) {
                if (image.width === width && image.height === height) {
                    return image;
                }
                var canvas = this.canvas.ownerDocument.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                var ctx = canvas.getContext('2d');
                ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, width, height);
                return canvas;
            };
            CanvasRenderer.prototype.renderBackgroundImage = function (container) {
                return __awaiter(this, void 0, void 0, function () {
                    var index, _loop_1, this_1, _i, _a, backgroundImage;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                index = container.styles.backgroundImage.length - 1;
                                _loop_1 = function (backgroundImage) {
                                    var image, url, _a, path, x, y, width, height, pattern, _b, path, x, y, width, height, _c, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _d, path, left, top_1, width, height, position, x, y, _e, rx, ry, radialGradient_1, midX, midY, f, invF;
                                    return __generator(this, function (_f) {
                                        switch (_f.label) {
                                            case 0:
                                                if (!(backgroundImage.type === CSSImageType.URL)) return [3 /*break*/, 5];
                                                image = void 0;
                                                url = backgroundImage.url;
                                                _f.label = 1;
                                            case 1:
                                                _f.trys.push([1, 3, , 4]);
                                                return [4 /*yield*/, this_1.options.cache.match(url)];
                                            case 2:
                                                image = _f.sent();
                                                return [3 /*break*/, 4];
                                            case 3:
                                                _f.sent();
                                                Logger.getInstance(this_1.options.id).error("Error loading background-image " + url);
                                                return [3 /*break*/, 4];
                                            case 4:
                                                if (image) {
                                                    _a = calculateBackgroundRendering(container, index, [
                                                        image.width,
                                                        image.height,
                                                        image.width / image.height
                                                    ]), path = _a[0], x = _a[1], y = _a[2], width = _a[3], height = _a[4];
                                                    pattern = this_1.ctx.createPattern(this_1.resizeImage(image, width, height), 'repeat');
                                                    this_1.renderRepeat(path, pattern, x, y);
                                                }
                                                return [3 /*break*/, 6];
                                            case 5:
                                                if (isLinearGradient(backgroundImage)) {
                                                    _b = calculateBackgroundRendering(container, index, [null, null, null]), path = _b[0], x = _b[1], y = _b[2], width = _b[3], height = _b[4];
                                                    _c = calculateGradientDirection(backgroundImage.angle, width, height), lineLength = _c[0], x0 = _c[1], x1 = _c[2], y0 = _c[3], y1 = _c[4];
                                                    canvas = document.createElement('canvas');
                                                    canvas.width = width;
                                                    canvas.height = height;
                                                    ctx = canvas.getContext('2d');
                                                    gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                                                    processColorStops(backgroundImage.stops, lineLength).forEach(function (colorStop) {
                                                        return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                                                    });
                                                    ctx.fillStyle = gradient_1;
                                                    ctx.fillRect(0, 0, width, height);
                                                    if (width > 0 && height > 0) {
                                                        pattern = this_1.ctx.createPattern(canvas, 'repeat');
                                                        this_1.renderRepeat(path, pattern, x, y);
                                                    }
                                                }
                                                else if (isRadialGradient(backgroundImage)) {
                                                    _d = calculateBackgroundRendering(container, index, [
                                                        null,
                                                        null,
                                                        null
                                                    ]), path = _d[0], left = _d[1], top_1 = _d[2], width = _d[3], height = _d[4];
                                                    position = backgroundImage.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage.position;
                                                    x = getAbsoluteValue(position[0], width);
                                                    y = getAbsoluteValue(position[position.length - 1], height);
                                                    _e = calculateRadius(backgroundImage, x, y, width, height), rx = _e[0], ry = _e[1];
                                                    if (rx > 0 && rx > 0) {
                                                        radialGradient_1 = this_1.ctx.createRadialGradient(left + x, top_1 + y, 0, left + x, top_1 + y, rx);
                                                        processColorStops(backgroundImage.stops, rx * 2).forEach(function (colorStop) {
                                                            return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                                                        });
                                                        this_1.path(path);
                                                        this_1.ctx.fillStyle = radialGradient_1;
                                                        if (rx !== ry) {
                                                            midX = container.bounds.left + 0.5 * container.bounds.width;
                                                            midY = container.bounds.top + 0.5 * container.bounds.height;
                                                            f = ry / rx;
                                                            invF = 1 / f;
                                                            this_1.ctx.save();
                                                            this_1.ctx.translate(midX, midY);
                                                            this_1.ctx.transform(1, 0, 0, f, 0, 0);
                                                            this_1.ctx.translate(-midX, -midY);
                                                            this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                                                            this_1.ctx.restore();
                                                        }
                                                        else {
                                                            this_1.ctx.fill();
                                                        }
                                                    }
                                                }
                                                _f.label = 6;
                                            case 6:
                                                index--;
                                                return [2 /*return*/];
                                        }
                                    });
                                };
                                this_1 = this;
                                _i = 0, _a = container.styles.backgroundImage.slice(0).reverse();
                                _b.label = 1;
                            case 1:
                                if (!(_i < _a.length)) return [3 /*break*/, 4];
                                backgroundImage = _a[_i];
                                return [5 /*yield**/, _loop_1(backgroundImage)];
                            case 2:
                                _b.sent();
                                _b.label = 3;
                            case 3:
                                _i++;
                                return [3 /*break*/, 1];
                            case 4: return [2 /*return*/];
                        }
                    });
                });
            };
            CanvasRenderer.prototype.renderBorder = function (color, side, curvePoints) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        this.path(parsePathForBorder(curvePoints, side));
                        this.ctx.fillStyle = asString(color);
                        this.ctx.fill();
                        return [2 /*return*/];
                    });
                });
            };
            CanvasRenderer.prototype.renderNodeBackgroundAndBorders = function (paint) {
                return __awaiter(this, void 0, void 0, function () {
                    var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
                    var _this = this;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                this.applyEffects(paint.effects, 2 /* BACKGROUND_BORDERS */);
                                styles = paint.container.styles;
                                hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
                                borders = [
                                    { style: styles.borderTopStyle, color: styles.borderTopColor },
                                    { style: styles.borderRightStyle, color: styles.borderRightColor },
                                    { style: styles.borderBottomStyle, color: styles.borderBottomColor },
                                    { style: styles.borderLeftStyle, color: styles.borderLeftColor }
                                ];
                                backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
                                if (!(hasBackground || styles.boxShadow.length)) return [3 /*break*/, 2];
                                this.ctx.save();
                                this.path(backgroundPaintingArea);
                                this.ctx.clip();
                                if (!isTransparent(styles.backgroundColor)) {
                                    this.ctx.fillStyle = asString(styles.backgroundColor);
                                    this.ctx.fill();
                                }
                                return [4 /*yield*/, this.renderBackgroundImage(paint.container)];
                            case 1:
                                _a.sent();
                                this.ctx.restore();
                                styles.boxShadow
                                    .slice(0)
                                    .reverse()
                                    .forEach(function (shadow) {
                                    _this.ctx.save();
                                    var borderBoxArea = calculateBorderBoxPath(paint.curves);
                                    var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                                    var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                                    if (shadow.inset) {
                                        _this.path(borderBoxArea);
                                        _this.ctx.clip();
                                        _this.mask(shadowPaintingArea);
                                    }
                                    else {
                                        _this.mask(borderBoxArea);
                                        _this.ctx.clip();
                                        _this.path(shadowPaintingArea);
                                    }
                                    _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                                    _this.ctx.shadowOffsetY = shadow.offsetY.number;
                                    _this.ctx.shadowColor = asString(shadow.color);
                                    _this.ctx.shadowBlur = shadow.blur.number;
                                    _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : 'rgba(0,0,0,1)';
                                    _this.ctx.fill();
                                    _this.ctx.restore();
                                });
                                _a.label = 2;
                            case 2:
                                side = 0;
                                _i = 0, borders_1 = borders;
                                _a.label = 3;
                            case 3:
                                if (!(_i < borders_1.length)) return [3 /*break*/, 7];
                                border = borders_1[_i];
                                if (!(border.style !== BORDER_STYLE.NONE && !isTransparent(border.color))) return [3 /*break*/, 5];
                                return [4 /*yield*/, this.renderBorder(border.color, side, paint.curves)];
                            case 4:
                                _a.sent();
                                _a.label = 5;
                            case 5:
                                side++;
                                _a.label = 6;
                            case 6:
                                _i++;
                                return [3 /*break*/, 3];
                            case 7: return [2 /*return*/];
                        }
                    });
                });
            };
            CanvasRenderer.prototype.render = function (element) {
                return __awaiter(this, void 0, void 0, function () {
                    var stack;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (this.options.backgroundColor) {
                                    this.ctx.fillStyle = asString(this.options.backgroundColor);
                                    this.ctx.fillRect(this.options.x - this.options.scrollX, this.options.y - this.options.scrollY, this.options.width, this.options.height);
                                }
                                stack = parseStackingContexts(element);
                                return [4 /*yield*/, this.renderStack(stack)];
                            case 1:
                                _a.sent();
                                this.applyEffects([], 2 /* BACKGROUND_BORDERS */);
                                return [2 /*return*/, this.canvas];
                        }
                    });
                });
            };
            return CanvasRenderer;
        }());
        var isTextInputElement = function (container) {
            if (container instanceof TextareaElementContainer) {
                return true;
            }
            else if (container instanceof SelectElementContainer) {
                return true;
            }
            else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
                return true;
            }
            return false;
        };
        var calculateBackgroundCurvedPaintingArea = function (clip, curves) {
            switch (clip) {
                case BACKGROUND_CLIP.BORDER_BOX:
                    return calculateBorderBoxPath(curves);
                case BACKGROUND_CLIP.CONTENT_BOX:
                    return calculateContentBoxPath(curves);
                case BACKGROUND_CLIP.PADDING_BOX:
                default:
                    return calculatePaddingBoxPath(curves);
            }
        };
        var canvasTextAlign = function (textAlign) {
            switch (textAlign) {
                case TEXT_ALIGN.CENTER:
                    return 'center';
                case TEXT_ALIGN.RIGHT:
                    return 'right';
                case TEXT_ALIGN.LEFT:
                default:
                    return 'left';
            }
        };

        var ForeignObjectRenderer = /** @class */ (function () {
            function ForeignObjectRenderer(options) {
                this.canvas = options.canvas ? options.canvas : document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.options = options;
                this.canvas.width = Math.floor(options.width * options.scale);
                this.canvas.height = Math.floor(options.height * options.scale);
                this.canvas.style.width = options.width + "px";
                this.canvas.style.height = options.height + "px";
                this.ctx.scale(this.options.scale, this.options.scale);
                this.ctx.translate(-options.x + options.scrollX, -options.y + options.scrollY);
                Logger.getInstance(options.id).debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
            }
            ForeignObjectRenderer.prototype.render = function (element) {
                return __awaiter(this, void 0, void 0, function () {
                    var svg, img;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                svg = createForeignObjectSVG(Math.max(this.options.windowWidth, this.options.width) * this.options.scale, Math.max(this.options.windowHeight, this.options.height) * this.options.scale, this.options.scrollX * this.options.scale, this.options.scrollY * this.options.scale, element);
                                return [4 /*yield*/, loadSerializedSVG$1(svg)];
                            case 1:
                                img = _a.sent();
                                if (this.options.backgroundColor) {
                                    this.ctx.fillStyle = asString(this.options.backgroundColor);
                                    this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
                                }
                                this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
                                return [2 /*return*/, this.canvas];
                        }
                    });
                });
            };
            return ForeignObjectRenderer;
        }());
        var loadSerializedSVG$1 = function (svg) {
            return new Promise(function (resolve, reject) {
                var img = new Image();
                img.onload = function () {
                    resolve(img);
                };
                img.onerror = reject;
                img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
            });
        };

        var _this = undefined;
        var parseColor$1 = function (value) { return color.parse(Parser.create(value).parseComponentValue()); };
        var html2canvas = function (element, options) {
            if (options === void 0) { options = {}; }
            return renderElement(element, options);
        };
        if (typeof window !== 'undefined') {
            CacheStorage.setContext(window);
        }
        var renderElement = function (element, opts) { return __awaiter(_this, void 0, void 0, function () {
            var ownerDocument, defaultView, instanceName, _a, width, height, left, top, defaultResourceOptions, resourceOptions, defaultOptions, options, windowBounds, documentCloner, clonedElement, container, documentBackgroundColor, bodyBackgroundColor, bgColor, defaultBackgroundColor, backgroundColor, renderOptions, canvas, renderer, root, renderer;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        ownerDocument = element.ownerDocument;
                        if (!ownerDocument) {
                            throw new Error("Element is not attached to a Document");
                        }
                        defaultView = ownerDocument.defaultView;
                        if (!defaultView) {
                            throw new Error("Document is not attached to a Window");
                        }
                        instanceName = (Math.round(Math.random() * 1000) + Date.now()).toString(16);
                        _a = isBodyElement(element) || isHTMLElement(element) ? parseDocumentSize(ownerDocument) : parseBounds(element), width = _a.width, height = _a.height, left = _a.left, top = _a.top;
                        defaultResourceOptions = {
                            allowTaint: false,
                            imageTimeout: 15000,
                            proxy: undefined,
                            useCORS: false
                        };
                        resourceOptions = __assign({}, defaultResourceOptions, opts);
                        defaultOptions = {
                            backgroundColor: '#ffffff',
                            cache: opts.cache ? opts.cache : CacheStorage.create(instanceName, resourceOptions),
                            logging: true,
                            removeContainer: true,
                            foreignObjectRendering: false,
                            scale: defaultView.devicePixelRatio || 1,
                            windowWidth: defaultView.innerWidth,
                            windowHeight: defaultView.innerHeight,
                            scrollX: defaultView.pageXOffset,
                            scrollY: defaultView.pageYOffset,
                            x: left,
                            y: top,
                            width: Math.ceil(width),
                            height: Math.ceil(height),
                            id: instanceName
                        };
                        options = __assign({}, defaultOptions, resourceOptions, opts);
                        windowBounds = new Bounds(options.scrollX, options.scrollY, options.windowWidth, options.windowHeight);
                        Logger.create({ id: instanceName, enabled: options.logging });
                        Logger.getInstance(instanceName).debug("Starting document clone");
                        documentCloner = new DocumentCloner(element, {
                            id: instanceName,
                            onclone: options.onclone,
                            ignoreElements: options.ignoreElements,
                            inlineImages: options.foreignObjectRendering,
                            copyStyles: options.foreignObjectRendering
                        });
                        clonedElement = documentCloner.clonedReferenceElement;
                        if (!clonedElement) {
                            return [2 /*return*/, Promise.reject("Unable to find element in cloned iframe")];
                        }
                        return [4 /*yield*/, documentCloner.toIFrame(ownerDocument, windowBounds)];
                    case 1:
                        container = _b.sent();
                        documentBackgroundColor = ownerDocument.documentElement
                            ? parseColor$1(getComputedStyle(ownerDocument.documentElement).backgroundColor)
                            : COLORS.TRANSPARENT;
                        bodyBackgroundColor = ownerDocument.body
                            ? parseColor$1(getComputedStyle(ownerDocument.body).backgroundColor)
                            : COLORS.TRANSPARENT;
                        bgColor = opts.backgroundColor;
                        defaultBackgroundColor = typeof bgColor === 'string' ? parseColor$1(bgColor) : bgColor === null ? COLORS.TRANSPARENT : 0xffffffff;
                        backgroundColor = element === ownerDocument.documentElement
                            ? isTransparent(documentBackgroundColor)
                                ? isTransparent(bodyBackgroundColor)
                                    ? defaultBackgroundColor
                                    : bodyBackgroundColor
                                : documentBackgroundColor
                            : defaultBackgroundColor;
                        renderOptions = {
                            id: instanceName,
                            cache: options.cache,
                            canvas: options.canvas,
                            backgroundColor: backgroundColor,
                            scale: options.scale,
                            x: options.x,
                            y: options.y,
                            scrollX: options.scrollX,
                            scrollY: options.scrollY,
                            width: options.width,
                            height: options.height,
                            windowWidth: options.windowWidth,
                            windowHeight: options.windowHeight
                        };
                        if (!options.foreignObjectRendering) return [3 /*break*/, 3];
                        Logger.getInstance(instanceName).debug("Document cloned, using foreign object rendering");
                        renderer = new ForeignObjectRenderer(renderOptions);
                        return [4 /*yield*/, renderer.render(clonedElement)];
                    case 2:
                        canvas = _b.sent();
                        return [3 /*break*/, 5];
                    case 3:
                        Logger.getInstance(instanceName).debug("Document cloned, using computed rendering");
                        CacheStorage.attachInstance(options.cache);
                        Logger.getInstance(instanceName).debug("Starting DOM parsing");
                        root = parseTree(clonedElement);
                        CacheStorage.detachInstance();
                        if (backgroundColor === root.styles.backgroundColor) {
                            root.styles.backgroundColor = COLORS.TRANSPARENT;
                        }
                        Logger.getInstance(instanceName).debug("Starting renderer");
                        renderer = new CanvasRenderer(renderOptions);
                        return [4 /*yield*/, renderer.render(root)];
                    case 4:
                        canvas = _b.sent();
                        _b.label = 5;
                    case 5:
                        if (options.removeContainer === true) {
                            if (!DocumentCloner.destroy(container)) {
                                Logger.getInstance(instanceName).error("Cannot detach cloned iframe as it is not in the DOM anymore");
                            }
                        }
                        Logger.getInstance(instanceName).debug("Finished rendering");
                        Logger.destroy(instanceName);
                        CacheStorage.destroy(instanceName);
                        return [2 /*return*/, canvas];
                }
            });
        }); };

        return html2canvas;

    }));

    });

    /* Tabulator v4.9.3 (c) Oliver Folkerd */

    // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

    if (!Array.prototype.findIndex) {

    	Object.defineProperty(Array.prototype, 'findIndex', {

    		value: function value(predicate) {

    			// 1. Let O be ? ToObject(this value).

    			if (this == null) {

    				throw new TypeError('"this" is null or not defined');
    			}

    			var o = Object(this);

    			// 2. Let len be ? ToLength(? Get(O, "length")).

    			var len = o.length >>> 0;

    			// 3. If IsCallable(predicate) is false, throw a TypeError exception.

    			if (typeof predicate !== 'function') {

    				throw new TypeError('predicate must be a function');
    			}

    			// 4. If thisArg was supplied, let T be thisArg; else let T be undefined.

    			var thisArg = arguments[1];

    			// 5. Let k be 0.

    			var k = 0;

    			// 6. Repeat, while k < len

    			while (k < len) {

    				// a. Let Pk be ! ToString(k).

    				// b. Let kValue be ? Get(O, Pk).

    				// c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).

    				// d. If testResult is true, return k.

    				var kValue = o[k];

    				if (predicate.call(thisArg, kValue, k, o)) {

    					return k;
    				}

    				// e. Increase k by 1.

    				k++;
    			}

    			// 7. Return -1.

    			return -1;
    		}

    	});
    }

    // https://tc39.github.io/ecma262/#sec-array.prototype.find

    if (!Array.prototype.find) {

    	Object.defineProperty(Array.prototype, 'find', {

    		value: function value(predicate) {

    			// 1. Let O be ? ToObject(this value).

    			if (this == null) {

    				throw new TypeError('"this" is null or not defined');
    			}

    			var o = Object(this);

    			// 2. Let len be ? ToLength(? Get(O, "length")).

    			var len = o.length >>> 0;

    			// 3. If IsCallable(predicate) is false, throw a TypeError exception.

    			if (typeof predicate !== 'function') {

    				throw new TypeError('predicate must be a function');
    			}

    			// 4. If thisArg was supplied, let T be thisArg; else let T be undefined.

    			var thisArg = arguments[1];

    			// 5. Let k be 0.

    			var k = 0;

    			// 6. Repeat, while k < len

    			while (k < len) {

    				// a. Let Pk be ! ToString(k).

    				// b. Let kValue be ? Get(O, Pk).

    				// c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).

    				// d. If testResult is true, return kValue.

    				var kValue = o[k];

    				if (predicate.call(thisArg, kValue, k, o)) {

    					return kValue;
    				}

    				// e. Increase k by 1.

    				k++;
    			}

    			// 7. Return undefined.

    			return undefined;
    		}

    	});
    }

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes#Polyfill

    if (!String.prototype.includes) {

    	String.prototype.includes = function (search, start) {

    		if (search instanceof RegExp) {

    			throw TypeError('first argument must not be a RegExp');
    		}

    		if (start === undefined) {
    			start = 0;
    		}

    		return this.indexOf(search, start) !== -1;
    	};
    }

    // https://tc39.github.io/ecma262/#sec-array.prototype.includes

    if (!Array.prototype.includes) {

    	Object.defineProperty(Array.prototype, 'includes', {

    		value: function value(searchElement, fromIndex) {

    			if (this == null) {

    				throw new TypeError('"this" is null or not defined');
    			}

    			// 1. Let O be ? ToObject(this value).

    			var o = Object(this);

    			// 2. Let len be ? ToLength(? Get(O, "length")).

    			var len = o.length >>> 0;

    			// 3. If len is 0, return false.

    			if (len === 0) {

    				return false;
    			}

    			// 4. Let n be ? ToInteger(fromIndex).

    			//    (If fromIndex is undefined, this step produces the value 0.)

    			var n = fromIndex | 0;

    			// 5. If n ≥ 0, then

    			//  a. Let k be n.

    			// 6. Else n < 0,

    			//  a. Let k be len + n.

    			//  b. If k < 0, let k be 0.

    			var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

    			function sameValueZero(x, y) {

    				return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);
    			}

    			// 7. Repeat, while k < len

    			while (k < len) {

    				// a. Let elementK be the result of ? Get(O, ! ToString(k)).

    				// b. If SameValueZero(searchElement, elementK) is true, return true.

    				if (sameValueZero(o[k], searchElement)) {

    					return true;
    				}

    				// c. Increase k by 1.

    				k++;
    			}

    			// 8. Return false

    			return false;
    		}

    	});
    }

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill

    if (typeof Object.assign !== 'function') {

    	// Must be writable: true, enumerable: false, configurable: true

    	Object.defineProperty(Object, "assign", {

    		value: function assign(target, varArgs) {

    			if (target === null || target === undefined) {

    				throw new TypeError('Cannot convert undefined or null to object');
    			}

    			var to = Object(target);

    			for (var index = 1; index < arguments.length; index++) {

    				var nextSource = arguments[index];

    				if (nextSource !== null && nextSource !== undefined) {

    					for (var nextKey in nextSource) {

    						// Avoid bugs when hasOwnProperty is shadowed

    						if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {

    							to[nextKey] = nextSource[nextKey];
    						}
    					}
    				}
    			}

    			return to;
    		},

    		writable: true,

    		configurable: true

    	});
    }

    var ColumnManager = function ColumnManager(table) {

    	this.table = table; //hold parent table

    	this.blockHozScrollEvent = false;

    	this.headersElement = this.createHeadersElement();

    	this.element = this.createHeaderElement(); //containing element

    	this.rowManager = null; //hold row manager object

    	this.columns = []; // column definition object

    	this.columnsByIndex = []; //columns by index

    	this.columnsByField = {}; //columns by field

    	this.scrollLeft = 0;

    	this.element.insertBefore(this.headersElement, this.element.firstChild);
    };

    ////////////// Setup Functions /////////////////


    ColumnManager.prototype.createHeadersElement = function () {

    	var el = document.createElement("div");

    	el.classList.add("tabulator-headers");

    	return el;
    };

    ColumnManager.prototype.createHeaderElement = function () {

    	var el = document.createElement("div");

    	el.classList.add("tabulator-header");

    	if (!this.table.options.headerVisible) {

    		el.classList.add("tabulator-header-hidden");
    	}

    	return el;
    };

    ColumnManager.prototype.initialize = function () {

    	//scroll body along with header

    	// self.element.addEventListener("scroll", function(e){

    	// 	if(!self.blockHozScrollEvent){

    	// 		self.table.rowManager.scrollHorizontal(self.element.scrollLeft);

    	// 	}

    	// });
    };

    //link to row manager

    ColumnManager.prototype.setRowManager = function (manager) {

    	this.rowManager = manager;
    };

    //return containing element

    ColumnManager.prototype.getElement = function () {

    	return this.element;
    };

    //return header containing element

    ColumnManager.prototype.getHeadersElement = function () {

    	return this.headersElement;
    };

    // ColumnManager.prototype.tempScrollBlock = function(){

    // 	clearTimeout(this.blockHozScrollEvent);

    // 	this.blockHozScrollEvent = setTimeout(() => {this.blockHozScrollEvent = false;}, 50);

    // }


    //scroll horizontally to match table body

    ColumnManager.prototype.scrollHorizontal = function (left) {

    	var hozAdjust = 0,
    	    scrollWidth = this.element.scrollWidth - this.table.element.clientWidth;

    	// this.tempScrollBlock();

    	this.element.scrollLeft = left;

    	//adjust for vertical scrollbar moving table when present

    	if (left > scrollWidth) {

    		hozAdjust = left - scrollWidth;

    		this.element.style.marginLeft = -hozAdjust + "px";
    	} else {

    		this.element.style.marginLeft = 0;
    	}

    	//keep frozen columns fixed in position

    	//this._calcFrozenColumnsPos(hozAdjust + 3);


    	this.scrollLeft = left;

    	if (this.table.modExists("frozenColumns")) {

    		this.table.modules.frozenColumns.scrollHorizontal();
    	}
    };

    ///////////// Column Setup Functions /////////////


    ColumnManager.prototype.generateColumnsFromRowData = function (data) {

    	var cols = [],
    	    definitions = this.table.options.autoColumnsDefinitions,
    	    row,
    	    sorter;

    	if (data && data.length) {

    		row = data[0];

    		for (var key in row) {

    			var col = {

    				field: key,

    				title: key

    			};

    			var value = row[key];

    			switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {

    				case "undefined":

    					sorter = "string";

    					break;

    				case "boolean":

    					sorter = "boolean";

    					break;

    				case "object":

    					if (Array.isArray(value)) {

    						sorter = "array";
    					} else {

    						sorter = "string";
    					}

    					break;

    				default:

    					if (!isNaN(value) && value !== "") {

    						sorter = "number";
    					} else {

    						if (value.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i)) {

    							sorter = "alphanum";
    						} else {

    							sorter = "string";
    						}
    					}

    					break;

    			}

    			col.sorter = sorter;

    			cols.push(col);
    		}

    		if (definitions) {

    			switch (typeof definitions === 'undefined' ? 'undefined' : _typeof(definitions)) {

    				case "function":

    					this.table.options.columns = definitions.call(this.table, cols);

    					break;

    				case "object":

    					if (Array.isArray(definitions)) {

    						cols.forEach(function (col) {

    							var match = definitions.find(function (def) {

    								return def.field === col.field;
    							});

    							if (match) {

    								Object.assign(col, match);
    							}
    						});
    					} else {

    						cols.forEach(function (col) {

    							if (definitions[col.field]) {

    								Object.assign(col, definitions[col.field]);
    							}
    						});
    					}

    					this.table.options.columns = cols;

    					break;

    			}
    		} else {

    			this.table.options.columns = cols;
    		}

    		this.setColumns(this.table.options.columns);
    	}
    };

    ColumnManager.prototype.setColumns = function (cols, row) {

    	var self = this;

    	while (self.headersElement.firstChild) {
    		self.headersElement.removeChild(self.headersElement.firstChild);
    	}self.columns = [];

    	self.columnsByIndex = [];

    	self.columnsByField = {};

    	//reset frozen columns

    	if (self.table.modExists("frozenColumns")) {

    		self.table.modules.frozenColumns.reset();
    	}

    	cols.forEach(function (def, i) {

    		self._addColumn(def);
    	});

    	self._reIndexColumns();

    	if (self.table.options.responsiveLayout && self.table.modExists("responsiveLayout", true)) {

    		self.table.modules.responsiveLayout.initialize();
    	}

    	if (this.table.options.virtualDomHoz) {

    		this.table.vdomHoz.reinitialize(false, true);
    	}

    	self.redraw(true);
    };

    ColumnManager.prototype._addColumn = function (definition, before, nextToColumn) {

    	var column = new Column(definition, this),
    	    colEl = column.getElement(),
    	    index = nextToColumn ? this.findColumnIndex(nextToColumn) : nextToColumn;

    	if (nextToColumn && index > -1) {

    		var parentIndex = this.columns.indexOf(nextToColumn.getTopColumn());

    		var nextEl = nextToColumn.getElement();

    		if (before) {

    			this.columns.splice(parentIndex, 0, column);

    			nextEl.parentNode.insertBefore(colEl, nextEl);
    		} else {

    			this.columns.splice(parentIndex + 1, 0, column);

    			nextEl.parentNode.insertBefore(colEl, nextEl.nextSibling);
    		}
    	} else {

    		if (before) {

    			this.columns.unshift(column);

    			this.headersElement.insertBefore(column.getElement(), this.headersElement.firstChild);
    		} else {

    			this.columns.push(column);

    			this.headersElement.appendChild(column.getElement());
    		}

    		column.columnRendered();
    	}

    	return column;
    };

    ColumnManager.prototype.registerColumnField = function (col) {

    	if (col.definition.field) {

    		this.columnsByField[col.definition.field] = col;
    	}
    };

    ColumnManager.prototype.registerColumnPosition = function (col) {

    	this.columnsByIndex.push(col);
    };

    ColumnManager.prototype._reIndexColumns = function () {

    	this.columnsByIndex = [];

    	this.columns.forEach(function (column) {

    		column.reRegisterPosition();
    	});
    };

    //ensure column headers take up the correct amount of space in column groups

    ColumnManager.prototype._verticalAlignHeaders = function () {

    	var self = this,
    	    minHeight = 0;

    	self.columns.forEach(function (column) {

    		var height;

    		column.clearVerticalAlign();

    		height = column.getHeight();

    		if (height > minHeight) {

    			minHeight = height;
    		}
    	});

    	self.columns.forEach(function (column) {

    		column.verticalAlign(self.table.options.columnHeaderVertAlign, minHeight);
    	});

    	self.rowManager.adjustTableSize();
    };

    //////////////// Column Details /////////////////


    ColumnManager.prototype.findColumn = function (subject) {

    	var self = this;

    	if ((typeof subject === 'undefined' ? 'undefined' : _typeof(subject)) == "object") {

    		if (subject instanceof Column) {

    			//subject is column element

    			return subject;
    		} else if (subject instanceof ColumnComponent) {

    			//subject is public column component

    			return subject._getSelf() || false;
    		} else if (typeof HTMLElement !== "undefined" && subject instanceof HTMLElement) {

    			//subject is a HTML element of the column header

    			var match = self.columns.find(function (column) {

    				return column.element === subject;
    			});

    			return match || false;
    		}
    	} else {

    		//subject should be treated as the field name of the column

    		return this.columnsByField[subject] || false;
    	}

    	//catch all for any other type of input


    	return false;
    };

    ColumnManager.prototype.getColumnByField = function (field) {

    	return this.columnsByField[field];
    };

    ColumnManager.prototype.getColumnsByFieldRoot = function (root) {
    	var _this = this;

    	var matches = [];

    	Object.keys(this.columnsByField).forEach(function (field) {

    		var fieldRoot = field.split(".")[0];

    		if (fieldRoot === root) {

    			matches.push(_this.columnsByField[field]);
    		}
    	});

    	return matches;
    };

    ColumnManager.prototype.getColumnByIndex = function (index) {

    	return this.columnsByIndex[index];
    };

    ColumnManager.prototype.getFirstVisibileColumn = function (index) {

    	var index = this.columnsByIndex.findIndex(function (col) {

    		return col.visible;
    	});

    	return index > -1 ? this.columnsByIndex[index] : false;
    };

    ColumnManager.prototype.getColumns = function () {

    	return this.columns;
    };

    ColumnManager.prototype.findColumnIndex = function (column) {

    	return this.columnsByIndex.findIndex(function (col) {

    		return column === col;
    	});
    };

    //return all columns that are not groups

    ColumnManager.prototype.getRealColumns = function () {

    	return this.columnsByIndex;
    };

    //travers across columns and call action

    ColumnManager.prototype.traverse = function (callback) {

    	var self = this;

    	self.columnsByIndex.forEach(function (column, i) {

    		callback(column, i);
    	});
    };

    //get defintions of actual columns

    ColumnManager.prototype.getDefinitions = function (active) {

    	var self = this,
    	    output = [];

    	self.columnsByIndex.forEach(function (column) {

    		if (!active || active && column.visible) {

    			output.push(column.getDefinition());
    		}
    	});

    	return output;
    };

    //get full nested definition tree

    ColumnManager.prototype.getDefinitionTree = function () {

    	var self = this,
    	    output = [];

    	self.columns.forEach(function (column) {

    		output.push(column.getDefinition(true));
    	});

    	return output;
    };

    ColumnManager.prototype.getComponents = function (structured) {

    	var self = this,
    	    output = [],
    	    columns = structured ? self.columns : self.columnsByIndex;

    	columns.forEach(function (column) {

    		output.push(column.getComponent());
    	});

    	return output;
    };

    ColumnManager.prototype.getWidth = function () {

    	var width = 0;

    	this.columnsByIndex.forEach(function (column) {

    		if (column.visible) {

    			width += column.getWidth();
    		}
    	});

    	return width;
    };

    ColumnManager.prototype.moveColumn = function (from, to, after) {

    	this.moveColumnActual(from, to, after);

    	if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {

    		this.table.modules.responsiveLayout.initialize();
    	}

    	if (this.table.modExists("columnCalcs")) {

    		this.table.modules.columnCalcs.recalc(this.table.rowManager.activeRows);
    	}

    	to.element.parentNode.insertBefore(from.element, to.element);

    	if (after) {

    		to.element.parentNode.insertBefore(to.element, from.element);
    	}

    	this._verticalAlignHeaders();

    	this.table.rowManager.reinitialize();
    };

    ColumnManager.prototype.moveColumnActual = function (from, to, after) {

    	if (from.parent.isGroup) {

    		this._moveColumnInArray(from.parent.columns, from, to, after);
    	} else {

    		this._moveColumnInArray(this.columns, from, to, after);
    	}

    	this._moveColumnInArray(this.columnsByIndex, from, to, after, true);

    	if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {

    		this.table.modules.responsiveLayout.initialize();
    	}

    	if (this.table.options.virtualDomHoz) {

    		this.table.vdomHoz.reinitialize(true);
    	}

    	if (this.table.options.columnMoved) {

    		this.table.options.columnMoved.call(this.table, from.getComponent(), this.table.columnManager.getComponents());
    	}

    	if (this.table.options.persistence && this.table.modExists("persistence", true) && this.table.modules.persistence.config.columns) {

    		this.table.modules.persistence.save("columns");
    	}
    };

    ColumnManager.prototype._moveColumnInArray = function (columns, from, to, after, updateRows) {
    	var _this2 = this;

    	var fromIndex = columns.indexOf(from),
    	    toIndex,
    	    rows = [];

    	if (fromIndex > -1) {

    		columns.splice(fromIndex, 1);

    		toIndex = columns.indexOf(to);

    		if (toIndex > -1) {

    			if (after) {

    				toIndex = toIndex + 1;
    			}
    		} else {

    			toIndex = fromIndex;
    		}

    		columns.splice(toIndex, 0, from);

    		if (updateRows) {

    			if (this.table.options.dataTree && this.table.modExists("dataTree", true)) {

    				this.table.rowManager.rows.forEach(function (row) {

    					rows = rows.concat(_this2.table.modules.dataTree.getTreeChildren(row, false, true));
    				});
    			}

    			rows = rows.concat(this.table.rowManager.rows);

    			rows.forEach(function (row) {

    				if (row.cells.length) {

    					var cell = row.cells.splice(fromIndex, 1)[0];

    					row.cells.splice(toIndex, 0, cell);
    				}
    			});
    		}
    	}
    };

    ColumnManager.prototype.scrollToColumn = function (column, position, ifVisible) {
    	var _this3 = this;

    	var left = 0,
    	    offset = 0,
    	    adjust = 0,
    	    colEl = column.getElement();

    	return new Promise(function (resolve, reject) {

    		if (typeof position === "undefined") {

    			position = _this3.table.options.scrollToColumnPosition;
    		}

    		if (typeof ifVisible === "undefined") {

    			ifVisible = _this3.table.options.scrollToColumnIfVisible;
    		}

    		if (column.visible) {

    			//align to correct position

    			switch (position) {

    				case "middle":

    				case "center":

    					adjust = -_this3.element.clientWidth / 2;

    					break;

    				case "right":

    					adjust = colEl.clientWidth - _this3.headersElement.clientWidth;

    					break;

    			}

    			//check column visibility

    			if (!ifVisible) {

    				offset = colEl.offsetLeft;

    				if (offset > 0 && offset + colEl.offsetWidth < _this3.element.clientWidth) {

    					return false;
    				}
    			}

    			//calculate scroll position

    			left = colEl.offsetLeft + adjust;

    			left = Math.max(Math.min(left, _this3.table.rowManager.element.scrollWidth - _this3.table.rowManager.element.clientWidth), 0);

    			_this3.table.rowManager.scrollHorizontal(left);

    			_this3.scrollHorizontal(left);

    			resolve();
    		} else {

    			console.warn("Scroll Error - Column not visible");

    			reject("Scroll Error - Column not visible");
    		}
    	});
    };

    //////////////// Cell Management /////////////////


    ColumnManager.prototype.generateCells = function (row) {

    	var self = this;

    	var cells = [];

    	self.columnsByIndex.forEach(function (column) {

    		cells.push(column.generateCell(row));
    	});

    	return cells;
    };

    //////////////// Column Management /////////////////


    ColumnManager.prototype.getFlexBaseWidth = function () {

    	var self = this,
    	    totalWidth = self.table.element.clientWidth,
    	    //table element width

    	fixedWidth = 0;

    	//adjust for vertical scrollbar if present

    	if (self.rowManager.element.scrollHeight > self.rowManager.element.clientHeight) {

    		totalWidth -= self.rowManager.element.offsetWidth - self.rowManager.element.clientWidth;
    	}

    	this.columnsByIndex.forEach(function (column) {

    		var width, minWidth, colWidth;

    		if (column.visible) {

    			width = column.definition.width || 0;

    			minWidth = typeof column.minWidth == "undefined" ? self.table.options.columnMinWidth : parseInt(column.minWidth);

    			if (typeof width == "string") {

    				if (width.indexOf("%") > -1) {

    					colWidth = totalWidth / 100 * parseInt(width);
    				} else {

    					colWidth = parseInt(width);
    				}
    			} else {

    				colWidth = width;
    			}

    			fixedWidth += colWidth > minWidth ? colWidth : minWidth;
    		}
    	});

    	return fixedWidth;
    };

    ColumnManager.prototype.addColumn = function (definition, before, nextToColumn) {
    	var _this4 = this;

    	return new Promise(function (resolve, reject) {

    		var column = _this4._addColumn(definition, before, nextToColumn);

    		_this4._reIndexColumns();

    		if (_this4.table.options.responsiveLayout && _this4.table.modExists("responsiveLayout", true)) {

    			_this4.table.modules.responsiveLayout.initialize();
    		}

    		if (_this4.table.modExists("columnCalcs")) {

    			_this4.table.modules.columnCalcs.recalc(_this4.table.rowManager.activeRows);
    		}

    		_this4.redraw(true);

    		if (_this4.table.modules.layout.getMode() != "fitColumns") {

    			column.reinitializeWidth();
    		}

    		_this4._verticalAlignHeaders();

    		_this4.table.rowManager.reinitialize();

    		if (_this4.table.options.virtualDomHoz) {

    			_this4.table.vdomHoz.reinitialize();
    		}

    		resolve(column);
    	});
    };

    //remove column from system

    ColumnManager.prototype.deregisterColumn = function (column) {

    	var field = column.getField(),
    	    index;

    	//remove from field list

    	if (field) {

    		delete this.columnsByField[field];
    	}

    	//remove from index list

    	index = this.columnsByIndex.indexOf(column);

    	if (index > -1) {

    		this.columnsByIndex.splice(index, 1);
    	}

    	//remove from column list

    	index = this.columns.indexOf(column);

    	if (index > -1) {

    		this.columns.splice(index, 1);
    	}

    	if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {

    		this.table.modules.responsiveLayout.initialize();
    	}

    	this._verticalAlignHeaders();

    	this.redraw();
    };

    //redraw columns

    ColumnManager.prototype.redraw = function (force) {

    	if (force) {

    		if (Tabulator.prototype.helpers.elVisible(this.element)) {

    			this._verticalAlignHeaders();
    		}

    		this.table.rowManager.resetScroll();

    		this.table.rowManager.reinitialize();
    	}

    	if (["fitColumns", "fitDataStretch"].indexOf(this.table.modules.layout.getMode()) > -1) {

    		this.table.modules.layout.layout();
    	} else {

    		if (force) {

    			this.table.modules.layout.layout();
    		} else {

    			if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {

    				this.table.modules.responsiveLayout.update();
    			}
    		}
    	}

    	if (this.table.modExists("frozenColumns")) {

    		this.table.modules.frozenColumns.layout();
    	}

    	if (this.table.modExists("columnCalcs")) {

    		this.table.modules.columnCalcs.recalc(this.table.rowManager.activeRows);
    	}

    	if (force) {

    		if (this.table.options.persistence && this.table.modExists("persistence", true) && this.table.modules.persistence.config.columns) {

    			this.table.modules.persistence.save("columns");
    		}

    		if (this.table.modExists("columnCalcs")) {

    			this.table.modules.columnCalcs.redraw();
    		}
    	}

    	this.table.footerManager.redraw();
    };

    //public column object
    var ColumnComponent = function ColumnComponent(column) {
    	this._column = column;
    	this.type = "ColumnComponent";
    };

    ColumnComponent.prototype.getElement = function () {
    	return this._column.getElement();
    };

    ColumnComponent.prototype.getDefinition = function () {
    	return this._column.getDefinition();
    };

    ColumnComponent.prototype.getField = function () {
    	return this._column.getField();
    };

    ColumnComponent.prototype.getCells = function () {
    	var cells = [];

    	this._column.cells.forEach(function (cell) {
    		cells.push(cell.getComponent());
    	});

    	return cells;
    };

    ColumnComponent.prototype.getVisibility = function () {
    	console.warn("getVisibility function is deprecated, you should now use the isVisible function");
    	return this._column.visible;
    };

    ColumnComponent.prototype.isVisible = function () {
    	return this._column.visible;
    };

    ColumnComponent.prototype.show = function () {
    	if (this._column.isGroup) {
    		this._column.columns.forEach(function (column) {
    			column.show();
    		});
    	} else {
    		this._column.show();
    	}
    };

    ColumnComponent.prototype.hide = function () {
    	if (this._column.isGroup) {
    		this._column.columns.forEach(function (column) {
    			column.hide();
    		});
    	} else {
    		this._column.hide();
    	}
    };

    ColumnComponent.prototype.toggle = function () {
    	if (this._column.visible) {
    		this.hide();
    	} else {
    		this.show();
    	}
    };

    ColumnComponent.prototype.delete = function () {
    	return this._column.delete();
    };

    ColumnComponent.prototype.getSubColumns = function () {
    	var output = [];

    	if (this._column.columns.length) {
    		this._column.columns.forEach(function (column) {
    			output.push(column.getComponent());
    		});
    	}

    	return output;
    };

    ColumnComponent.prototype.getParentColumn = function () {
    	return this._column.parent instanceof Column ? this._column.parent.getComponent() : false;
    };

    ColumnComponent.prototype._getSelf = function () {
    	return this._column;
    };

    ColumnComponent.prototype.scrollTo = function () {
    	return this._column.table.columnManager.scrollToColumn(this._column);
    };

    ColumnComponent.prototype.getTable = function () {
    	return this._column.table;
    };

    ColumnComponent.prototype.headerFilterFocus = function () {
    	if (this._column.table.modExists("filter", true)) {
    		this._column.table.modules.filter.setHeaderFilterFocus(this._column);
    	}
    };

    ColumnComponent.prototype.reloadHeaderFilter = function () {
    	if (this._column.table.modExists("filter", true)) {
    		this._column.table.modules.filter.reloadHeaderFilter(this._column);
    	}
    };

    ColumnComponent.prototype.getHeaderFilterValue = function () {
    	if (this._column.table.modExists("filter", true)) {
    		return this._column.table.modules.filter.getHeaderFilterValue(this._column);
    	}
    };

    ColumnComponent.prototype.setHeaderFilterValue = function (value) {
    	if (this._column.table.modExists("filter", true)) {
    		this._column.table.modules.filter.setHeaderFilterValue(this._column, value);
    	}
    };

    ColumnComponent.prototype.move = function (to, after) {
    	var toColumn = this._column.table.columnManager.findColumn(to);

    	if (toColumn) {
    		this._column.table.columnManager.moveColumn(this._column, toColumn, after);
    	} else {
    		console.warn("Move Error - No matching column found:", toColumn);
    	}
    };

    ColumnComponent.prototype.getNextColumn = function () {
    	var nextCol = this._column.nextColumn();

    	return nextCol ? nextCol.getComponent() : false;
    };

    ColumnComponent.prototype.getPrevColumn = function () {
    	var prevCol = this._column.prevColumn();

    	return prevCol ? prevCol.getComponent() : false;
    };

    ColumnComponent.prototype.updateDefinition = function (updates) {
    	return this._column.updateDefinition(updates);
    };

    ColumnComponent.prototype.getWidth = function () {
    	return this._column.getWidth();
    };

    ColumnComponent.prototype.setWidth = function (width) {
    	var result;

    	if (width === true) {
    		result = this._column.reinitializeWidth(true);
    	} else {
    		result = this._column.setWidth(width);
    	}

    	if (this._column.table.options.virtualDomHoz) {
    		this._column.table.vdomHoz.reinitialize(true);
    	}

    	return result;
    };

    ColumnComponent.prototype.validate = function () {
    	return this._column.validate();
    };

    var Column = function Column(def, parent) {
    	var self = this;

    	this.table = parent.table;
    	this.definition = def; //column definition
    	this.parent = parent; //hold parent object
    	this.type = "column"; //type of element
    	this.columns = []; //child columns
    	this.cells = []; //cells bound to this column
    	this.element = this.createElement(); //column header element
    	this.contentElement = false;
    	this.titleHolderElement = false;
    	this.titleElement = false;
    	this.groupElement = this.createGroupElement(); //column group holder element
    	this.isGroup = false;
    	this.tooltip = false; //hold column tooltip
    	this.hozAlign = ""; //horizontal text alignment
    	this.vertAlign = ""; //vert text alignment

    	//multi dimensional filed handling
    	this.field = "";
    	this.fieldStructure = "";
    	this.getFieldValue = "";
    	this.setFieldValue = "";

    	this.titleFormatterRendered = false;

    	this.setField(this.definition.field);

    	if (this.table.options.invalidOptionWarnings) {
    		this.checkDefinition();
    	}

    	this.modules = {}; //hold module variables;

    	this.cellEvents = {
    		cellClick: false,
    		cellDblClick: false,
    		cellContext: false,
    		cellTap: false,
    		cellDblTap: false,
    		cellTapHold: false,
    		cellMouseEnter: false,
    		cellMouseLeave: false,
    		cellMouseOver: false,
    		cellMouseOut: false,
    		cellMouseMove: false
    	};

    	this.width = null; //column width
    	this.widthStyled = ""; //column width prestyled to improve render efficiency
    	this.maxWidth = null; //column maximum width
    	this.maxWidthStyled = ""; //column maximum prestyled to improve render efficiency
    	this.minWidth = null; //column minimum width
    	this.minWidthStyled = ""; //column minimum prestyled to improve render efficiency
    	this.widthFixed = false; //user has specified a width for this column

    	this.visible = true; //default visible state

    	this.component = null;

    	this._mapDepricatedFunctionality();

    	//initialize column
    	if (def.columns) {

    		this.isGroup = true;

    		def.columns.forEach(function (def, i) {
    			var newCol = new Column(def, self);
    			self.attachColumn(newCol);
    		});

    		self.checkColumnVisibility();
    	} else {
    		parent.registerColumnField(this);
    	}

    	if (def.rowHandle && this.table.options.movableRows !== false && this.table.modExists("moveRow")) {
    		this.table.modules.moveRow.setHandle(true);
    	}

    	this._buildHeader();

    	this.bindModuleColumns();
    };

    Column.prototype.createElement = function () {
    	var el = document.createElement("div");

    	el.classList.add("tabulator-col");
    	el.setAttribute("role", "columnheader");
    	el.setAttribute("aria-sort", "none");

    	return el;
    };

    Column.prototype.createGroupElement = function () {
    	var el = document.createElement("div");

    	el.classList.add("tabulator-col-group-cols");

    	return el;
    };

    Column.prototype.checkDefinition = function () {
    	var _this5 = this;

    	Object.keys(this.definition).forEach(function (key) {
    		if (_this5.defaultOptionList.indexOf(key) === -1) {
    			console.warn("Invalid column definition option in '" + (_this5.field || _this5.definition.title) + "' column:", key);
    		}
    	});
    };

    Column.prototype.setField = function (field) {
    	this.field = field;
    	this.fieldStructure = field ? this.table.options.nestedFieldSeparator ? field.split(this.table.options.nestedFieldSeparator) : [field] : [];
    	this.getFieldValue = this.fieldStructure.length > 1 ? this._getNestedData : this._getFlatData;
    	this.setFieldValue = this.fieldStructure.length > 1 ? this._setNestedData : this._setFlatData;
    };

    //register column position with column manager
    Column.prototype.registerColumnPosition = function (column) {
    	this.parent.registerColumnPosition(column);
    };

    //register column position with column manager
    Column.prototype.registerColumnField = function (column) {
    	this.parent.registerColumnField(column);
    };

    //trigger position registration
    Column.prototype.reRegisterPosition = function () {
    	if (this.isGroup) {
    		this.columns.forEach(function (column) {
    			column.reRegisterPosition();
    		});
    	} else {
    		this.registerColumnPosition(this);
    	}
    };

    Column.prototype._mapDepricatedFunctionality = function () {
    	if (typeof this.definition.hideInHtml !== "undefined") {
    		this.definition.htmlOutput = !this.definition.hideInHtml;
    		console.warn("hideInHtml column definition property is deprecated, you should now use htmlOutput");
    	}

    	if (typeof this.definition.align !== "undefined") {
    		this.definition.hozAlign = this.definition.align;
    		console.warn("align column definition property is deprecated, you should now use hozAlign");
    	}

    	if (typeof this.definition.downloadTitle !== "undefined") {
    		this.definition.titleDownload = this.definition.downloadTitle;
    		console.warn("downloadTitle definition property is deprecated, you should now use titleDownload");
    	}
    };

    Column.prototype.setTooltip = function () {
    	var self = this,
    	    def = self.definition;

    	//set header tooltips
    	var tooltip = def.headerTooltip || def.tooltip === false ? def.headerTooltip : self.table.options.tooltipsHeader;

    	if (tooltip) {
    		if (tooltip === true) {
    			if (def.field) {
    				self.table.modules.localize.bind("columns|" + def.field, function (value) {
    					self.element.setAttribute("title", value || def.title);
    				});
    			} else {
    				self.element.setAttribute("title", def.title);
    			}
    		} else {
    			if (typeof tooltip == "function") {
    				tooltip = tooltip(self.getComponent());

    				if (tooltip === false) {
    					tooltip = "";
    				}
    			}

    			self.element.setAttribute("title", tooltip);
    		}
    	} else {
    		self.element.setAttribute("title", "");
    	}
    };

    //build header element
    Column.prototype._buildHeader = function () {
    	var self = this,
    	    def = self.definition;

    	while (self.element.firstChild) {
    		self.element.removeChild(self.element.firstChild);
    	}if (def.headerVertical) {
    		self.element.classList.add("tabulator-col-vertical");

    		if (def.headerVertical === "flip") {
    			self.element.classList.add("tabulator-col-vertical-flip");
    		}
    	}

    	self.contentElement = self._bindEvents();

    	self.contentElement = self._buildColumnHeaderContent();

    	self.element.appendChild(self.contentElement);

    	if (self.isGroup) {
    		self._buildGroupHeader();
    	} else {
    		self._buildColumnHeader();
    	}

    	self.setTooltip();

    	//set resizable handles
    	if (self.table.options.resizableColumns && self.table.modExists("resizeColumns")) {
    		self.table.modules.resizeColumns.initializeColumn("header", self, self.element);
    	}

    	//set resizable handles
    	if (def.headerFilter && self.table.modExists("filter") && self.table.modExists("edit")) {
    		if (typeof def.headerFilterPlaceholder !== "undefined" && def.field) {
    			self.table.modules.localize.setHeaderFilterColumnPlaceholder(def.field, def.headerFilterPlaceholder);
    		}

    		self.table.modules.filter.initializeColumn(self);
    	}

    	//set resizable handles
    	if (self.table.modExists("frozenColumns")) {
    		self.table.modules.frozenColumns.initializeColumn(self);
    	}

    	//set movable column
    	if (self.table.options.movableColumns && !self.isGroup && self.table.modExists("moveColumn")) {
    		self.table.modules.moveColumn.initializeColumn(self);
    	}

    	//set calcs column
    	if ((def.topCalc || def.bottomCalc) && self.table.modExists("columnCalcs")) {
    		self.table.modules.columnCalcs.initializeColumn(self);
    	}

    	//handle persistence
    	if (self.table.modExists("persistence") && self.table.modules.persistence.config.columns) {
    		self.table.modules.persistence.initializeColumn(self);
    	}

    	//update header tooltip on mouse enter
    	self.element.addEventListener("mouseenter", function (e) {
    		self.setTooltip();
    	});
    };

    Column.prototype._bindEvents = function () {

    	var self = this,
    	    def = self.definition,
    	    dblTap,
    	    tapHold,
    	    tap;

    	//setup header click event bindings
    	if (typeof def.headerClick == "function") {
    		self.element.addEventListener("click", function (e) {
    			def.headerClick(e, self.getComponent());
    		});
    	}

    	if (typeof def.headerDblClick == "function") {
    		self.element.addEventListener("dblclick", function (e) {
    			def.headerDblClick(e, self.getComponent());
    		});
    	}

    	if (typeof def.headerContext == "function") {
    		self.element.addEventListener("contextmenu", function (e) {
    			def.headerContext(e, self.getComponent());
    		});
    	}

    	//setup header tap event bindings
    	if (typeof def.headerTap == "function") {
    		tap = false;

    		self.element.addEventListener("touchstart", function (e) {
    			tap = true;
    		}, { passive: true });

    		self.element.addEventListener("touchend", function (e) {
    			if (tap) {
    				def.headerTap(e, self.getComponent());
    			}

    			tap = false;
    		});
    	}

    	if (typeof def.headerDblTap == "function") {
    		dblTap = null;

    		self.element.addEventListener("touchend", function (e) {

    			if (dblTap) {
    				clearTimeout(dblTap);
    				dblTap = null;

    				def.headerDblTap(e, self.getComponent());
    			} else {

    				dblTap = setTimeout(function () {
    					clearTimeout(dblTap);
    					dblTap = null;
    				}, 300);
    			}
    		});
    	}

    	if (typeof def.headerTapHold == "function") {
    		tapHold = null;

    		self.element.addEventListener("touchstart", function (e) {
    			clearTimeout(tapHold);

    			tapHold = setTimeout(function () {
    				clearTimeout(tapHold);
    				tapHold = null;
    				tap = false;
    				def.headerTapHold(e, self.getComponent());
    			}, 1000);
    		}, { passive: true });

    		self.element.addEventListener("touchend", function (e) {
    			clearTimeout(tapHold);
    			tapHold = null;
    		});
    	}

    	//store column cell click event bindings
    	if (typeof def.cellClick == "function") {
    		self.cellEvents.cellClick = def.cellClick;
    	}

    	if (typeof def.cellDblClick == "function") {
    		self.cellEvents.cellDblClick = def.cellDblClick;
    	}

    	if (typeof def.cellContext == "function") {
    		self.cellEvents.cellContext = def.cellContext;
    	}

    	//store column mouse event bindings
    	if (typeof def.cellMouseEnter == "function") {
    		self.cellEvents.cellMouseEnter = def.cellMouseEnter;
    	}

    	if (typeof def.cellMouseLeave == "function") {
    		self.cellEvents.cellMouseLeave = def.cellMouseLeave;
    	}

    	if (typeof def.cellMouseOver == "function") {
    		self.cellEvents.cellMouseOver = def.cellMouseOver;
    	}

    	if (typeof def.cellMouseOut == "function") {
    		self.cellEvents.cellMouseOut = def.cellMouseOut;
    	}

    	if (typeof def.cellMouseMove == "function") {
    		self.cellEvents.cellMouseMove = def.cellMouseMove;
    	}

    	//setup column cell tap event bindings
    	if (typeof def.cellTap == "function") {
    		self.cellEvents.cellTap = def.cellTap;
    	}

    	if (typeof def.cellDblTap == "function") {
    		self.cellEvents.cellDblTap = def.cellDblTap;
    	}

    	if (typeof def.cellTapHold == "function") {
    		self.cellEvents.cellTapHold = def.cellTapHold;
    	}

    	//setup column cell edit callbacks
    	if (typeof def.cellEdited == "function") {
    		self.cellEvents.cellEdited = def.cellEdited;
    	}

    	if (typeof def.cellEditing == "function") {
    		self.cellEvents.cellEditing = def.cellEditing;
    	}

    	if (typeof def.cellEditCancelled == "function") {
    		self.cellEvents.cellEditCancelled = def.cellEditCancelled;
    	}
    };

    //build header element for header
    Column.prototype._buildColumnHeader = function () {
    	var _this6 = this;

    	var def = this.definition,
    	    table = this.table;

    	//set column sorter
    	if (table.modExists("sort")) {
    		table.modules.sort.initializeColumn(this, this.titleHolderElement);
    	}

    	//set column header context menu
    	if ((def.headerContextMenu || def.headerClickMenu || def.headerMenu) && table.modExists("menu")) {
    		table.modules.menu.initializeColumnHeader(this);
    	}

    	//set column formatter
    	if (table.modExists("format")) {
    		table.modules.format.initializeColumn(this);
    	}

    	//set column editor
    	if (typeof def.editor != "undefined" && table.modExists("edit")) {
    		table.modules.edit.initializeColumn(this);
    	}

    	//set colum validator
    	if (typeof def.validator != "undefined" && table.modExists("validate")) {
    		table.modules.validate.initializeColumn(this);
    	}

    	//set column mutator
    	if (table.modExists("mutator")) {
    		table.modules.mutator.initializeColumn(this);
    	}

    	//set column accessor
    	if (table.modExists("accessor")) {
    		table.modules.accessor.initializeColumn(this);
    	}

    	//set respoviveLayout
    	if (_typeof(table.options.responsiveLayout) && table.modExists("responsiveLayout")) {
    		table.modules.responsiveLayout.initializeColumn(this);
    	}

    	//set column visibility
    	if (typeof def.visible != "undefined") {
    		if (def.visible) {
    			this.show(true);
    		} else {
    			this.hide(true);
    		}
    	}

    	//asign additional css classes to column header
    	if (def.cssClass) {
    		var classeNames = def.cssClass.split(" ");
    		classeNames.forEach(function (className) {
    			_this6.element.classList.add(className);
    		});
    	}

    	if (def.field) {
    		this.element.setAttribute("tabulator-field", def.field);
    	}

    	//set min width if present
    	this.setMinWidth(typeof def.minWidth == "undefined" ? this.table.options.columnMinWidth : parseInt(def.minWidth));

    	if (def.maxWidth || this.table.options.columnMaxWidth) {
    		if (def.maxWidth !== false) {
    			this.setMaxWidth(typeof def.maxWidth == "undefined" ? this.table.options.columnMaxWidth : parseInt(def.maxWidth));
    		}
    	}

    	this.reinitializeWidth();

    	//set tooltip if present
    	this.tooltip = this.definition.tooltip || this.definition.tooltip === false ? this.definition.tooltip : this.table.options.tooltips;

    	//set orizontal text alignment
    	this.hozAlign = typeof this.definition.hozAlign == "undefined" ? this.table.options.cellHozAlign : this.definition.hozAlign;
    	this.vertAlign = typeof this.definition.vertAlign == "undefined" ? this.table.options.cellVertAlign : this.definition.vertAlign;

    	this.titleElement.style.textAlign = this.definition.headerHozAlign || this.table.options.headerHozAlign;
    };

    Column.prototype._buildColumnHeaderContent = function () {
    	this.definition;
    	    this.table;

    	var contentElement = document.createElement("div");
    	contentElement.classList.add("tabulator-col-content");

    	this.titleHolderElement = document.createElement("div");
    	this.titleHolderElement.classList.add("tabulator-col-title-holder");

    	contentElement.appendChild(this.titleHolderElement);

    	this.titleElement = this._buildColumnHeaderTitle();

    	this.titleHolderElement.appendChild(this.titleElement);

    	return contentElement;
    };

    //build title element of column
    Column.prototype._buildColumnHeaderTitle = function () {
    	var self = this,
    	    def = self.definition,
    	    table = self.table;

    	var titleHolderElement = document.createElement("div");
    	titleHolderElement.classList.add("tabulator-col-title");

    	if (def.editableTitle) {
    		var titleElement = document.createElement("input");
    		titleElement.classList.add("tabulator-title-editor");

    		titleElement.addEventListener("click", function (e) {
    			e.stopPropagation();
    			titleElement.focus();
    		});

    		titleElement.addEventListener("change", function () {
    			def.title = titleElement.value;
    			table.options.columnTitleChanged.call(self.table, self.getComponent());
    		});

    		titleHolderElement.appendChild(titleElement);

    		if (def.field) {
    			table.modules.localize.bind("columns|" + def.field, function (text) {
    				titleElement.value = text || def.title || "&nbsp;";
    			});
    		} else {
    			titleElement.value = def.title || "&nbsp;";
    		}
    	} else {
    		if (def.field) {
    			table.modules.localize.bind("columns|" + def.field, function (text) {
    				self._formatColumnHeaderTitle(titleHolderElement, text || def.title || "&nbsp;");
    			});
    		} else {
    			self._formatColumnHeaderTitle(titleHolderElement, def.title || "&nbsp;");
    		}
    	}

    	return titleHolderElement;
    };

    Column.prototype._formatColumnHeaderTitle = function (el, title) {
    	var _this7 = this;

    	var formatter, contents, params, mockCell, onRendered;

    	if (this.definition.titleFormatter && this.table.modExists("format")) {

    		formatter = this.table.modules.format.getFormatter(this.definition.titleFormatter);

    		onRendered = function onRendered(callback) {
    			_this7.titleFormatterRendered = callback;
    		};

    		mockCell = {
    			getValue: function getValue() {
    				return title;
    			},
    			getElement: function getElement() {
    				return el;
    			}
    		};

    		params = this.definition.titleFormatterParams || {};

    		params = typeof params === "function" ? params() : params;

    		contents = formatter.call(this.table.modules.format, mockCell, params, onRendered);

    		switch (typeof contents === 'undefined' ? 'undefined' : _typeof(contents)) {
    			case "object":
    				if (contents instanceof Node) {
    					el.appendChild(contents);
    				} else {
    					el.innerHTML = "";
    					console.warn("Format Error - Title formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", contents);
    				}
    				break;
    			case "undefined":
    			case "null":
    				el.innerHTML = "";
    				break;
    			default:
    				el.innerHTML = contents;
    		}
    	} else {
    		el.innerHTML = title;
    	}
    };

    //build header element for column group
    Column.prototype._buildGroupHeader = function () {
    	var _this8 = this;

    	this.element.classList.add("tabulator-col-group");
    	this.element.setAttribute("role", "columngroup");
    	this.element.setAttribute("aria-title", this.definition.title);

    	//asign additional css classes to column header
    	if (this.definition.cssClass) {
    		var classeNames = this.definition.cssClass.split(" ");
    		classeNames.forEach(function (className) {
    			_this8.element.classList.add(className);
    		});
    	}

    	//set column header context menu
    	if ((this.definition.headerContextMenu || this.definition.headerMenu) && this.table.modExists("menu")) {
    		this.table.modules.menu.initializeColumnHeader(this);
    	}

    	this.titleElement.style.textAlign = this.definition.headerHozAlign || this.table.options.headerHozAlign;

    	this.element.appendChild(this.groupElement);
    };

    //flat field lookup
    Column.prototype._getFlatData = function (data) {
    	return data[this.field];
    };

    //nested field lookup
    Column.prototype._getNestedData = function (data) {
    	var dataObj = data,
    	    structure = this.fieldStructure,
    	    length = structure.length,
    	    output;

    	for (var _i = 0; _i < length; _i++) {

    		dataObj = dataObj[structure[_i]];

    		output = dataObj;

    		if (!dataObj) {
    			break;
    		}
    	}

    	return output;
    };

    //flat field set
    Column.prototype._setFlatData = function (data, value) {
    	if (this.field) {
    		data[this.field] = value;
    	}
    };

    //nested field set
    Column.prototype._setNestedData = function (data, value) {
    	var dataObj = data,
    	    structure = this.fieldStructure,
    	    length = structure.length;

    	for (var _i2 = 0; _i2 < length; _i2++) {

    		if (_i2 == length - 1) {
    			dataObj[structure[_i2]] = value;
    		} else {
    			if (!dataObj[structure[_i2]]) {
    				if (typeof value !== "undefined") {
    					dataObj[structure[_i2]] = {};
    				} else {
    					break;
    				}
    			}

    			dataObj = dataObj[structure[_i2]];
    		}
    	}
    };

    //attach column to this group
    Column.prototype.attachColumn = function (column) {
    	var self = this;

    	if (self.groupElement) {
    		self.columns.push(column);
    		self.groupElement.appendChild(column.getElement());
    	} else {
    		console.warn("Column Warning - Column being attached to another column instead of column group");
    	}
    };

    //vertically align header in column
    Column.prototype.verticalAlign = function (alignment, height) {

    	//calculate height of column header and group holder element
    	var parentHeight = this.parent.isGroup ? this.parent.getGroupElement().clientHeight : height || this.parent.getHeadersElement().clientHeight;
    	// var parentHeight = this.parent.isGroup ? this.parent.getGroupElement().clientHeight : this.parent.getHeadersElement().clientHeight;

    	this.element.style.height = parentHeight + "px";

    	if (this.isGroup) {
    		this.groupElement.style.minHeight = parentHeight - this.contentElement.offsetHeight + "px";
    	}

    	//vertically align cell contents
    	if (!this.isGroup && alignment !== "top") {
    		if (alignment === "bottom") {
    			this.element.style.paddingTop = this.element.clientHeight - this.contentElement.offsetHeight + "px";
    		} else {
    			this.element.style.paddingTop = (this.element.clientHeight - this.contentElement.offsetHeight) / 2 + "px";
    		}
    	}

    	this.columns.forEach(function (column) {
    		column.verticalAlign(alignment);
    	});
    };

    //clear vertical alignmenet
    Column.prototype.clearVerticalAlign = function () {
    	this.element.style.paddingTop = "";
    	this.element.style.height = "";
    	this.element.style.minHeight = "";
    	this.groupElement.style.minHeight = "";

    	this.columns.forEach(function (column) {
    		column.clearVerticalAlign();
    	});
    };

    Column.prototype.bindModuleColumns = function () {
    	//check if rownum formatter is being used on a column
    	if (this.definition.formatter == "rownum") {
    		this.table.rowManager.rowNumColumn = this;
    	}
    };

    //// Retreive Column Information ////

    //return column header element
    Column.prototype.getElement = function () {
    	return this.element;
    };

    //return colunm group element
    Column.prototype.getGroupElement = function () {
    	return this.groupElement;
    };

    //return field name
    Column.prototype.getField = function () {
    	return this.field;
    };

    //return the first column in a group
    Column.prototype.getFirstColumn = function () {
    	if (!this.isGroup) {
    		return this;
    	} else {
    		if (this.columns.length) {
    			return this.columns[0].getFirstColumn();
    		} else {
    			return false;
    		}
    	}
    };

    //return the last column in a group
    Column.prototype.getLastColumn = function () {
    	if (!this.isGroup) {
    		return this;
    	} else {
    		if (this.columns.length) {
    			return this.columns[this.columns.length - 1].getLastColumn();
    		} else {
    			return false;
    		}
    	}
    };

    //return all columns in a group
    Column.prototype.getColumns = function () {
    	return this.columns;
    };

    //return all columns in a group
    Column.prototype.getCells = function () {
    	return this.cells;
    };

    //retreive the top column in a group of columns
    Column.prototype.getTopColumn = function () {
    	if (this.parent.isGroup) {
    		return this.parent.getTopColumn();
    	} else {
    		return this;
    	}
    };

    //return column definition object
    Column.prototype.getDefinition = function (updateBranches) {
    	var colDefs = [];

    	if (this.isGroup && updateBranches) {
    		this.columns.forEach(function (column) {
    			colDefs.push(column.getDefinition(true));
    		});

    		this.definition.columns = colDefs;
    	}

    	return this.definition;
    };

    //////////////////// Actions ////////////////////

    Column.prototype.checkColumnVisibility = function () {
    	var visible = false;

    	this.columns.forEach(function (column) {
    		if (column.visible) {
    			visible = true;
    		}
    	});

    	if (visible) {
    		this.show();
    		this.parent.table.options.columnVisibilityChanged.call(this.table, this.getComponent(), false);
    	} else {
    		this.hide();
    	}
    };

    //show column
    Column.prototype.show = function (silent, responsiveToggle) {
    	if (!this.visible) {
    		this.visible = true;

    		this.element.style.display = "";

    		if (this.parent.isGroup) {
    			this.parent.checkColumnVisibility();
    		}

    		this.cells.forEach(function (cell) {
    			cell.show();
    		});

    		if (!this.isGroup && this.width === null) {
    			this.reinitializeWidth();
    		}

    		this.table.columnManager._verticalAlignHeaders();

    		if (this.table.options.persistence && this.table.modExists("persistence", true) && this.table.modules.persistence.config.columns) {
    			this.table.modules.persistence.save("columns");
    		}

    		if (!responsiveToggle && this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
    			this.table.modules.responsiveLayout.updateColumnVisibility(this, this.visible);
    		}

    		if (!silent) {
    			this.table.options.columnVisibilityChanged.call(this.table, this.getComponent(), true);
    		}

    		if (this.parent.isGroup) {
    			this.parent.matchChildWidths();
    		}

    		if (!this.silent && this.table.options.virtualDomHoz) {
    			this.table.vdomHoz.reinitialize();
    		}
    	}
    };

    //hide column
    Column.prototype.hide = function (silent, responsiveToggle) {
    	if (this.visible) {
    		this.visible = false;

    		this.element.style.display = "none";

    		this.table.columnManager._verticalAlignHeaders();

    		if (this.parent.isGroup) {
    			this.parent.checkColumnVisibility();
    		}

    		this.cells.forEach(function (cell) {
    			cell.hide();
    		});

    		if (this.table.options.persistence && this.table.modExists("persistence", true) && this.table.modules.persistence.config.columns) {
    			this.table.modules.persistence.save("columns");
    		}

    		if (!responsiveToggle && this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
    			this.table.modules.responsiveLayout.updateColumnVisibility(this, this.visible);
    		}

    		if (!silent) {
    			this.table.options.columnVisibilityChanged.call(this.table, this.getComponent(), false);
    		}

    		if (this.parent.isGroup) {
    			this.parent.matchChildWidths();
    		}

    		if (!this.silent && this.table.options.virtualDomHoz) {
    			this.table.vdomHoz.reinitialize();
    		}
    	}
    };

    Column.prototype.matchChildWidths = function () {
    	var childWidth = 0;

    	if (this.contentElement && this.columns.length) {
    		this.columns.forEach(function (column) {
    			if (column.visible) {
    				childWidth += column.getWidth();
    			}
    		});

    		this.contentElement.style.maxWidth = childWidth - 1 + "px";

    		if (this.parent.isGroup) {
    			this.parent.matchChildWidths();
    		}
    	}
    };

    Column.prototype.removeChild = function (child) {
    	var index = this.columns.indexOf(child);

    	if (index > -1) {
    		this.columns.splice(index, 1);
    	}

    	if (!this.columns.length) {
    		this.delete();
    	}
    };

    Column.prototype.setWidth = function (width) {
    	this.widthFixed = true;
    	this.setWidthActual(width);
    };

    Column.prototype.setWidthActual = function (width) {
    	if (isNaN(width)) {
    		width = Math.floor(this.table.element.clientWidth / 100 * parseInt(width));
    	}

    	width = Math.max(this.minWidth, width);

    	if (this.maxWidth) {
    		width = Math.min(this.maxWidth, width);
    	}

    	this.width = width;
    	this.widthStyled = width ? width + "px" : "";

    	this.element.style.width = this.widthStyled;

    	if (!this.isGroup) {
    		this.cells.forEach(function (cell) {
    			cell.setWidth();
    		});
    	}

    	if (this.parent.isGroup) {
    		this.parent.matchChildWidths();
    	}

    	//set resizable handles
    	if (this.table.modExists("frozenColumns")) {
    		this.table.modules.frozenColumns.layout();
    	}
    };

    Column.prototype.checkCellHeights = function () {
    	var rows = [];

    	this.cells.forEach(function (cell) {
    		if (cell.row.heightInitialized) {
    			if (cell.row.getElement().offsetParent !== null) {
    				rows.push(cell.row);
    				cell.row.clearCellHeight();
    			} else {
    				cell.row.heightInitialized = false;
    			}
    		}
    	});

    	rows.forEach(function (row) {
    		row.calcHeight();
    	});

    	rows.forEach(function (row) {
    		row.setCellHeight();
    	});
    };

    Column.prototype.getWidth = function () {
    	var width = 0;

    	if (this.isGroup) {
    		this.columns.forEach(function (column) {
    			if (column.visible) {
    				width += column.getWidth();
    			}
    		});
    	} else {
    		width = this.width;
    	}

    	return width;
    };

    Column.prototype.getHeight = function () {
    	return this.element.offsetHeight;
    };

    Column.prototype.setMinWidth = function (minWidth) {
    	this.minWidth = minWidth;
    	this.minWidthStyled = minWidth ? minWidth + "px" : "";

    	this.element.style.minWidth = this.minWidthStyled;

    	this.cells.forEach(function (cell) {
    		cell.setMinWidth();
    	});
    };

    Column.prototype.setMaxWidth = function (maxWidth) {
    	this.maxWidth = maxWidth;
    	this.maxWidthStyled = maxWidth ? maxWidth + "px" : "";

    	this.element.style.maxWidth = this.maxWidthStyled;

    	this.cells.forEach(function (cell) {
    		cell.setMaxWidth();
    	});
    };

    Column.prototype.delete = function () {
    	var _this9 = this;

    	return new Promise(function (resolve, reject) {

    		if (_this9.isGroup) {
    			_this9.columns.forEach(function (column) {
    				column.delete();
    			});
    		}

    		//cancel edit if column is currently being edited
    		if (_this9.table.modExists("edit")) {
    			if (_this9.table.modules.edit.currentCell.column === _this9) {
    				_this9.table.modules.edit.cancelEdit();
    			}
    		}

    		var cellCount = _this9.cells.length;

    		for (var _i3 = 0; _i3 < cellCount; _i3++) {
    			_this9.cells[0].delete();
    		}

    		if (_this9.element.parentNode) {
    			_this9.element.parentNode.removeChild(_this9.element);
    		}

    		_this9.element = false;
    		_this9.contentElement = false;
    		_this9.titleElement = false;
    		_this9.groupElement = false;

    		if (_this9.parent.isGroup) {
    			_this9.parent.removeChild(_this9);
    		}

    		_this9.table.columnManager.deregisterColumn(_this9);

    		if (_this9.table.options.virtualDomHoz) {
    			_this9.table.vdomHoz.reinitialize(true);
    		}

    		resolve();
    	});
    };

    Column.prototype.columnRendered = function () {
    	if (this.titleFormatterRendered) {
    		this.titleFormatterRendered();
    	}
    };

    Column.prototype.validate = function () {
    	var invalid = [];

    	this.cells.forEach(function (cell) {
    		if (!cell.validate()) {
    			invalid.push(cell.getComponent());
    		}
    	});

    	return invalid.length ? invalid : true;
    };

    //////////////// Cell Management /////////////////

    //generate cell for this column
    Column.prototype.generateCell = function (row) {
    	var self = this;

    	var cell = new Cell(self, row);

    	this.cells.push(cell);

    	return cell;
    };

    Column.prototype.nextColumn = function () {
    	var index = this.table.columnManager.findColumnIndex(this);
    	return index > -1 ? this._nextVisibleColumn(index + 1) : false;
    };

    Column.prototype._nextVisibleColumn = function (index) {
    	var column = this.table.columnManager.getColumnByIndex(index);
    	return !column || column.visible ? column : this._nextVisibleColumn(index + 1);
    };

    Column.prototype.prevColumn = function () {
    	var index = this.table.columnManager.findColumnIndex(this);
    	return index > -1 ? this._prevVisibleColumn(index - 1) : false;
    };

    Column.prototype._prevVisibleColumn = function (index) {
    	var column = this.table.columnManager.getColumnByIndex(index);
    	return !column || column.visible ? column : this._prevVisibleColumn(index - 1);
    };

    Column.prototype.reinitializeWidth = function (force) {
    	this.widthFixed = false;

    	//set width if present
    	if (typeof this.definition.width !== "undefined" && !force) {
    		this.setWidth(this.definition.width);
    	}

    	//hide header filters to prevent them altering column width
    	if (this.table.modExists("filter")) {
    		this.table.modules.filter.hideHeaderFilterElements();
    	}

    	this.fitToData();

    	//show header filters again after layout is complete
    	if (this.table.modExists("filter")) {
    		this.table.modules.filter.showHeaderFilterElements();
    	}
    };

    //set column width to maximum cell width
    Column.prototype.fitToData = function () {
    	var self = this;

    	if (!this.widthFixed) {
    		this.element.style.width = "";

    		self.cells.forEach(function (cell) {
    			cell.clearWidth();
    		});
    	}

    	var maxWidth = this.element.offsetWidth;

    	if (!self.width || !this.widthFixed) {
    		self.cells.forEach(function (cell) {
    			var width = cell.getWidth();

    			if (width > maxWidth) {
    				maxWidth = width;
    			}
    		});

    		if (maxWidth) {
    			self.setWidthActual(maxWidth + 1);
    		}
    	}
    };

    Column.prototype.updateDefinition = function (updates) {
    	var _this10 = this;

    	return new Promise(function (resolve, reject) {
    		var definition;

    		if (!_this10.isGroup) {
    			if (!_this10.parent.isGroup) {
    				definition = Object.assign({}, _this10.getDefinition());
    				definition = Object.assign(definition, updates);

    				_this10.table.columnManager.addColumn(definition, false, _this10).then(function (column) {

    					if (definition.field == _this10.field) {
    						_this10.field = false; //cleair field name to prevent deletion of duplicate column from arrays
    					}

    					_this10.delete().then(function () {
    						resolve(column.getComponent());
    					}).catch(function (err) {
    						reject(err);
    					});
    				}).catch(function (err) {
    					reject(err);
    				});
    			} else {
    				console.warn("Column Update Error - The updateDefinition function is only available on ungrouped columns");
    				reject("Column Update Error - The updateDefinition function is only available on columns, not column groups");
    			}
    		} else {
    			console.warn("Column Update Error - The updateDefinition function is only available on ungrouped columns");
    			reject("Column Update Error - The updateDefinition function is only available on columns, not column groups");
    		}
    	});
    };

    Column.prototype.deleteCell = function (cell) {
    	var index = this.cells.indexOf(cell);

    	if (index > -1) {
    		this.cells.splice(index, 1);
    	}
    };

    Column.prototype.defaultOptionList = ["title", "field", "columns", "visible", "align", "hozAlign", "vertAlign", "width", "minWidth", "maxWidth", "widthGrow", "widthShrink", "resizable", "frozen", "responsive", "tooltip", "cssClass", "rowHandle", "hideInHtml", "print", "htmlOutput", "sorter", "sorterParams", "formatter", "formatterParams", "variableHeight", "editable", "editor", "editorParams", "validator", "mutator", "mutatorParams", "mutatorData", "mutatorDataParams", "mutatorEdit", "mutatorEditParams", "mutatorClipboard", "mutatorClipboardParams", "accessor", "accessorParams", "accessorData", "accessorDataParams", "accessorDownload", "accessorDownloadParams", "accessorClipboard", "accessorClipboardParams", "accessorPrint", "accessorPrintParams", "accessorHtmlOutput", "accessorHtmlOutputParams", "clipboard", "download", "downloadTitle", "topCalc", "topCalcParams", "topCalcFormatter", "topCalcFormatterParams", "bottomCalc", "bottomCalcParams", "bottomCalcFormatter", "bottomCalcFormatterParams", "cellClick", "cellDblClick", "cellContext", "cellTap", "cellDblTap", "cellTapHold", "cellMouseEnter", "cellMouseLeave", "cellMouseOver", "cellMouseOut", "cellMouseMove", "cellEditing", "cellEdited", "cellEditCancelled", "headerSort", "headerSortStartingDir", "headerSortTristate", "headerClick", "headerDblClick", "headerContext", "headerTap", "headerDblTap", "headerTapHold", "headerTooltip", "headerVertical", "headerHozAlign", "editableTitle", "titleFormatter", "titleFormatterParams", "headerFilter", "headerFilterPlaceholder", "headerFilterParams", "headerFilterEmptyCheck", "headerFilterFunc", "headerFilterFuncParams", "headerFilterLiveFilter", "print", "headerContextMenu", "headerMenu", "contextMenu",
    // "headerClickMenu",
    "clickMenu", "formatterPrint", "formatterPrintParams", "formatterClipboard", "formatterClipboardParams", "formatterHtmlOutput", "formatterHtmlOutputParams", "titlePrint", "titleClipboard", "titleHtmlOutput", "titleDownload"];

    //////////////// Event Bindings /////////////////

    //////////////// Object Generation /////////////////
    Column.prototype.getComponent = function () {
    	if (!this.component) {
    		this.component = new ColumnComponent(this);
    	}

    	return this.component;
    };

    var RowManager = function RowManager(table) {

    	this.table = table;
    	this.element = this.createHolderElement(); //containing element
    	this.tableElement = this.createTableElement(); //table element
    	this.heightFixer = this.createTableElement(); //table element
    	this.columnManager = null; //hold column manager object
    	this.height = 0; //hold height of table element

    	this.firstRender = false; //handle first render
    	this.renderMode = "virtual"; //current rendering mode
    	this.fixedHeight = false; //current rendering mode

    	this.rows = []; //hold row data objects
    	this.activeRows = []; //rows currently available to on display in the table
    	this.activeRowsCount = 0; //count of active rows

    	this.displayRows = []; //rows currently on display in the table
    	this.displayRowsCount = 0; //count of display rows

    	this.scrollTop = 0;
    	this.scrollLeft = 0;

    	this.vDomRowHeight = 20; //approximation of row heights for padding

    	this.vDomTop = 0; //hold position for first rendered row in the virtual DOM
    	this.vDomBottom = 0; //hold possition for last rendered row in the virtual DOM

    	this.vDomScrollPosTop = 0; //last scroll position of the vDom top;
    	this.vDomScrollPosBottom = 0; //last scroll position of the vDom bottom;

    	this.vDomTopPad = 0; //hold value of padding for top of virtual DOM
    	this.vDomBottomPad = 0; //hold value of padding for bottom of virtual DOM

    	this.vDomMaxRenderChain = 90; //the maximum number of dom elements that can be rendered in 1 go

    	this.vDomWindowBuffer = 0; //window row buffer before removing elements, to smooth scrolling

    	this.vDomWindowMinTotalRows = 20; //minimum number of rows to be generated in virtual dom (prevent buffering issues on tables with tall rows)
    	this.vDomWindowMinMarginRows = 5; //minimum number of rows to be generated in virtual dom margin

    	this.vDomTopNewRows = []; //rows to normalize after appending to optimize render speed
    	this.vDomBottomNewRows = []; //rows to normalize after appending to optimize render speed

    	this.rowNumColumn = false; //hold column component for row number column

    	this.redrawBlock = false; //prevent redraws to allow multiple data manipulations becore continuing
    	this.redrawBlockRestoreConfig = false; //store latest redraw function calls for when redraw is needed
    	this.redrawBlockRederInPosition = false; //store latest redraw function calls for when redraw is needed
    };

    //////////////// Setup Functions /////////////////

    RowManager.prototype.createHolderElement = function () {
    	var el = document.createElement("div");

    	el.classList.add("tabulator-tableHolder");
    	el.setAttribute("tabindex", 0);

    	return el;
    };

    RowManager.prototype.createTableElement = function () {
    	var el = document.createElement("div");

    	el.classList.add("tabulator-table");

    	return el;
    };

    //return containing element
    RowManager.prototype.getElement = function () {
    	return this.element;
    };

    //return table element
    RowManager.prototype.getTableElement = function () {
    	return this.tableElement;
    };

    //return position of row in table
    RowManager.prototype.getRowPosition = function (row, active) {
    	if (active) {
    		return this.activeRows.indexOf(row);
    	} else {
    		return this.rows.indexOf(row);
    	}
    };

    //link to column manager
    RowManager.prototype.setColumnManager = function (manager) {
    	this.columnManager = manager;
    };

    RowManager.prototype.initialize = function () {
    	var self = this;

    	self.setRenderMode();

    	//initialize manager
    	self.element.appendChild(self.tableElement);

    	self.firstRender = true;

    	//scroll header along with table body
    	self.element.addEventListener("scroll", function () {
    		var left = self.element.scrollLeft;

    		//handle horizontal scrolling
    		if (self.scrollLeft != left) {
    			self.columnManager.scrollHorizontal(left);

    			if (self.table.options.groupBy) {
    				self.table.modules.groupRows.scrollHeaders(left);
    			}

    			if (self.table.modExists("columnCalcs")) {
    				self.table.modules.columnCalcs.scrollHorizontal(left);
    			}

    			self.table.options.scrollHorizontal(left);
    		}

    		self.scrollLeft = left;
    	});

    	//handle virtual dom scrolling
    	if (this.renderMode === "virtual") {

    		self.element.addEventListener("scroll", function () {
    			var top = self.element.scrollTop;
    			var dir = self.scrollTop > top;

    			//handle verical scrolling
    			if (self.scrollTop != top) {
    				self.scrollTop = top;
    				self.scrollVertical(dir);

    				if (self.table.options.ajaxProgressiveLoad == "scroll") {
    					self.table.modules.ajax.nextPage(self.element.scrollHeight - self.element.clientHeight - top);
    				}

    				self.table.options.scrollVertical(top);
    			} else {
    				self.scrollTop = top;
    			}
    		});
    	}
    };

    ////////////////// Row Manipulation //////////////////

    RowManager.prototype.findRow = function (subject) {
    	var self = this;

    	if ((typeof subject === 'undefined' ? 'undefined' : _typeof(subject)) == "object") {

    		if (subject instanceof Row) {
    			//subject is row element
    			return subject;
    		} else if (subject instanceof RowComponent) {
    			//subject is public row component
    			return subject._getSelf() || false;
    		} else if (typeof HTMLElement !== "undefined" && subject instanceof HTMLElement) {
    			//subject is a HTML element of the row
    			var match = self.rows.find(function (row) {
    				return row.getElement() === subject;
    			});

    			return match || false;
    		}
    	} else if (typeof subject == "undefined" || subject === null) {
    		return false;
    	} else {
    		//subject should be treated as the index of the row
    		var _match = self.rows.find(function (row) {
    			return row.data[self.table.options.index] == subject;
    		});

    		return _match || false;
    	}

    	//catch all for any other type of input

    	return false;
    };

    RowManager.prototype.getRowFromDataObject = function (data) {
    	var match = this.rows.find(function (row) {
    		return row.data === data;
    	});

    	return match || false;
    };

    RowManager.prototype.getRowFromPosition = function (position, active) {
    	if (active) {
    		return this.activeRows[position];
    	} else {
    		return this.rows[position];
    	}
    };

    RowManager.prototype.scrollToRow = function (row, position, ifVisible) {
    	var _this11 = this;

    	var rowIndex = this.getDisplayRows().indexOf(row),
    	    rowEl = row.getElement(),
    	    rowTop,
    	    offset = 0;

    	return new Promise(function (resolve, reject) {
    		if (rowIndex > -1) {

    			if (typeof position === "undefined") {
    				position = _this11.table.options.scrollToRowPosition;
    			}

    			if (typeof ifVisible === "undefined") {
    				ifVisible = _this11.table.options.scrollToRowIfVisible;
    			}

    			if (position === "nearest") {
    				switch (_this11.renderMode) {
    					case "classic":
    						rowTop = Tabulator.prototype.helpers.elOffset(rowEl).top;
    						position = Math.abs(_this11.element.scrollTop - rowTop) > Math.abs(_this11.element.scrollTop + _this11.element.clientHeight - rowTop) ? "bottom" : "top";
    						break;
    					case "virtual":
    						position = Math.abs(_this11.vDomTop - rowIndex) > Math.abs(_this11.vDomBottom - rowIndex) ? "bottom" : "top";
    						break;
    				}
    			}

    			//check row visibility
    			if (!ifVisible) {
    				if (Tabulator.prototype.helpers.elVisible(rowEl)) {
    					offset = Tabulator.prototype.helpers.elOffset(rowEl).top - Tabulator.prototype.helpers.elOffset(_this11.element).top;

    					if (offset > 0 && offset < _this11.element.clientHeight - rowEl.offsetHeight) {
    						return false;
    					}
    				}
    			}

    			//scroll to row
    			switch (_this11.renderMode) {
    				case "classic":
    					_this11.element.scrollTop = Tabulator.prototype.helpers.elOffset(rowEl).top - Tabulator.prototype.helpers.elOffset(_this11.element).top + _this11.element.scrollTop;
    					break;
    				case "virtual":
    					_this11._virtualRenderFill(rowIndex, true);
    					break;
    			}

    			//align to correct position
    			switch (position) {
    				case "middle":
    				case "center":

    					if (_this11.element.scrollHeight - _this11.element.scrollTop == _this11.element.clientHeight) {
    						_this11.element.scrollTop = _this11.element.scrollTop + (rowEl.offsetTop - _this11.element.scrollTop) - (_this11.element.scrollHeight - rowEl.offsetTop) / 2;
    					} else {
    						_this11.element.scrollTop = _this11.element.scrollTop - _this11.element.clientHeight / 2;
    					}

    					break;

    				case "bottom":

    					if (_this11.element.scrollHeight - _this11.element.scrollTop == _this11.element.clientHeight) {
    						_this11.element.scrollTop = _this11.element.scrollTop - (_this11.element.scrollHeight - rowEl.offsetTop) + rowEl.offsetHeight;
    					} else {
    						_this11.element.scrollTop = _this11.element.scrollTop - _this11.element.clientHeight + rowEl.offsetHeight;
    					}

    					break;
    			}

    			resolve();
    		} else {
    			console.warn("Scroll Error - Row not visible");
    			reject("Scroll Error - Row not visible");
    		}
    	});
    };

    ////////////////// Data Handling //////////////////

    RowManager.prototype.setData = function (data, renderInPosition, columnsChanged) {
    	var _this12 = this;

    	var self = this;

    	return new Promise(function (resolve, reject) {
    		if (renderInPosition && _this12.getDisplayRows().length) {
    			if (self.table.options.pagination) {
    				self._setDataActual(data, true);
    			} else {
    				_this12.reRenderInPosition(function () {
    					self._setDataActual(data);
    				});
    			}
    		} else {
    			if (_this12.table.options.autoColumns && columnsChanged) {
    				_this12.table.columnManager.generateColumnsFromRowData(data);
    			}
    			_this12.resetScroll();

    			_this12._setDataActual(data);
    		}

    		resolve();
    	});
    };

    RowManager.prototype._setDataActual = function (data, renderInPosition) {
    	var self = this;

    	self.table.options.dataLoading.call(this.table, data);

    	this._wipeElements();

    	if (this.table.options.history && this.table.modExists("history")) {
    		this.table.modules.history.clear();
    	}

    	if (Array.isArray(data)) {

    		if (this.table.modExists("selectRow")) {
    			this.table.modules.selectRow.clearSelectionData();
    		}

    		if (this.table.options.reactiveData && this.table.modExists("reactiveData", true)) {
    			this.table.modules.reactiveData.watchData(data);
    		}

    		data.forEach(function (def, i) {
    			if (def && (typeof def === 'undefined' ? 'undefined' : _typeof(def)) === "object") {
    				var row = new Row(def, self);
    				self.rows.push(row);
    			} else {
    				console.warn("Data Loading Warning - Invalid row data detected and ignored, expecting object but received:", def);
    			}
    		});

    		self.refreshActiveData(false, false, renderInPosition);

    		self.table.options.dataLoaded.call(this.table, data);
    	} else {
    		console.error("Data Loading Error - Unable to process data due to invalid data type \nExpecting: array \nReceived: ", typeof data === 'undefined' ? 'undefined' : _typeof(data), "\nData:     ", data);
    	}
    };

    RowManager.prototype._wipeElements = function () {
    	this.rows.forEach(function (row) {
    		row.wipe();
    	});

    	if (this.table.options.groupBy && this.table.modExists("groupRows")) {
    		this.table.modules.groupRows.wipe();
    	}

    	this.rows = [];
    	this.activeRows = [];
    	this.activeRowsCount = 0;
    	this.displayRows = [];
    	this.displayRowsCount = 0;

    	this.adjustTableSize();
    };

    RowManager.prototype.deleteRow = function (row, blockRedraw) {
    	var allIndex = this.rows.indexOf(row),
    	    activeIndex = this.activeRows.indexOf(row);

    	if (activeIndex > -1) {
    		this.activeRows.splice(activeIndex, 1);
    	}

    	if (allIndex > -1) {
    		this.rows.splice(allIndex, 1);
    	}

    	this.setActiveRows(this.activeRows);

    	this.displayRowIterator(function (rows) {
    		var displayIndex = rows.indexOf(row);

    		if (displayIndex > -1) {
    			rows.splice(displayIndex, 1);
    		}
    	});

    	if (!blockRedraw) {
    		this.reRenderInPosition();
    	}

    	this.regenerateRowNumbers();

    	this.table.options.rowDeleted.call(this.table, row.getComponent());

    	if (this.table.options.dataChanged) {
    		this.table.options.dataChanged.call(this.table, this.getData());
    	}

    	if (this.table.options.groupBy && this.table.modExists("groupRows")) {
    		this.table.modules.groupRows.updateGroupRows(true);
    	} else if (this.table.options.pagination && this.table.modExists("page")) {
    		this.refreshActiveData(false, false, true);
    	} else {
    		if (this.table.options.pagination && this.table.modExists("page")) {
    			this.refreshActiveData("page");
    		}
    	}
    };

    RowManager.prototype.addRow = function (data, pos, index, blockRedraw) {

    	var row = this.addRowActual(data, pos, index, blockRedraw);

    	if (this.table.options.history && this.table.modExists("history")) {
    		this.table.modules.history.action("rowAdd", row, { data: data, pos: pos, index: index });
    	}

    	return row;
    };

    //add multiple rows
    RowManager.prototype.addRows = function (data, pos, index) {
    	var _this13 = this;

    	var self = this,
    	    rows = [];

    	return new Promise(function (resolve, reject) {
    		pos = _this13.findAddRowPos(pos);

    		if (!Array.isArray(data)) {
    			data = [data];
    		}

    		data.length - 1;

    		if (typeof index == "undefined" && pos || typeof index !== "undefined" && !pos) {
    			data.reverse();
    		}

    		data.forEach(function (item, i) {
    			var row = self.addRow(item, pos, index, true);
    			rows.push(row);
    		});

    		if (_this13.table.options.groupBy && _this13.table.modExists("groupRows")) {
    			_this13.table.modules.groupRows.updateGroupRows(true);
    		} else if (_this13.table.options.pagination && _this13.table.modExists("page")) {
    			_this13.refreshActiveData(false, false, true);
    		} else {
    			_this13.reRenderInPosition();
    		}

    		//recalc column calculations if present
    		if (_this13.table.modExists("columnCalcs")) {
    			_this13.table.modules.columnCalcs.recalc(_this13.table.rowManager.activeRows);
    		}

    		_this13.regenerateRowNumbers();
    		resolve(rows);
    	});
    };

    RowManager.prototype.findAddRowPos = function (pos) {
    	if (typeof pos === "undefined") {
    		pos = this.table.options.addRowPos;
    	}

    	if (pos === "pos") {
    		pos = true;
    	}

    	if (pos === "bottom") {
    		pos = false;
    	}

    	return pos;
    };

    RowManager.prototype.addRowActual = function (data, pos, index, blockRedraw) {
    	var row = data instanceof Row ? data : new Row(data || {}, this),
    	    top = this.findAddRowPos(pos),
    	    allIndex = -1,
    	    activeIndex,
    	    dispRows;

    	if (!index && this.table.options.pagination && this.table.options.paginationAddRow == "page") {
    		dispRows = this.getDisplayRows();

    		if (top) {
    			if (dispRows.length) {
    				index = dispRows[0];
    			} else {
    				if (this.activeRows.length) {
    					index = this.activeRows[this.activeRows.length - 1];
    					top = false;
    				}
    			}
    		} else {
    			if (dispRows.length) {
    				index = dispRows[dispRows.length - 1];
    				top = dispRows.length < this.table.modules.page.getPageSize() ? false : true;
    			}
    		}
    	}

    	if (typeof index !== "undefined") {
    		index = this.findRow(index);
    	}

    	if (this.table.options.groupBy && this.table.modExists("groupRows")) {
    		this.table.modules.groupRows.assignRowToGroup(row);

    		var groupRows = row.getGroup().rows;

    		if (groupRows.length > 1) {

    			if (!index || index && groupRows.indexOf(index) == -1) {
    				if (top) {
    					if (groupRows[0] !== row) {
    						index = groupRows[0];
    						this._moveRowInArray(row.getGroup().rows, row, index, !top);
    					}
    				} else {
    					if (groupRows[groupRows.length - 1] !== row) {
    						index = groupRows[groupRows.length - 1];
    						this._moveRowInArray(row.getGroup().rows, row, index, !top);
    					}
    				}
    			} else {
    				this._moveRowInArray(row.getGroup().rows, row, index, !top);
    			}
    		}
    	}

    	if (index) {
    		allIndex = this.rows.indexOf(index);
    	}

    	if (index && allIndex > -1) {
    		activeIndex = this.activeRows.indexOf(index);

    		this.displayRowIterator(function (rows) {
    			var displayIndex = rows.indexOf(index);

    			if (displayIndex > -1) {
    				rows.splice(top ? displayIndex : displayIndex + 1, 0, row);
    			}
    		});

    		if (activeIndex > -1) {
    			this.activeRows.splice(top ? activeIndex : activeIndex + 1, 0, row);
    		}

    		this.rows.splice(top ? allIndex : allIndex + 1, 0, row);
    	} else {

    		if (top) {

    			this.displayRowIterator(function (rows) {
    				rows.unshift(row);
    			});

    			this.activeRows.unshift(row);
    			this.rows.unshift(row);
    		} else {
    			this.displayRowIterator(function (rows) {
    				rows.push(row);
    			});

    			this.activeRows.push(row);
    			this.rows.push(row);
    		}
    	}

    	this.setActiveRows(this.activeRows);

    	this.table.options.rowAdded.call(this.table, row.getComponent());

    	if (this.table.options.dataChanged) {
    		this.table.options.dataChanged.call(this.table, this.getData());
    	}

    	if (!blockRedraw) {
    		this.reRenderInPosition();
    	}

    	return row;
    };

    RowManager.prototype.moveRow = function (from, to, after) {
    	if (this.table.options.history && this.table.modExists("history")) {
    		this.table.modules.history.action("rowMove", from, { posFrom: this.getRowPosition(from), posTo: this.getRowPosition(to), to: to, after: after });
    	}

    	this.moveRowActual(from, to, after);

    	this.regenerateRowNumbers();

    	this.table.options.rowMoved.call(this.table, from.getComponent());
    };

    RowManager.prototype.moveRowActual = function (from, to, after) {
    	var _this14 = this;

    	this._moveRowInArray(this.rows, from, to, after);
    	this._moveRowInArray(this.activeRows, from, to, after);

    	this.displayRowIterator(function (rows) {
    		_this14._moveRowInArray(rows, from, to, after);
    	});

    	if (this.table.options.groupBy && this.table.modExists("groupRows")) {

    		if (!after && to instanceof Group) {
    			to = this.table.rowManager.prevDisplayRow(from) || to;
    		}

    		var toGroup = to.getGroup();
    		var fromGroup = from.getGroup();

    		if (toGroup === fromGroup) {
    			this._moveRowInArray(toGroup.rows, from, to, after);
    		} else {
    			if (fromGroup) {
    				fromGroup.removeRow(from);
    			}

    			toGroup.insertRow(from, to, after);
    		}
    	}
    };

    RowManager.prototype._moveRowInArray = function (rows, from, to, after) {
    	var fromIndex, toIndex, start, end;

    	if (from !== to) {

    		fromIndex = rows.indexOf(from);

    		if (fromIndex > -1) {

    			rows.splice(fromIndex, 1);

    			toIndex = rows.indexOf(to);

    			if (toIndex > -1) {

    				if (after) {
    					rows.splice(toIndex + 1, 0, from);
    				} else {
    					rows.splice(toIndex, 0, from);
    				}
    			} else {
    				rows.splice(fromIndex, 0, from);
    			}
    		}

    		//restyle rows
    		if (rows === this.getDisplayRows()) {

    			start = fromIndex < toIndex ? fromIndex : toIndex;
    			end = toIndex > fromIndex ? toIndex : fromIndex + 1;

    			for (var _i4 = start; _i4 <= end; _i4++) {
    				if (rows[_i4]) {
    					this.styleRow(rows[_i4], _i4);
    				}
    			}
    		}
    	}
    };

    RowManager.prototype.clearData = function () {
    	this.setData([]);
    };

    RowManager.prototype.getRowIndex = function (row) {
    	return this.findRowIndex(row, this.rows);
    };

    RowManager.prototype.getDisplayRowIndex = function (row) {
    	var index = this.getDisplayRows().indexOf(row);
    	return index > -1 ? index : false;
    };

    RowManager.prototype.nextDisplayRow = function (row, rowOnly) {
    	var index = this.getDisplayRowIndex(row),
    	    nextRow = false;

    	if (index !== false && index < this.displayRowsCount - 1) {
    		nextRow = this.getDisplayRows()[index + 1];
    	}

    	if (nextRow && (!(nextRow instanceof Row) || nextRow.type != "row")) {
    		return this.nextDisplayRow(nextRow, rowOnly);
    	}

    	return nextRow;
    };

    RowManager.prototype.prevDisplayRow = function (row, rowOnly) {
    	var index = this.getDisplayRowIndex(row),
    	    prevRow = false;

    	if (index) {
    		prevRow = this.getDisplayRows()[index - 1];
    	}

    	if (rowOnly && prevRow && (!(prevRow instanceof Row) || prevRow.type != "row")) {
    		return this.prevDisplayRow(prevRow, rowOnly);
    	}

    	return prevRow;
    };

    RowManager.prototype.findRowIndex = function (row, list) {
    	var rowIndex;

    	row = this.findRow(row);

    	if (row) {
    		rowIndex = list.indexOf(row);

    		if (rowIndex > -1) {
    			return rowIndex;
    		}
    	}

    	return false;
    };

    RowManager.prototype.getData = function (active, transform) {
    	var output = [],
    	    rows = this.getRows(active);

    	rows.forEach(function (row) {
    		if (row.type == "row") {
    			output.push(row.getData(transform || "data"));
    		}
    	});

    	return output;
    };

    RowManager.prototype.getComponents = function (active) {
    	var output = [],
    	    rows = this.getRows(active);

    	rows.forEach(function (row) {
    		output.push(row.getComponent());
    	});

    	return output;
    };

    RowManager.prototype.getDataCount = function (active) {
    	var rows = this.getRows(active);

    	return rows.length;
    };

    RowManager.prototype._genRemoteRequest = function () {
    	var _this15 = this;

    	var table = this.table,
    	    options = table.options,
    	    params = {};

    	if (table.modExists("page")) {
    		//set sort data if defined
    		if (options.ajaxSorting) {
    			var sorters = this.table.modules.sort.getSort();

    			sorters.forEach(function (item) {
    				delete item.column;
    			});

    			params[this.table.modules.page.paginationDataSentNames.sorters] = sorters;
    		}

    		//set filter data if defined
    		if (options.ajaxFiltering) {
    			var filters = this.table.modules.filter.getFilters(true, true);

    			params[this.table.modules.page.paginationDataSentNames.filters] = filters;
    		}

    		this.table.modules.ajax.setParams(params, true);
    	}

    	table.modules.ajax.sendRequest().then(function (data) {
    		_this15._setDataActual(data, true);
    	}).catch(function (e) {});
    };

    //choose the path to refresh data after a filter update
    RowManager.prototype.filterRefresh = function () {
    	var table = this.table,
    	    options = table.options,
    	    left = this.scrollLeft;

    	if (options.ajaxFiltering) {
    		if (options.pagination == "remote" && table.modExists("page")) {
    			table.modules.page.reset(true);
    			table.modules.page.setPage(1).then(function () {}).catch(function () {});
    		} else if (options.ajaxProgressiveLoad) {
    			table.modules.ajax.loadData().then(function () {}).catch(function () {});
    		} else {
    			//assume data is url, make ajax call to url to get data
    			this._genRemoteRequest();
    		}
    	} else {
    		this.refreshActiveData("filter");
    	}

    	this.scrollHorizontal(left);
    };

    //choose the path to refresh data after a sorter update
    RowManager.prototype.sorterRefresh = function (loadOrignalData) {
    	var table = this.table,
    	    options = this.table.options,
    	    left = this.scrollLeft;

    	if (options.ajaxSorting) {
    		if ((options.pagination == "remote" || options.progressiveLoad) && table.modExists("page")) {
    			table.modules.page.reset(true);
    			table.modules.page.setPage(1).then(function () {}).catch(function () {});
    		} else if (options.ajaxProgressiveLoad) {
    			table.modules.ajax.loadData().then(function () {}).catch(function () {});
    		} else {
    			//assume data is url, make ajax call to url to get data
    			this._genRemoteRequest();
    		}
    	} else {
    		this.refreshActiveData(loadOrignalData ? "filter" : "sort");
    	}

    	this.scrollHorizontal(left);
    };

    RowManager.prototype.scrollHorizontal = function (left) {
    	this.scrollLeft = left;
    	this.element.scrollLeft = left;

    	if (this.table.options.groupBy) {
    		this.table.modules.groupRows.scrollHeaders(left);
    	}

    	if (this.table.modExists("columnCalcs")) {
    		this.table.modules.columnCalcs.scrollHorizontal(left);
    	}
    };

    //set active data set
    RowManager.prototype.refreshActiveData = function (stage, skipStage, renderInPosition) {
    	var self = this,
    	    table = this.table,
    	    cascadeOrder = ["all", "filter", "sort", "display", "freeze", "group", "tree", "page"],
    	    displayIndex;

    	if (this.redrawBlock) {

    		if (!this.redrawBlockRestoreConfig || cascadeOrder.indexOf(stage) < cascadeOrder.indexOf(this.redrawBlockRestoreConfig.stage)) {
    			this.redrawBlockRestoreConfig = {
    				stage: stage,
    				skipStage: skipStage,
    				renderInPosition: renderInPosition
    			};
    		}

    		return;
    	} else {

    		if (self.table.modExists("edit")) {
    			self.table.modules.edit.cancelEdit();
    		}

    		if (!stage) {
    			stage = "all";
    		}

    		if (table.options.selectable && !table.options.selectablePersistence && table.modExists("selectRow")) {
    			table.modules.selectRow.deselectRows();
    		}

    		//cascade through data refresh stages
    		switch (stage) {
    			case "all":

    			case "filter":
    				if (!skipStage) {
    					if (table.modExists("filter")) {
    						self.setActiveRows(table.modules.filter.filter(self.rows));
    					} else {
    						self.setActiveRows(self.rows.slice(0));
    					}
    				} else {
    					skipStage = false;
    				}

    			case "sort":
    				if (!skipStage) {
    					if (table.modExists("sort")) {
    						table.modules.sort.sort(this.activeRows);
    					}
    				} else {
    					skipStage = false;
    				}

    				//regenerate row numbers for row number formatter if in use
    				this.regenerateRowNumbers();

    			//generic stage to allow for pipeline trigger after the data manipulation stage
    			case "display":
    				this.resetDisplayRows();

    			case "freeze":
    				if (!skipStage) {
    					if (this.table.modExists("frozenRows")) {
    						if (table.modules.frozenRows.isFrozen()) {
    							if (!table.modules.frozenRows.getDisplayIndex()) {
    								table.modules.frozenRows.setDisplayIndex(this.getNextDisplayIndex());
    							}

    							displayIndex = table.modules.frozenRows.getDisplayIndex();

    							displayIndex = self.setDisplayRows(table.modules.frozenRows.getRows(this.getDisplayRows(displayIndex - 1)), displayIndex);

    							if (displayIndex !== true) {
    								table.modules.frozenRows.setDisplayIndex(displayIndex);
    							}
    						}
    					}
    				} else {
    					skipStage = false;
    				}

    			case "group":
    				if (!skipStage) {
    					if (table.options.groupBy && table.modExists("groupRows")) {

    						if (!table.modules.groupRows.getDisplayIndex()) {
    							table.modules.groupRows.setDisplayIndex(this.getNextDisplayIndex());
    						}

    						displayIndex = table.modules.groupRows.getDisplayIndex();

    						displayIndex = self.setDisplayRows(table.modules.groupRows.getRows(this.getDisplayRows(displayIndex - 1)), displayIndex);

    						if (displayIndex !== true) {
    							table.modules.groupRows.setDisplayIndex(displayIndex);
    						}
    					}
    				} else {
    					skipStage = false;
    				}

    			case "tree":

    				if (!skipStage) {
    					if (table.options.dataTree && table.modExists("dataTree")) {
    						if (!table.modules.dataTree.getDisplayIndex()) {
    							table.modules.dataTree.setDisplayIndex(this.getNextDisplayIndex());
    						}

    						displayIndex = table.modules.dataTree.getDisplayIndex();

    						displayIndex = self.setDisplayRows(table.modules.dataTree.getRows(this.getDisplayRows(displayIndex - 1)), displayIndex);

    						if (displayIndex !== true) {
    							table.modules.dataTree.setDisplayIndex(displayIndex);
    						}
    					}
    				} else {
    					skipStage = false;
    				}

    				if (table.options.pagination && table.modExists("page") && !renderInPosition) {
    					if (table.modules.page.getMode() == "local") {
    						table.modules.page.reset();
    					}
    				}

    			case "page":
    				if (!skipStage) {
    					if (table.options.pagination && table.modExists("page")) {

    						if (!table.modules.page.getDisplayIndex()) {
    							table.modules.page.setDisplayIndex(this.getNextDisplayIndex());
    						}

    						displayIndex = table.modules.page.getDisplayIndex();

    						if (table.modules.page.getMode() == "local") {
    							table.modules.page.setMaxRows(this.getDisplayRows(displayIndex - 1).length);
    						}

    						displayIndex = self.setDisplayRows(table.modules.page.getRows(this.getDisplayRows(displayIndex - 1)), displayIndex);

    						if (displayIndex !== true) {
    							table.modules.page.setDisplayIndex(displayIndex);
    						}
    					}
    				} else {
    					skipStage = false;
    				}
    		}

    		if (Tabulator.prototype.helpers.elVisible(self.element)) {
    			if (renderInPosition) {
    				self.reRenderInPosition();
    			} else {

    				if (stage === "all" && this.table.options.virtualDomHoz) {
    					this.table.vdomHoz.dataChange();
    				}

    				self.renderTable();

    				if (table.options.layoutColumnsOnNewData) {
    					self.table.columnManager.redraw(true);
    				}
    			}
    		}

    		if (table.modExists("columnCalcs")) {
    			table.modules.columnCalcs.recalc(this.activeRows);
    		}
    	}
    };

    //regenerate row numbers for row number formatter if in use
    RowManager.prototype.regenerateRowNumbers = function () {
    	var _this16 = this;

    	if (this.rowNumColumn) {
    		this.activeRows.forEach(function (row) {
    			var cell = row.getCell(_this16.rowNumColumn);

    			if (cell) {
    				cell._generateContents();
    			}
    		});
    	}
    };

    RowManager.prototype.setActiveRows = function (activeRows) {
    	this.activeRows = activeRows;
    	this.activeRowsCount = this.activeRows.length;
    };

    //reset display rows array
    RowManager.prototype.resetDisplayRows = function () {
    	this.displayRows = [];

    	this.displayRows.push(this.activeRows.slice(0));

    	this.displayRowsCount = this.displayRows[0].length;

    	if (this.table.modExists("frozenRows")) {
    		this.table.modules.frozenRows.setDisplayIndex(0);
    	}

    	if (this.table.options.groupBy && this.table.modExists("groupRows")) {
    		this.table.modules.groupRows.setDisplayIndex(0);
    	}

    	if (this.table.options.pagination && this.table.modExists("page")) {
    		this.table.modules.page.setDisplayIndex(0);
    	}
    };

    RowManager.prototype.getNextDisplayIndex = function () {
    	return this.displayRows.length;
    };

    //set display row pipeline data
    RowManager.prototype.setDisplayRows = function (displayRows, index) {

    	var output = true;

    	if (index && typeof this.displayRows[index] != "undefined") {
    		this.displayRows[index] = displayRows;
    		output = true;
    	} else {
    		this.displayRows.push(displayRows);
    		output = index = this.displayRows.length - 1;
    	}

    	if (index == this.displayRows.length - 1) {
    		this.displayRowsCount = this.displayRows[this.displayRows.length - 1].length;
    	}

    	return output;
    };

    RowManager.prototype.getDisplayRows = function (index) {
    	if (typeof index == "undefined") {
    		return this.displayRows.length ? this.displayRows[this.displayRows.length - 1] : [];
    	} else {
    		return this.displayRows[index] || [];
    	}
    };

    RowManager.prototype.getVisibleRows = function (viewable) {
    	var topEdge = this.element.scrollTop,
    	    bottomEdge = this.element.clientHeight + topEdge,
    	    topFound = false,
    	    topRow = 0,
    	    bottomRow = 0,
    	    rows = this.getDisplayRows();

    	if (viewable) {

    		this.getDisplayRows();
    		for (var i = this.vDomTop; i <= this.vDomBottom; i++) {
    			if (rows[i]) {
    				if (!topFound) {
    					if (topEdge - rows[i].getElement().offsetTop >= 0) {
    						topRow = i;
    					} else {
    						topFound = true;

    						if (bottomEdge - rows[i].getElement().offsetTop >= 0) {
    							bottomRow = i;
    						} else {
    							break;
    						}
    					}
    				} else {
    					if (bottomEdge - rows[i].getElement().offsetTop >= 0) {
    						bottomRow = i;
    					} else {
    						break;
    					}
    				}
    			}
    		}
    	} else {
    		topRow = this.vDomTop;
    		bottomRow = this.vDomBottom;
    	}

    	return rows.slice(topRow, bottomRow + 1);
    };

    //repeat action accross display rows
    RowManager.prototype.displayRowIterator = function (callback) {
    	this.displayRows.forEach(callback);

    	this.displayRowsCount = this.displayRows[this.displayRows.length - 1].length;
    };

    //return only actual rows (not group headers etc)
    RowManager.prototype.getRows = function (active) {
    	var rows;

    	switch (active) {
    		case "active":
    			rows = this.activeRows;
    			break;

    		case "display":
    			rows = this.table.rowManager.getDisplayRows();
    			break;

    		case "visible":
    			rows = this.getVisibleRows(true);
    			break;

    		case "selected":
    			rows = this.table.modules.selectRow.selectedRows;
    			break;

    		default:
    			rows = this.rows;
    	}

    	return rows;
    };

    ///////////////// Table Rendering /////////////////

    //trigger rerender of table in current position
    RowManager.prototype.reRenderInPosition = function (callback) {
    	if (this.getRenderMode() == "virtual") {

    		if (this.redrawBlock) {
    			if (callback) {
    				callback();
    			} else {
    				this.redrawBlockRederInPosition = true;
    			}
    		} else {
    			var scrollTop = this.element.scrollTop;
    			var topRow = false;
    			var topOffset = false;

    			var left = this.scrollLeft;

    			var rows = this.getDisplayRows();

    			for (var i = this.vDomTop; i <= this.vDomBottom; i++) {

    				if (rows[i]) {
    					var diff = scrollTop - rows[i].getElement().offsetTop;

    					if (topOffset === false || Math.abs(diff) < topOffset) {
    						topOffset = diff;
    						topRow = i;
    					} else {
    						break;
    					}
    				}
    			}

    			if (callback) {
    				callback();
    			}

    			this._virtualRenderFill(topRow === false ? this.displayRowsCount - 1 : topRow, true, topOffset || 0);

    			this.scrollHorizontal(left);
    		}
    	} else {
    		this.renderTable();

    		if (callback) {
    			callback();
    		}
    	}
    };

    RowManager.prototype.setRenderMode = function () {

    	if (this.table.options.virtualDom) {

    		this.renderMode = "virtual";

    		if (this.table.element.clientHeight || this.table.options.height) {
    			this.fixedHeight = true;
    		} else {
    			this.fixedHeight = false;
    		}
    	} else {
    		this.renderMode = "classic";
    	}
    };

    RowManager.prototype.getRenderMode = function () {
    	return this.renderMode;
    };

    RowManager.prototype.renderTable = function () {

    	this.table.options.renderStarted.call(this.table);

    	this.element.scrollTop = 0;

    	switch (this.renderMode) {
    		case "classic":
    			this._simpleRender();
    			break;

    		case "virtual":
    			this._virtualRenderFill();
    			break;
    	}

    	if (this.firstRender) {
    		if (this.displayRowsCount) {
    			this.firstRender = false;
    			this.table.modules.layout.layout();
    		} else {
    			this.renderEmptyScroll();
    		}
    	}

    	if (this.table.modExists("frozenColumns")) {
    		this.table.modules.frozenColumns.layout();
    	}

    	if (!this.displayRowsCount) {
    		if (this.table.options.placeholder) {

    			this.table.options.placeholder.setAttribute("tabulator-render-mode", this.renderMode);

    			this.getElement().appendChild(this.table.options.placeholder);
    			this.table.options.placeholder.style.width = this.table.columnManager.getWidth() + "px";
    		}
    	}

    	this.table.options.renderComplete.call(this.table);
    };

    //simple render on heightless table
    RowManager.prototype._simpleRender = function () {
    	this._clearVirtualDom();

    	if (this.displayRowsCount) {
    		this.checkClassicModeGroupHeaderWidth();
    	} else {
    		this.renderEmptyScroll();
    	}
    };

    RowManager.prototype.checkClassicModeGroupHeaderWidth = function () {
    	var self = this,
    	    element = this.tableElement,
    	    onlyGroupHeaders = true;

    	self.getDisplayRows().forEach(function (row, index) {
    		self.styleRow(row, index);
    		element.appendChild(row.getElement());
    		row.initialize(true);

    		if (row.type !== "group") {
    			onlyGroupHeaders = false;
    		}
    	});

    	if (onlyGroupHeaders) {
    		element.style.minWidth = self.table.columnManager.getWidth() + "px";
    	} else {
    		element.style.minWidth = "";
    	}
    };

    //show scrollbars on empty table div
    RowManager.prototype.renderEmptyScroll = function () {
    	if (this.table.options.placeholder) {
    		this.tableElement.style.display = "none";
    	} else {
    		this.tableElement.style.minWidth = this.table.columnManager.getWidth() + "px";
    		// this.tableElement.style.minHeight = "1px";
    		// this.tableElement.style.visibility = "hidden";
    	}
    };

    RowManager.prototype._clearVirtualDom = function () {
    	var element = this.tableElement;

    	if (this.table.options.placeholder && this.table.options.placeholder.parentNode) {
    		this.table.options.placeholder.parentNode.removeChild(this.table.options.placeholder);
    	}

    	// element.children.detach();
    	while (element.firstChild) {
    		element.removeChild(element.firstChild);
    	}element.style.paddingTop = "";
    	element.style.paddingBottom = "";
    	element.style.minWidth = "";
    	element.style.minHeight = "";
    	element.style.display = "";
    	element.style.visibility = "";

    	this.scrollTop = 0;
    	this.scrollLeft = 0;
    	this.vDomTop = 0;
    	this.vDomBottom = 0;
    	this.vDomTopPad = 0;
    	this.vDomBottomPad = 0;
    };

    RowManager.prototype.styleRow = function (row, index) {
    	var rowEl = row.getElement();

    	if (index % 2) {
    		rowEl.classList.add("tabulator-row-even");
    		rowEl.classList.remove("tabulator-row-odd");
    	} else {
    		rowEl.classList.add("tabulator-row-odd");
    		rowEl.classList.remove("tabulator-row-even");
    	}
    };

    //full virtual render
    RowManager.prototype._virtualRenderFill = function (position, forceMove, offset) {
    	var self = this,
    	    element = self.tableElement,
    	    holder = self.element,
    	    topPad = 0,
    	    rowsHeight = 0,
    	    topPadHeight = 0,
    	    i = 0,
    	    onlyGroupHeaders = true,
    	    rows = self.getDisplayRows();

    	position = position || 0;

    	offset = offset || 0;

    	if (!position) {
    		self._clearVirtualDom();
    	} else {
    		while (element.firstChild) {
    			element.removeChild(element.firstChild);
    		} //check if position is too close to bottom of table
    		var heightOccupied = (self.displayRowsCount - position + 1) * self.vDomRowHeight;

    		if (heightOccupied < self.height) {
    			position -= Math.ceil((self.height - heightOccupied) / self.vDomRowHeight);

    			if (position < 0) {
    				position = 0;
    			}
    		}

    		//calculate initial pad
    		topPad = Math.min(Math.max(Math.floor(self.vDomWindowBuffer / self.vDomRowHeight), self.vDomWindowMinMarginRows), position);
    		position -= topPad;
    	}

    	if (self.displayRowsCount && Tabulator.prototype.helpers.elVisible(self.element)) {

    		self.vDomTop = position;

    		self.vDomBottom = position - 1;

    		while ((rowsHeight <= self.height + self.vDomWindowBuffer || i < self.vDomWindowMinTotalRows) && self.vDomBottom < self.displayRowsCount - 1) {
    			var index = self.vDomBottom + 1,
    			    row = rows[index],
    			    rowHeight = 0;

    			self.styleRow(row, index);

    			element.appendChild(row.getElement());

    			row.initialize();

    			if (!row.heightInitialized) {
    				row.normalizeHeight(true);
    			}

    			// if(!row.initialized){
    			// 	row.initialize(true);
    			// }else{
    			// 	if(!row.heightInitialized){
    			// 		row.normalizeHeight(true);
    			// 	}
    			// }

    			rowHeight = row.getHeight();

    			if (i < topPad) {
    				topPadHeight += rowHeight;
    			} else {
    				rowsHeight += rowHeight;
    			}

    			if (rowHeight > this.vDomWindowBuffer) {
    				this.vDomWindowBuffer = rowHeight * 2;
    			}

    			if (row.type !== "group") {
    				onlyGroupHeaders = false;
    			}

    			self.vDomBottom++;
    			i++;
    		}

    		if (!position) {
    			this.vDomTopPad = 0;
    			//adjust rowheight to match average of rendered elements
    			self.vDomRowHeight = Math.floor((rowsHeight + topPadHeight) / i);
    			self.vDomBottomPad = self.vDomRowHeight * (self.displayRowsCount - self.vDomBottom - 1);

    			self.vDomScrollHeight = topPadHeight + rowsHeight + self.vDomBottomPad - self.height;
    		} else {
    			self.vDomTopPad = !forceMove ? self.scrollTop - topPadHeight : self.vDomRowHeight * this.vDomTop + offset;
    			self.vDomBottomPad = self.vDomBottom == self.displayRowsCount - 1 ? 0 : Math.max(self.vDomScrollHeight - self.vDomTopPad - rowsHeight - topPadHeight, 0);
    		}

    		element.style.paddingTop = self.vDomTopPad + "px";
    		element.style.paddingBottom = self.vDomBottomPad + "px";

    		if (forceMove) {
    			this.scrollTop = self.vDomTopPad + topPadHeight + offset - (this.element.scrollWidth > this.element.clientWidth ? this.element.offsetHeight - this.element.clientHeight : 0);
    		}

    		this.scrollTop = Math.min(this.scrollTop, this.element.scrollHeight - this.height);

    		//adjust for horizontal scrollbar if present (and not at top of table)
    		if (this.element.scrollWidth > this.element.offsetWidth && forceMove) {
    			this.scrollTop += this.element.offsetHeight - this.element.clientHeight;
    		}

    		this.vDomScrollPosTop = this.scrollTop;
    		this.vDomScrollPosBottom = this.scrollTop;

    		holder.scrollTop = this.scrollTop;

    		element.style.minWidth = onlyGroupHeaders ? self.table.columnManager.getWidth() + "px" : "";

    		if (self.table.options.groupBy) {
    			if (self.table.modules.layout.getMode() != "fitDataFill" && self.displayRowsCount == self.table.modules.groupRows.countGroups()) {
    				self.tableElement.style.minWidth = self.table.columnManager.getWidth();
    			}
    		}
    	} else {
    		this.renderEmptyScroll();
    	}

    	if (!this.fixedHeight) {
    		this.adjustTableSize();
    	}
    };

    //handle vertical scrolling
    RowManager.prototype.scrollVertical = function (dir) {
    	var topDiff = this.scrollTop - this.vDomScrollPosTop;
    	var bottomDiff = this.scrollTop - this.vDomScrollPosBottom;
    	var margin = this.vDomWindowBuffer * 2;

    	if (-topDiff > margin || bottomDiff > margin) {
    		//if big scroll redraw table;
    		var left = this.scrollLeft;
    		this._virtualRenderFill(Math.floor(this.element.scrollTop / this.element.scrollHeight * this.displayRowsCount));
    		this.scrollHorizontal(left);
    	} else {

    		if (dir) {
    			//scrolling up
    			if (topDiff < 0) {

    				this._addTopRow(-topDiff);
    			}

    			if (bottomDiff < 0) {

    				//hide bottom row if needed
    				if (this.vDomScrollHeight - this.scrollTop > this.vDomWindowBuffer) {
    					this._removeBottomRow(-bottomDiff);
    				} else {
    					this.vDomScrollPosBottom = this.scrollTop;
    				}
    			}
    		} else {
    			//scrolling down
    			if (topDiff >= 0) {

    				//hide top row if needed
    				if (this.scrollTop > this.vDomWindowBuffer) {

    					this._removeTopRow(topDiff);
    				} else {
    					this.vDomScrollPosTop = this.scrollTop;
    				}
    			}

    			if (bottomDiff >= 0) {

    				this._addBottomRow(bottomDiff);
    			}
    		}
    	}
    };

    RowManager.prototype._addTopRow = function (topDiff) {
    	var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    	var table = this.tableElement,
    	    rows = this.getDisplayRows();

    	if (this.vDomTop) {
    		var index = this.vDomTop - 1,
    		    topRow = rows[index],
    		    topRowHeight = topRow.getHeight() || this.vDomRowHeight;

    		//hide top row if needed
    		if (topDiff >= topRowHeight) {
    			this.styleRow(topRow, index);
    			table.insertBefore(topRow.getElement(), table.firstChild);
    			if (!topRow.initialized || !topRow.heightInitialized) {
    				this.vDomTopNewRows.push(topRow);

    				if (!topRow.heightInitialized) {
    					topRow.clearCellHeight();
    				}
    			}
    			topRow.initialize();

    			this.vDomTopPad -= topRowHeight;

    			if (this.vDomTopPad < 0) {
    				this.vDomTopPad = index * this.vDomRowHeight;
    			}

    			if (!index) {
    				this.vDomTopPad = 0;
    			}

    			table.style.paddingTop = this.vDomTopPad + "px";
    			this.vDomScrollPosTop -= topRowHeight;
    			this.vDomTop--;
    		}

    		topDiff = -(this.scrollTop - this.vDomScrollPosTop);

    		if (topRow.getHeight() > this.vDomWindowBuffer) {
    			this.vDomWindowBuffer = topRow.getHeight() * 2;
    		}

    		if (i < this.vDomMaxRenderChain && this.vDomTop && topDiff >= (rows[this.vDomTop - 1].getHeight() || this.vDomRowHeight)) {
    			this._addTopRow(topDiff, i + 1);
    		} else {
    			this._quickNormalizeRowHeight(this.vDomTopNewRows);
    		}
    	}
    };

    RowManager.prototype._removeTopRow = function (topDiff) {
    	var table = this.tableElement,
    	    topRow = this.getDisplayRows()[this.vDomTop],
    	    topRowHeight = topRow.getHeight() || this.vDomRowHeight;

    	if (topDiff >= topRowHeight) {

    		var rowEl = topRow.getElement();
    		rowEl.parentNode.removeChild(rowEl);

    		this.vDomTopPad += topRowHeight;
    		table.style.paddingTop = this.vDomTopPad + "px";
    		this.vDomScrollPosTop += this.vDomTop ? topRowHeight : topRowHeight + this.vDomWindowBuffer;
    		this.vDomTop++;

    		topDiff = this.scrollTop - this.vDomScrollPosTop;

    		this._removeTopRow(topDiff);
    	}
    };

    RowManager.prototype._addBottomRow = function (bottomDiff) {
    	var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    	var table = this.tableElement,
    	    rows = this.getDisplayRows();

    	if (this.vDomBottom < this.displayRowsCount - 1) {
    		var index = this.vDomBottom + 1,
    		    bottomRow = rows[index],
    		    bottomRowHeight = bottomRow.getHeight() || this.vDomRowHeight;

    		//hide bottom row if needed
    		if (bottomDiff >= bottomRowHeight) {
    			this.styleRow(bottomRow, index);
    			table.appendChild(bottomRow.getElement());

    			if (!bottomRow.initialized || !bottomRow.heightInitialized) {
    				this.vDomBottomNewRows.push(bottomRow);

    				if (!bottomRow.heightInitialized) {
    					bottomRow.clearCellHeight();
    				}
    			}

    			bottomRow.initialize();

    			this.vDomBottomPad -= bottomRowHeight;

    			if (this.vDomBottomPad < 0 || index == this.displayRowsCount - 1) {
    				this.vDomBottomPad = 0;
    			}

    			table.style.paddingBottom = this.vDomBottomPad + "px";
    			this.vDomScrollPosBottom += bottomRowHeight;
    			this.vDomBottom++;
    		}

    		bottomDiff = this.scrollTop - this.vDomScrollPosBottom;

    		if (bottomRow.getHeight() > this.vDomWindowBuffer) {
    			this.vDomWindowBuffer = bottomRow.getHeight() * 2;
    		}

    		if (i < this.vDomMaxRenderChain && this.vDomBottom < this.displayRowsCount - 1 && bottomDiff >= (rows[this.vDomBottom + 1].getHeight() || this.vDomRowHeight)) {
    			this._addBottomRow(bottomDiff, i + 1);
    		} else {
    			this._quickNormalizeRowHeight(this.vDomBottomNewRows);
    		}
    	}
    };

    RowManager.prototype._removeBottomRow = function (bottomDiff) {
    	var table = this.tableElement,
    	    bottomRow = this.getDisplayRows()[this.vDomBottom],
    	    bottomRowHeight = bottomRow.getHeight() || this.vDomRowHeight;

    	if (bottomDiff >= bottomRowHeight) {

    		var rowEl = bottomRow.getElement();

    		if (rowEl.parentNode) {
    			rowEl.parentNode.removeChild(rowEl);
    		}

    		this.vDomBottomPad += bottomRowHeight;

    		if (this.vDomBottomPad < 0) {
    			this.vDomBottomPad = 0;
    		}

    		table.style.paddingBottom = this.vDomBottomPad + "px";
    		this.vDomScrollPosBottom -= bottomRowHeight;
    		this.vDomBottom--;

    		bottomDiff = -(this.scrollTop - this.vDomScrollPosBottom);

    		this._removeBottomRow(bottomDiff);
    	}
    };

    RowManager.prototype._quickNormalizeRowHeight = function (rows) {
    	rows.forEach(function (row) {
    		row.calcHeight();
    	});

    	rows.forEach(function (row) {
    		row.setCellHeight();
    	});

    	rows.length = 0;
    };

    //normalize height of active rows
    RowManager.prototype.normalizeHeight = function () {
    	this.activeRows.forEach(function (row) {
    		row.normalizeHeight();
    	});
    };

    //adjust the height of the table holder to fit in the Tabulator element
    RowManager.prototype.adjustTableSize = function () {
    	var initialHeight = this.element.clientHeight,
    	    modExists;

    	if (this.renderMode === "virtual") {

    		var otherHeight = Math.floor(this.columnManager.getElement().getBoundingClientRect().height + (this.table.footerManager && this.table.footerManager.active && !this.table.footerManager.external ? this.table.footerManager.getElement().getBoundingClientRect().height : 0));

    		if (this.fixedHeight) {
    			this.element.style.minHeight = "calc(100% - " + otherHeight + "px)";
    			this.element.style.height = "calc(100% - " + otherHeight + "px)";
    			this.element.style.maxHeight = "calc(100% - " + otherHeight + "px)";
    		} else {
    			this.element.style.height = "";
    			this.element.style.height = this.table.element.clientHeight - otherHeight + "px";
    			this.element.scrollTop = this.scrollTop;
    		}

    		this.height = this.element.clientHeight;
    		this.vDomWindowBuffer = this.table.options.virtualDomBuffer || this.height;

    		//check if the table has changed size when dealing with variable height tables
    		if (!this.fixedHeight && initialHeight != this.element.clientHeight) {
    			modExists = this.table.modExists("resizeTable");

    			if (modExists && !this.table.modules.resizeTable.autoResize || !modExists) {
    				this.redraw();
    			}
    		}
    	}
    };

    //renitialize all rows
    RowManager.prototype.reinitialize = function () {
    	this.rows.forEach(function (row) {
    		row.reinitialize(true);
    	});
    };

    //prevent table from being redrawn
    RowManager.prototype.blockRedraw = function () {
    	this.redrawBlock = true;
    	this.redrawBlockRestoreConfig = false;
    };

    //restore table redrawing
    RowManager.prototype.restoreRedraw = function () {
    	this.redrawBlock = false;

    	if (this.redrawBlockRestoreConfig) {
    		this.refreshActiveData(this.redrawBlockRestoreConfig.stage, this.redrawBlockRestoreConfig.skipStage, this.redrawBlockRestoreConfig.renderInPosition);

    		this.redrawBlockRestoreConfig = false;
    	} else {
    		if (this.redrawBlockRederInPosition) {
    			this.reRenderInPosition();
    		}
    	}

    	this.redrawBlockRederInPosition = false;
    };

    //redraw table
    RowManager.prototype.redraw = function (force) {
    	var left = this.scrollLeft;

    	this.adjustTableSize();

    	this.table.tableWidth = this.table.element.clientWidth;

    	if (!force) {
    		if (this.renderMode == "classic") {

    			if (this.table.options.groupBy) {
    				this.refreshActiveData("group", false, false);
    			} else {
    				this._simpleRender();
    			}
    		} else {
    			this.reRenderInPosition();
    			this.scrollHorizontal(left);
    		}

    		if (!this.displayRowsCount) {
    			if (this.table.options.placeholder) {
    				this.getElement().appendChild(this.table.options.placeholder);
    			}
    		}
    	} else {
    		this.renderTable();
    	}
    };

    RowManager.prototype.resetScroll = function () {
    	this.element.scrollLeft = 0;
    	this.element.scrollTop = 0;

    	if (this.table.browser === "ie") {
    		var event = document.createEvent("Event");
    		event.initEvent("scroll", false, true);
    		this.element.dispatchEvent(event);
    	} else {
    		this.element.dispatchEvent(new Event('scroll'));
    	}
    };

    var VDomHoz = function VDomHoz(table) {
    	this.table = table;

    	this.element = this.table.rowManager.tableElement;
    	this.holderEl = this.table.rowManager.element;

    	this.leftCol = 0;
    	this.rightCol = 0;
    	this.scrollLeft = 0;

    	this.vDomScrollPosLeft = 0;
    	this.vDomScrollPosRight = 0;

    	this.vDomPadLeft = 0;
    	this.vDomPadRight = 0;

    	this.fitDataColAvg = 0;

    	this.window = 200; //pixel margin to make column visible before it is shown on screen

    	this.initialized = false;

    	this.columns = [];

    	if (this.compatabilityCheck()) {
    		this.initialize();
    	}
    };

    VDomHoz.prototype.compatabilityCheck = function () {
    	var options = this.table.options,
    	    frozen = false,
    	    ok = true;

    	if (options.layout == "fitDataTable") {
    		console.warn("Horizontal Vitrual DOM is not compatible with fitDataTable layout mode");
    		ok = false;
    	}

    	if (options.responsiveLayout) {
    		console.warn("Horizontal Vitrual DOM is not compatible with responsive columns");
    		ok = false;
    	}

    	if (this.table.rtl) {
    		console.warn("Horizontal Vitrual DOM is not currently compatible with RTL text direction");
    		ok = false;
    	}

    	// if(options.rowFormatter){
    	// 	console.warn("Horizontal Vitrual DOM is not compatible with row formatters");
    	// 	ok = false;
    	// }

    	if (options.columns) {
    		frozen = options.columns.find(function (col) {
    			return col.frozen;
    		});

    		if (frozen) {
    			console.warn("Horizontal Vitrual DOM is not compatible with frozen columns");
    			ok = false;
    		}
    	}

    	if (!ok) {
    		options.virtualDomHoz = false;
    	}

    	return ok;
    };

    VDomHoz.prototype.initialize = function () {
    	var _this17 = this;

    	this.holderEl.addEventListener("scroll", function () {
    		var left = _this17.holderEl.scrollLeft;

    		if (_this17.scrollLeft != left) {
    			_this17.scrollLeft = left;
    			_this17.scroll(left - (_this17.vDomScrollPosLeft + _this17.window));
    		}
    	});
    };

    VDomHoz.prototype.deinitialize = function () {
    	this.initialized = false;
    };

    VDomHoz.prototype.clear = function () {
    	this.columns = [];

    	this.leftCol = -1;
    	this.rightCol = 0;

    	this.vDomScrollPosLeft = 0;
    	this.vDomScrollPosRight = 0;
    	this.vDomPadLeft = 0;
    	this.vDomPadRight = 0;
    };

    VDomHoz.prototype.dataChange = function () {
    	var change = false,
    	    collsWidth = 0,
    	    colEnd = 0,
    	    group,
    	    row,
    	    rowEl;

    	if (this.table.options.layout === "fitData") {
    		this.table.columnManager.columnsByIndex.forEach(function (column) {
    			if (!column.definition.width && column.visible) {
    				change = true;
    			}
    		});

    		if (change) {
    			if (change && this.table.rowManager.getDisplayRows().length) {
    				// this.table.vdomHoz.deinitialize();

    				this.vDomScrollPosRight = this.scrollLeft + this.holderEl.clientWidth + this.window;

    				if (this.table.options.groupBy) {
    					group = this.table.modules.groupRows.getGroups(false)[0];

    					row = group.getRows(false)[0];
    				} else {
    					row = this.table.rowManager.getDisplayRows()[0];
    				}

    				if (row) {

    					rowEl = row.getElement();

    					row.generateCells();

    					this.element.appendChild(rowEl);

    					for (var colEnd = 0; colEnd < row.cells.length; colEnd++) {
    						var cell = row.cells[colEnd];
    						rowEl.appendChild(cell.getElement());

    						cell.column.reinitializeWidth();

    						collsWidth += cell.column.getWidth();

    						if (collsWidth > this.vDomScrollPosRight) {
    							break;
    						}
    					}

    					rowEl.parentNode.removeChild(rowEl);

    					this.fitDataColAvg = Math.floor(collsWidth / (colEnd + 1));

    					for (colEnd; colEnd < this.table.columnManager.columnsByIndex.length; colEnd++) {
    						this.table.columnManager.columnsByIndex[colEnd].setWidth(this.fitDataColAvg);
    					}

    					this.reinitialize(false, true);
    				}
    			}
    		}
    	} else {
    		if (this.table.options.layout === "fitColumns") {
    			this.table.modules.layout.layout();
    			this.table.vdomHoz.reinitialize(false, true);
    		}
    	}
    };

    VDomHoz.prototype.fitDataLayoutOverride = function () {
    	for (var _i5 = this.leftCol; _i5 <= this.rightCol; _i5++) {
    		this.columns[_i5].reinitializeWidth();
    	}
    };

    VDomHoz.prototype.reinitialize = function (update, blockRedraw) {
    	var _this18 = this;

    	var old = {
    		cols: this.columns,
    		leftCol: this.leftCol,
    		rightCol: this.rightCol
    	};

    	if (update && !this.initialized) {
    		return;
    	}

    	this.clear();

    	this.scrollLeft = this.holderEl.scrollLeft;

    	this.vDomScrollPosLeft = this.scrollLeft - this.window;
    	this.vDomScrollPosRight = this.scrollLeft + this.holderEl.clientWidth + this.window;

    	var colPos = 0;

    	this.table.columnManager.columnsByIndex.forEach(function (column) {
    		var config = {};

    		if (column.visible) {
    			var width = column.getWidth();

    			config.leftPos = colPos;
    			config.rightPos = colPos + width;

    			if (colPos + width > _this18.vDomScrollPosLeft && colPos < _this18.vDomScrollPosRight) {
    				//column is visible

    				if (_this18.leftCol == -1) {
    					_this18.leftCol = _this18.columns.length;
    					_this18.vDomPadLeft = colPos;
    				}

    				_this18.rightCol = _this18.columns.length;
    			} else {
    				// column is hidden
    				if (_this18.leftCol !== -1) {
    					_this18.vDomPadRight += width;
    				}
    			}

    			_this18.columns.push(column);

    			column.modules.vdomHoz = config;

    			colPos += width;
    		}
    	});

    	this.element.style.paddingLeft = this.vDomPadLeft + "px";
    	this.element.style.paddingRight = this.vDomPadRight + "px";

    	this.initialized = true;

    	if (!blockRedraw) {
    		if (!update || this.reinitChanged(old)) {
    			this.renitializeRows();
    		}
    	}

    	this.holderEl.scrollLeft = this.scrollLeft;
    };

    VDomHoz.prototype.reinitChanged = function (old) {
    	var _this19 = this;

    	var match = true;

    	if (old.cols.length !== this.columns.length || old.leftCol !== this.leftCol || old.rightCol !== this.rightCol) {
    		return true;
    	}

    	old.cols.forEach(function (col, i) {
    		if (col !== _this19.columns[i]) {
    			match = false;
    		}
    	});

    	return !match;
    };

    VDomHoz.prototype.renitializeRows = function () {
    	var _this20 = this;

    	var rows = this.table.rowManager.getVisibleRows();
    	rows.forEach(function (row) {
    		_this20.reinitializeRow(row, true);
    	});
    };

    VDomHoz.prototype.scroll = function (diff) {
    	this.vDomScrollPosLeft += diff;
    	this.vDomScrollPosRight += diff;

    	if (diff > this.holderEl.clientWidth * .8) {
    		this.reinitialize();
    	} else {
    		if (diff > 0) {
    			//scroll right
    			this.addColRight();
    			this.removeColLeft();
    		} else {
    			//scroll left
    			this.addColLeft();
    			this.removeColRight();
    		}
    	}
    };

    VDomHoz.prototype.colPositionAdjust = function (start, end, diff) {
    	for (var _i6 = start; _i6 < end; _i6++) {
    		var column = this.columns[_i6];

    		column.modules.vdomHoz.leftPos -= diff;
    		column.modules.vdomHoz.rightPos -= diff;
    	}
    };

    VDomHoz.prototype.addColRight = function () {
    	var column = this.columns[this.rightCol + 1],
    	    rows,
    	    oldWidth,
    	    widthDiff;

    	if (column && column.modules.vdomHoz.leftPos <= this.vDomScrollPosRight) {

    		rows = this.table.rowManager.getVisibleRows();

    		rows.forEach(function (row) {
    			if (row.type !== "group") {
    				var cell = row.getCell(column);
    				row.getElement().appendChild(cell.getElement());
    				cell.cellRendered();
    			}
    		});

    		if (this.fitDataColAvg) {

    			oldWidth = column.getWidth();

    			if (oldWidth === this.fitDataColAvg) {
    				column.reinitializeWidth();

    				widthDiff = oldWidth - column.getWidth();

    				if (widthDiff) {
    					column.modules.vdomHoz.rightPos -= widthDiff;
    					this.colPositionAdjust(this.rightCol + 1, this.columns.length, widthDiff);
    				}
    			}
    		}

    		this.rightCol++;

    		if (this.rightCol >= this.columns.length - 1) {
    			this.vDomPadRight = 0;
    		} else {
    			this.vDomPadRight -= column.getWidth();
    		}

    		this.element.style.paddingRight = this.vDomPadRight + "px";

    		this.addColRight();
    	}
    };

    VDomHoz.prototype.addColLeft = function () {
    	var column = this.columns[this.leftCol - 1],
    	    rows;

    	if (column && column.modules.vdomHoz.rightPos >= this.vDomScrollPosLeft) {
    		var rows = this.table.rowManager.getVisibleRows();

    		rows.forEach(function (row) {
    			if (row.type !== "group") {
    				var cell = row.getCell(column);
    				row.getElement().prepend(cell.getElement());
    				cell.cellRendered();
    			}
    		});

    		if (!this.leftCol) {
    			this.vDomPadLeft = 0;
    		} else {
    			this.vDomPadLeft -= column.getWidth();
    		}

    		this.element.style.paddingLeft = this.vDomPadLeft + "px";

    		this.leftCol--;

    		this.addColLeft();
    	}
    };

    VDomHoz.prototype.removeColRight = function (column) {
    	var column = this.columns[this.rightCol],
    	    rows;

    	if (column && column.modules.vdomHoz.leftPos > this.vDomScrollPosRight) {
    		rows = this.table.rowManager.getVisibleRows();

    		column.modules.vdomHoz.visible = false;

    		rows.forEach(function (row) {
    			if (row.type !== "group") {
    				var cell = row.getCell(column);
    				row.getElement().removeChild(cell.getElement());
    			}
    		});

    		this.vDomPadRight += column.getWidth();
    		this.element.style.paddingRight = this.vDomPadRight + "px";

    		this.rightCol--;

    		this.removeColRight();
    	}
    };

    VDomHoz.prototype.removeColLeft = function () {
    	var column = this.columns[this.leftCol],
    	    rows;

    	if (column && column.modules.vdomHoz.rightPos < this.vDomScrollPosLeft) {

    		rows = this.table.rowManager.getVisibleRows();

    		rows.forEach(function (row) {
    			if (row.type !== "group") {
    				var cell = row.getCell(column);
    				row.getElement().removeChild(cell.getElement());
    			}
    		});

    		this.vDomPadLeft += column.getWidth();
    		this.element.style.paddingLeft = this.vDomPadLeft + "px";

    		this.leftCol++;

    		this.removeColLeft();
    	}
    };

    VDomHoz.prototype.initializeRow = function (row) {
    	if (row.type !== "group") {
    		row.modules.vdomHoz = {
    			leftCol: this.leftCol,
    			rightCol: this.rightCol
    		};

    		for (var _i7 = this.leftCol; _i7 <= this.rightCol; _i7++) {
    			var column = this.columns[_i7];

    			if (column && column.visible) {
    				var cell = row.getCell(column);

    				row.getElement().appendChild(cell.getElement());
    				cell.cellRendered();
    			}
    		}
    	}
    };

    VDomHoz.prototype.reinitializeRow = function (row, force) {
    	if (row.type !== "group") {
    		if (force || !row.modules.vdomHoz || row.modules.vdomHoz.leftCol !== this.leftCol || row.modules.vdomHoz.rightCol !== this.rightCol) {
    			var rowEl = row.getElement();
    			while (rowEl.firstChild) {
    				rowEl.removeChild(rowEl.firstChild);
    			}this.initializeRow(row);
    		}
    	}
    };
    //public row object
    var RowComponent = function RowComponent(row) {
    	this._row = row;
    };

    RowComponent.prototype.getData = function (transform) {
    	return this._row.getData(transform);
    };

    RowComponent.prototype.getElement = function () {
    	return this._row.getElement();
    };

    RowComponent.prototype.getCells = function () {
    	var cells = [];

    	this._row.getCells().forEach(function (cell) {
    		cells.push(cell.getComponent());
    	});

    	return cells;
    };

    RowComponent.prototype.getCell = function (column) {
    	var cell = this._row.getCell(column);
    	return cell ? cell.getComponent() : false;
    };

    RowComponent.prototype.getIndex = function () {
    	return this._row.getData("data")[this._row.table.options.index];
    };

    RowComponent.prototype.getPosition = function (active) {
    	return this._row.table.rowManager.getRowPosition(this._row, active);
    };

    RowComponent.prototype.delete = function () {
    	return this._row.delete();
    };

    RowComponent.prototype.scrollTo = function () {
    	return this._row.table.rowManager.scrollToRow(this._row);
    };

    RowComponent.prototype.pageTo = function () {
    	if (this._row.table.modExists("page", true)) {
    		return this._row.table.modules.page.setPageToRow(this._row);
    	}
    };

    RowComponent.prototype.move = function (to, after) {
    	this._row.moveToRow(to, after);
    };

    RowComponent.prototype.update = function (data) {
    	return this._row.updateData(data);
    };

    RowComponent.prototype.normalizeHeight = function () {
    	this._row.normalizeHeight(true);
    };

    RowComponent.prototype.select = function () {
    	this._row.table.modules.selectRow.selectRows(this._row);
    };

    RowComponent.prototype.deselect = function () {
    	this._row.table.modules.selectRow.deselectRows(this._row);
    };

    RowComponent.prototype.toggleSelect = function () {
    	this._row.table.modules.selectRow.toggleRow(this._row);
    };

    RowComponent.prototype.isSelected = function () {
    	return this._row.table.modules.selectRow.isRowSelected(this._row);
    };

    RowComponent.prototype._getSelf = function () {
    	return this._row;
    };

    RowComponent.prototype.validate = function () {
    	return this._row.validate();
    };

    RowComponent.prototype.freeze = function () {
    	if (this._row.table.modExists("frozenRows", true)) {
    		this._row.table.modules.frozenRows.freezeRow(this._row);
    	}
    };

    RowComponent.prototype.unfreeze = function () {
    	if (this._row.table.modExists("frozenRows", true)) {
    		this._row.table.modules.frozenRows.unfreezeRow(this._row);
    	}
    };

    RowComponent.prototype.isFrozen = function () {
    	if (this._row.table.modExists("frozenRows", true)) {
    		var index = this._row.table.modules.frozenRows.rows.indexOf(this._row);
    		return index > -1;
    	}

    	return false;
    };

    RowComponent.prototype.treeCollapse = function () {
    	if (this._row.table.modExists("dataTree", true)) {
    		this._row.table.modules.dataTree.collapseRow(this._row);
    	}
    };

    RowComponent.prototype.treeExpand = function () {
    	if (this._row.table.modExists("dataTree", true)) {
    		this._row.table.modules.dataTree.expandRow(this._row);
    	}
    };

    RowComponent.prototype.treeToggle = function () {
    	if (this._row.table.modExists("dataTree", true)) {
    		this._row.table.modules.dataTree.toggleRow(this._row);
    	}
    };

    RowComponent.prototype.getTreeParent = function () {
    	if (this._row.table.modExists("dataTree", true)) {
    		return this._row.table.modules.dataTree.getTreeParent(this._row);
    	}

    	return false;
    };

    RowComponent.prototype.getTreeChildren = function () {
    	if (this._row.table.modExists("dataTree", true)) {
    		return this._row.table.modules.dataTree.getTreeChildren(this._row, true);
    	}

    	return false;
    };

    RowComponent.prototype.addTreeChild = function (data, pos, index) {
    	if (this._row.table.modExists("dataTree", true)) {
    		return this._row.table.modules.dataTree.addTreeChildRow(this._row, data, pos, index);
    	}

    	return false;
    };

    RowComponent.prototype.reformat = function () {
    	return this._row.reinitialize();
    };

    RowComponent.prototype.getGroup = function () {
    	return this._row.getGroup().getComponent();
    };

    RowComponent.prototype.getTable = function () {
    	return this._row.table;
    };

    RowComponent.prototype.getNextRow = function () {
    	var row = this._row.nextRow();
    	return row ? row.getComponent() : row;
    };

    RowComponent.prototype.getPrevRow = function () {
    	var row = this._row.prevRow();
    	return row ? row.getComponent() : row;
    };

    var Row = function Row(data, parent) {
    	var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "row";

    	this.table = parent.table;
    	this.parent = parent;
    	this.data = {};
    	this.type = type; //type of element
    	this.element = false;
    	this.modules = {}; //hold module variables;
    	this.cells = [];
    	this.height = 0; //hold element height
    	this.heightStyled = ""; //hold element height prestyled to improve render efficiency
    	this.manualHeight = false; //user has manually set row height
    	this.outerHeight = 0; //holde lements outer height
    	this.initialized = false; //element has been rendered
    	this.heightInitialized = false; //element has resized cells to fit

    	this.component = null;

    	this.created = false;

    	this.setData(data);
    };

    Row.prototype.create = function () {
    	if (!this.created) {
    		this.created = true;
    		this.generateElement();
    	}
    };

    Row.prototype.createElement = function () {
    	var el = document.createElement("div");

    	el.classList.add("tabulator-row");
    	el.setAttribute("role", "row");

    	this.element = el;
    };

    Row.prototype.getElement = function () {
    	this.create();
    	return this.element;
    };

    Row.prototype.detachElement = function () {
    	if (this.element && this.element.parentNode) {
    		this.element.parentNode.removeChild(this.element);
    	}
    };

    Row.prototype.generateElement = function () {
    	var self = this,
    	    dblTap,
    	    tapHold,
    	    tap;

    	this.createElement();

    	//set row selection characteristics
    	if (self.table.options.selectable !== false && self.table.modExists("selectRow")) {
    		self.table.modules.selectRow.initializeRow(this);
    	}

    	//setup movable rows
    	if (self.table.options.movableRows !== false && self.table.modExists("moveRow")) {
    		self.table.modules.moveRow.initializeRow(this);
    	}

    	//setup data tree
    	if (self.table.options.dataTree !== false && self.table.modExists("dataTree")) {
    		self.table.modules.dataTree.initializeRow(this);
    	}

    	//setup column colapse container
    	if (self.table.options.responsiveLayout === "collapse" && self.table.modExists("responsiveLayout")) {
    		self.table.modules.responsiveLayout.initializeRow(this);
    	}

    	//set column menu
    	if ((self.table.options.rowContextMenu || self.table.options.rowClickMenu) && this.table.modExists("menu")) {
    		self.table.modules.menu.initializeRow(this);
    	}

    	//handle row click events
    	if (self.table.options.rowClick) {
    		self.element.addEventListener("click", function (e) {
    			self.table.options.rowClick(e, self.getComponent());
    		});
    	}

    	if (self.table.options.rowDblClick) {
    		self.element.addEventListener("dblclick", function (e) {
    			self.table.options.rowDblClick(e, self.getComponent());
    		});
    	}

    	if (self.table.options.rowContext) {
    		self.element.addEventListener("contextmenu", function (e) {
    			self.table.options.rowContext(e, self.getComponent());
    		});
    	}

    	//handle mouse events
    	if (self.table.options.rowMouseEnter) {
    		self.element.addEventListener("mouseenter", function (e) {
    			self.table.options.rowMouseEnter(e, self.getComponent());
    		});
    	}

    	if (self.table.options.rowMouseLeave) {
    		self.element.addEventListener("mouseleave", function (e) {
    			self.table.options.rowMouseLeave(e, self.getComponent());
    		});
    	}

    	if (self.table.options.rowMouseOver) {
    		self.element.addEventListener("mouseover", function (e) {
    			self.table.options.rowMouseOver(e, self.getComponent());
    		});
    	}

    	if (self.table.options.rowMouseOut) {
    		self.element.addEventListener("mouseout", function (e) {
    			self.table.options.rowMouseOut(e, self.getComponent());
    		});
    	}

    	if (self.table.options.rowMouseMove) {
    		self.element.addEventListener("mousemove", function (e) {
    			self.table.options.rowMouseMove(e, self.getComponent());
    		});
    	}

    	if (self.table.options.rowTap) {

    		tap = false;

    		self.element.addEventListener("touchstart", function (e) {
    			tap = true;
    		}, { passive: true });

    		self.element.addEventListener("touchend", function (e) {
    			if (tap) {
    				self.table.options.rowTap(e, self.getComponent());
    			}

    			tap = false;
    		});
    	}

    	if (self.table.options.rowDblTap) {

    		dblTap = null;

    		self.element.addEventListener("touchend", function (e) {

    			if (dblTap) {
    				clearTimeout(dblTap);
    				dblTap = null;

    				self.table.options.rowDblTap(e, self.getComponent());
    			} else {

    				dblTap = setTimeout(function () {
    					clearTimeout(dblTap);
    					dblTap = null;
    				}, 300);
    			}
    		});
    	}

    	if (self.table.options.rowTapHold) {

    		tapHold = null;

    		self.element.addEventListener("touchstart", function (e) {
    			clearTimeout(tapHold);

    			tapHold = setTimeout(function () {
    				clearTimeout(tapHold);
    				tapHold = null;
    				tap = false;
    				self.table.options.rowTapHold(e, self.getComponent());
    			}, 1000);
    		}, { passive: true });

    		self.element.addEventListener("touchend", function (e) {
    			clearTimeout(tapHold);
    			tapHold = null;
    		});
    	}
    };

    Row.prototype.generateCells = function () {
    	this.cells = this.table.columnManager.generateCells(this);
    };

    //functions to setup on first render
    Row.prototype.initialize = function (force) {
    	var _this21 = this;

    	this.create();

    	if (!this.initialized || force) {

    		this.deleteCells();

    		while (this.element.firstChild) {
    			this.element.removeChild(this.element.firstChild);
    		} //handle frozen cells
    		if (this.table.modExists("frozenColumns")) {
    			this.table.modules.frozenColumns.layoutRow(this);
    		}

    		this.generateCells();

    		if (this.table.options.virtualDomHoz && this.table.vdomHoz.initialized) {
    			this.table.vdomHoz.initializeRow(this);
    		} else {
    			this.cells.forEach(function (cell) {
    				_this21.element.appendChild(cell.getElement());
    				cell.cellRendered();
    			});
    		}

    		if (force) {
    			this.normalizeHeight();
    		}

    		//setup movable rows
    		if (this.table.options.dataTree && this.table.modExists("dataTree")) {
    			this.table.modules.dataTree.layoutRow(this);
    		}

    		//setup column colapse container
    		if (this.table.options.responsiveLayout === "collapse" && this.table.modExists("responsiveLayout")) {
    			this.table.modules.responsiveLayout.layoutRow(this);
    		}

    		if (this.table.options.rowFormatter) {
    			this.table.options.rowFormatter(this.getComponent());
    		}

    		//set resizable handles
    		if (this.table.options.resizableRows && this.table.modExists("resizeRows")) {
    			this.table.modules.resizeRows.initializeRow(this);
    		}

    		this.initialized = true;
    	} else {
    		if (this.table.options.virtualDomHoz) {
    			this.table.vdomHoz.reinitializeRow(this);
    		}
    	}
    };

    Row.prototype.reinitializeHeight = function () {
    	this.heightInitialized = false;

    	if (this.element && this.element.offsetParent !== null) {
    		this.normalizeHeight(true);
    	}
    };

    Row.prototype.reinitialize = function (children) {
    	this.initialized = false;
    	this.heightInitialized = false;

    	if (!this.manualHeight) {
    		this.height = 0;
    		this.heightStyled = "";
    	}

    	if (this.element && this.element.offsetParent !== null) {
    		this.initialize(true);
    	}

    	if (this.table.options.dataTree && this.table.modExists("dataTree", true)) {
    		this.table.modules.dataTree.getTreeChildren(this, false, true).forEach(function (child) {
    			child.reinitialize(true);
    		});
    	}
    };

    //get heights when doing bulk row style calcs in virtual DOM
    Row.prototype.calcHeight = function (force) {

    	var maxHeight = 0,
    	    minHeight = this.table.options.resizableRows ? this.element.clientHeight : 0;

    	this.cells.forEach(function (cell) {
    		var height = cell.getHeight();
    		if (height > maxHeight) {
    			maxHeight = height;
    		}
    	});

    	if (force) {
    		this.height = Math.max(maxHeight, minHeight);
    	} else {
    		this.height = this.manualHeight ? this.height : Math.max(maxHeight, minHeight);
    	}

    	this.heightStyled = this.height ? this.height + "px" : "";
    	this.outerHeight = this.element.offsetHeight;
    };

    //set of cells
    Row.prototype.setCellHeight = function () {
    	this.cells.forEach(function (cell) {
    		cell.setHeight();
    	});

    	this.heightInitialized = true;
    };

    Row.prototype.clearCellHeight = function () {
    	this.cells.forEach(function (cell) {
    		cell.clearHeight();
    	});
    };

    //normalize the height of elements in the row
    Row.prototype.normalizeHeight = function (force) {

    	if (force) {
    		this.clearCellHeight();
    	}

    	this.calcHeight(force);

    	this.setCellHeight();
    };

    // Row.prototype.setHeight = function(height){
    // 	this.height = height;

    // 	this.setCellHeight();
    // };

    //set height of rows
    Row.prototype.setHeight = function (height, force) {
    	if (this.height != height || force) {

    		this.manualHeight = true;

    		this.height = height;
    		this.heightStyled = height ? height + "px" : "";

    		this.setCellHeight();

    		// this.outerHeight = this.element.outerHeight();
    		this.outerHeight = this.element.offsetHeight;
    	}
    };

    //return rows outer height
    Row.prototype.getHeight = function () {
    	return this.outerHeight;
    };

    //return rows outer Width
    Row.prototype.getWidth = function () {
    	return this.element.offsetWidth;
    };

    //////////////// Cell Management /////////////////

    Row.prototype.deleteCell = function (cell) {
    	var index = this.cells.indexOf(cell);

    	if (index > -1) {
    		this.cells.splice(index, 1);
    	}
    };

    //////////////// Data Management /////////////////

    Row.prototype.setData = function (data) {
    	if (this.table.modExists("mutator")) {
    		data = this.table.modules.mutator.transformRow(data, "data");
    	}

    	this.data = data;

    	if (this.table.options.reactiveData && this.table.modExists("reactiveData", true)) {
    		this.table.modules.reactiveData.watchRow(this);
    	}
    };

    //update the rows data
    Row.prototype.updateData = function (updatedData) {
    	var _this22 = this;

    	var visible = this.element && Tabulator.prototype.helpers.elVisible(this.element),
    	    tempData = {},
    	    newRowData;

    	return new Promise(function (resolve, reject) {

    		if (typeof updatedData === "string") {
    			updatedData = JSON.parse(updatedData);
    		}

    		if (_this22.table.options.reactiveData && _this22.table.modExists("reactiveData", true)) {
    			_this22.table.modules.reactiveData.block();
    		}

    		//mutate incomming data if needed
    		if (_this22.table.modExists("mutator")) {

    			tempData = Object.assign(tempData, _this22.data);
    			tempData = Object.assign(tempData, updatedData);

    			newRowData = _this22.table.modules.mutator.transformRow(tempData, "data", updatedData);
    		} else {
    			newRowData = updatedData;
    		}

    		//set data
    		for (var attrname in newRowData) {
    			_this22.data[attrname] = newRowData[attrname];
    		}

    		if (_this22.table.options.reactiveData && _this22.table.modExists("reactiveData", true)) {
    			_this22.table.modules.reactiveData.unblock();
    		}

    		//update affected cells only
    		for (var attrname in updatedData) {

    			var columns = _this22.table.columnManager.getColumnsByFieldRoot(attrname);

    			columns.forEach(function (column) {
    				var cell = _this22.getCell(column.getField());

    				if (cell) {
    					var value = column.getFieldValue(newRowData);
    					if (cell.getValue() != value) {
    						cell.setValueProcessData(value);

    						if (visible) {
    							cell.cellRendered();
    						}
    					}
    				}
    			});
    		}

    		if (_this22.table.options.groupUpdateOnCellEdit && _this22.table.options.groupBy && _this22.table.modExists("groupRows")) {
    			_this22.table.modules.groupRows.reassignRowToGroup(_this22.row);
    		}

    		//Partial reinitialization if visible
    		if (visible) {
    			_this22.normalizeHeight(true);

    			if (_this22.table.options.rowFormatter) {
    				_this22.table.options.rowFormatter(_this22.getComponent());
    			}
    		} else {
    			_this22.initialized = false;
    			_this22.height = 0;
    			_this22.heightStyled = "";
    		}

    		if (_this22.table.options.dataTree !== false && _this22.table.modExists("dataTree") && _this22.table.modules.dataTree.redrawNeeded(updatedData)) {
    			_this22.table.modules.dataTree.initializeRow(_this22);

    			if (visible) {
    				_this22.table.modules.dataTree.layoutRow(_this22);
    				_this22.table.rowManager.refreshActiveData("tree", false, true);
    			}
    		}

    		//this.reinitialize();

    		_this22.table.options.rowUpdated.call(_this22.table, _this22.getComponent());

    		if (_this22.table.options.dataChanged) {
    			_this22.table.options.dataChanged.call(_this22.table, _this22.table.rowManager.getData());
    		}

    		resolve();
    	});
    };

    Row.prototype.getData = function (transform) {
    	if (transform) {
    		if (this.table.modExists("accessor")) {
    			return this.table.modules.accessor.transformRow(this, transform);
    		}
    	}

    	return this.data;
    };

    Row.prototype.getCell = function (column) {
    	var match = false;

    	column = this.table.columnManager.findColumn(column);

    	match = this.cells.find(function (cell) {
    		return cell.column === column;
    	});

    	return match;
    };

    Row.prototype.getCellIndex = function (findCell) {
    	return this.cells.findIndex(function (cell) {
    		return cell === findCell;
    	});
    };

    Row.prototype.findNextEditableCell = function (index) {
    	var nextCell = false;

    	if (index < this.cells.length - 1) {
    		for (var i = index + 1; i < this.cells.length; i++) {
    			var cell = this.cells[i];

    			if (cell.column.modules.edit && Tabulator.prototype.helpers.elVisible(cell.getElement())) {
    				var allowEdit = true;

    				if (typeof cell.column.modules.edit.check == "function") {
    					allowEdit = cell.column.modules.edit.check(cell.getComponent());
    				}

    				if (allowEdit) {
    					nextCell = cell;
    					break;
    				}
    			}
    		}
    	}

    	return nextCell;
    };

    Row.prototype.findPrevEditableCell = function (index) {
    	var prevCell = false;

    	if (index > 0) {
    		for (var i = index - 1; i >= 0; i--) {
    			var cell = this.cells[i],
    			    allowEdit = true;

    			if (cell.column.modules.edit && Tabulator.prototype.helpers.elVisible(cell.getElement())) {
    				if (typeof cell.column.modules.edit.check == "function") {
    					allowEdit = cell.column.modules.edit.check(cell.getComponent());
    				}

    				if (allowEdit) {
    					prevCell = cell;
    					break;
    				}
    			}
    		}
    	}

    	return prevCell;
    };

    Row.prototype.getCells = function () {
    	return this.cells;
    };

    Row.prototype.nextRow = function () {
    	var row = this.table.rowManager.nextDisplayRow(this, true);
    	return row || false;
    };

    Row.prototype.prevRow = function () {
    	var row = this.table.rowManager.prevDisplayRow(this, true);
    	return row || false;
    };

    Row.prototype.moveToRow = function (to, before) {
    	var toRow = this.table.rowManager.findRow(to);

    	if (toRow) {
    		this.table.rowManager.moveRowActual(this, toRow, !before);
    		this.table.rowManager.refreshActiveData("display", false, true);
    	} else {
    		console.warn("Move Error - No matching row found:", to);
    	}
    };

    Row.prototype.validate = function () {
    	var invalid = [];

    	this.cells.forEach(function (cell) {
    		if (!cell.validate()) {
    			invalid.push(cell.getComponent());
    		}
    	});

    	return invalid.length ? invalid : true;
    };

    ///////////////////// Actions  /////////////////////

    Row.prototype.delete = function () {
    	var _this23 = this;

    	return new Promise(function (resolve, reject) {
    		var index, rows;

    		if (_this23.table.options.history && _this23.table.modExists("history")) {

    			if (_this23.table.options.groupBy && _this23.table.modExists("groupRows")) {
    				rows = _this23.getGroup().rows;
    				index = rows.indexOf(_this23);

    				if (index) {
    					index = rows[index - 1];
    				}
    			} else {
    				index = _this23.table.rowManager.getRowIndex(_this23);

    				if (index) {
    					index = _this23.table.rowManager.rows[index - 1];
    				}
    			}

    			_this23.table.modules.history.action("rowDelete", _this23, { data: _this23.getData(), pos: !index, index: index });
    		}

    		_this23.deleteActual();

    		resolve();
    	});
    };

    Row.prototype.deleteActual = function (blockRedraw) {
    	this.table.rowManager.getRowIndex(this);

    	this.detatchModules();

    	// if(this.table.options.dataTree && this.table.modExists("dataTree")){
    	// 	this.table.modules.dataTree.collapseRow(this, true);
    	// }

    	//remove any reactive data watchers from row object
    	if (this.table.options.reactiveData && this.table.modExists("reactiveData", true)) ;
    	// this.table.modules.reactiveData.unwatchRow(this);


    	//remove from group
    	if (this.modules.group) {
    		this.modules.group.removeRow(this);
    	}

    	this.table.rowManager.deleteRow(this, blockRedraw);

    	this.deleteCells();

    	this.initialized = false;
    	this.heightInitialized = false;
    	this.element = false;

    	if (this.table.options.dataTree && this.table.modExists("dataTree", true)) {
    		this.table.modules.dataTree.rowDelete(this);
    	}

    	//recalc column calculations if present
    	if (this.table.modExists("columnCalcs")) {
    		if (this.table.options.groupBy && this.table.modExists("groupRows")) {
    			this.table.modules.columnCalcs.recalcRowGroup(this);
    		} else {
    			this.table.modules.columnCalcs.recalc(this.table.rowManager.activeRows);
    		}
    	}
    };

    Row.prototype.detatchModules = function () {
    	//deselect row if it is selected
    	if (this.table.modExists("selectRow")) {
    		this.table.modules.selectRow._deselectRow(this, true);
    	}

    	//cancel edit if row is currently being edited
    	if (this.table.modExists("edit")) {
    		if (this.table.modules.edit.currentCell.row === this) {
    			this.table.modules.edit.cancelEdit();
    		}
    	}

    	if (this.table.modExists("frozenRows")) {
    		this.table.modules.frozenRows.detachRow(this);
    	}
    };

    Row.prototype.deleteCells = function () {
    	var cellCount = this.cells.length;

    	for (var _i8 = 0; _i8 < cellCount; _i8++) {
    		this.cells[0].delete();
    	}
    };

    Row.prototype.wipe = function () {
    	this.detatchModules();
    	this.deleteCells();

    	if (this.element) {
    		while (this.element.firstChild) {
    			this.element.removeChild(this.element.firstChild);
    		}if (this.element.parentNode) {
    			this.element.parentNode.removeChild(this.element);
    		}
    	}

    	this.element = false;
    	this.modules = {};
    };

    Row.prototype.getGroup = function () {
    	return this.modules.group || false;
    };

    //////////////// Object Generation /////////////////
    Row.prototype.getComponent = function () {
    	if (!this.component) {
    		this.component = new RowComponent(this);
    	}

    	return this.component;
    };

    //public row object
    var CellComponent = function CellComponent(cell) {
    	this._cell = cell;
    };

    CellComponent.prototype.getValue = function () {
    	return this._cell.getValue();
    };

    CellComponent.prototype.getOldValue = function () {
    	return this._cell.getOldValue();
    };

    CellComponent.prototype.getInitialValue = function () {
    	return this._cell.initialValue;
    };

    CellComponent.prototype.getElement = function () {
    	return this._cell.getElement();
    };

    CellComponent.prototype.getRow = function () {
    	return this._cell.row.getComponent();
    };

    CellComponent.prototype.getData = function () {
    	return this._cell.row.getData();
    };

    CellComponent.prototype.getField = function () {
    	return this._cell.column.getField();
    };

    CellComponent.prototype.getColumn = function () {
    	return this._cell.column.getComponent();
    };

    CellComponent.prototype.setValue = function (value, mutate) {
    	if (typeof mutate == "undefined") {
    		mutate = true;
    	}

    	this._cell.setValue(value, mutate);
    };

    CellComponent.prototype.restoreOldValue = function () {
    	this._cell.setValueActual(this._cell.getOldValue());
    };

    CellComponent.prototype.restoreInitialValue = function () {
    	this._cell.setValueActual(this._cell.initialValue);
    };

    CellComponent.prototype.edit = function (force) {
    	return this._cell.edit(force);
    };

    CellComponent.prototype.cancelEdit = function () {
    	this._cell.cancelEdit();
    };

    CellComponent.prototype.isEdited = function () {
    	return !!this._cell.modules.edit && this._cell.modules.edit.edited;
    };

    CellComponent.prototype.clearEdited = function () {
    	if (self.table.modExists("edit", true)) {
    		this._cell.table.modules.edit.clearEdited(this._cell);
    	}
    };

    CellComponent.prototype.isValid = function () {
    	return this._cell.modules.validate ? !this._cell.modules.validate.invalid : true;
    };

    CellComponent.prototype.validate = function () {
    	return this._cell.validate();
    };

    CellComponent.prototype.clearValidation = function () {
    	if (this._cell.table.modExists("validate", true)) {
    		this._cell.table.modules.validate.clearValidation(this._cell);
    	}
    };

    CellComponent.prototype.nav = function () {
    	return this._cell.nav();
    };

    CellComponent.prototype.checkHeight = function () {
    	this._cell.checkHeight();
    };

    CellComponent.prototype.getTable = function () {
    	return this._cell.table;
    };

    CellComponent.prototype._getSelf = function () {
    	return this._cell;
    };

    var Cell = function Cell(column, row) {

    	this.table = column.table;
    	this.column = column;
    	this.row = row;
    	this.element = null;
    	this.value = null;
    	this.initialValue;
    	this.oldValue = null;
    	this.modules = {};

    	this.height = null;
    	this.width = null;
    	this.minWidth = null;

    	this.component = null;

    	this.loaded = false; //track if the cell has been added to the DOM yet

    	this.build();
    };

    //////////////// Setup Functions /////////////////

    //generate element
    Cell.prototype.build = function () {
    	this.generateElement();

    	this.setWidth();

    	this._configureCell();

    	this.setValueActual(this.column.getFieldValue(this.row.data));

    	this.initialValue = this.value;
    };

    Cell.prototype.generateElement = function () {
    	this.element = document.createElement('div');
    	this.element.className = "tabulator-cell";
    	this.element.setAttribute("role", "gridcell");
    	this.element = this.element;
    };

    Cell.prototype._configureCell = function () {
    	var self = this,
    	    cellEvents = self.column.cellEvents,
    	    element = self.element,
    	    field = this.column.getField(),
    	    vertAligns = {
    		top: "flex-start",
    		bottom: "flex-end",
    		middle: "center"
    	},
    	    hozAligns = {
    		left: "flex-start",
    		right: "flex-end",
    		center: "center"
    	};

    	//set text alignment
    	element.style.textAlign = self.column.hozAlign;

    	if (self.column.vertAlign) {
    		element.style.display = "inline-flex";

    		element.style.alignItems = vertAligns[self.column.vertAlign] || "";

    		if (self.column.hozAlign) {
    			element.style.justifyContent = hozAligns[self.column.hozAlign] || "";
    		}
    	}

    	if (field) {
    		element.setAttribute("tabulator-field", field);
    	}

    	//add class to cell if needed
    	if (self.column.definition.cssClass) {
    		var classNames = self.column.definition.cssClass.split(" ");
    		classNames.forEach(function (className) {
    			element.classList.add(className);
    		});
    	}

    	//update tooltip on mouse enter
    	if (this.table.options.tooltipGenerationMode === "hover") {
    		element.addEventListener("mouseenter", function (e) {
    			self._generateTooltip();
    		});
    	}

    	self._bindClickEvents(cellEvents);

    	self._bindTouchEvents(cellEvents);

    	self._bindMouseEvents(cellEvents);

    	if (self.column.modules.edit) {
    		self.table.modules.edit.bindEditor(self);
    	}

    	if (self.column.definition.rowHandle && self.table.options.movableRows !== false && self.table.modExists("moveRow")) {
    		self.table.modules.moveRow.initializeCell(self);
    	}

    	//hide cell if not visible
    	if (!self.column.visible) {
    		self.hide();
    	}
    };

    Cell.prototype._bindClickEvents = function (cellEvents) {
    	var self = this,
    	    element = self.element;

    	//set event bindings
    	if (cellEvents.cellClick || self.table.options.cellClick) {
    		element.addEventListener("click", function (e) {
    			var component = self.getComponent();

    			if (cellEvents.cellClick) {
    				cellEvents.cellClick.call(self.table, e, component);
    			}

    			if (self.table.options.cellClick) {
    				self.table.options.cellClick.call(self.table, e, component);
    			}
    		});
    	}

    	if (cellEvents.cellDblClick || this.table.options.cellDblClick) {
    		element.addEventListener("dblclick", function (e) {
    			var component = self.getComponent();

    			if (cellEvents.cellDblClick) {
    				cellEvents.cellDblClick.call(self.table, e, component);
    			}

    			if (self.table.options.cellDblClick) {
    				self.table.options.cellDblClick.call(self.table, e, component);
    			}
    		});
    	} else {
    		element.addEventListener("dblclick", function (e) {

    			if (self.table.modExists("edit")) {
    				if (self.table.modules.edit.currentCell === self) {
    					return; //prevent instant selection of editor content
    				}
    			}

    			e.preventDefault();

    			try {
    				if (document.selection) {
    					// IE
    					var range = document.body.createTextRange();
    					range.moveToElementText(self.element);
    					range.select();
    				} else if (window.getSelection) {
    					var range = document.createRange();
    					range.selectNode(self.element);
    					window.getSelection().removeAllRanges();
    					window.getSelection().addRange(range);
    				}
    			} catch (e) {}
    		});
    	}

    	if (cellEvents.cellContext || this.table.options.cellContext) {
    		element.addEventListener("contextmenu", function (e) {
    			var component = self.getComponent();

    			if (cellEvents.cellContext) {
    				cellEvents.cellContext.call(self.table, e, component);
    			}

    			if (self.table.options.cellContext) {
    				self.table.options.cellContext.call(self.table, e, component);
    			}
    		});
    	}
    };

    Cell.prototype._bindMouseEvents = function (cellEvents) {
    	var self = this,
    	    element = self.element;

    	if (cellEvents.cellMouseEnter || self.table.options.cellMouseEnter) {
    		element.addEventListener("mouseenter", function (e) {
    			var component = self.getComponent();

    			if (cellEvents.cellMouseEnter) {
    				cellEvents.cellMouseEnter.call(self.table, e, component);
    			}

    			if (self.table.options.cellMouseEnter) {
    				self.table.options.cellMouseEnter.call(self.table, e, component);
    			}
    		});
    	}

    	if (cellEvents.cellMouseLeave || self.table.options.cellMouseLeave) {
    		element.addEventListener("mouseleave", function (e) {
    			var component = self.getComponent();

    			if (cellEvents.cellMouseLeave) {
    				cellEvents.cellMouseLeave.call(self.table, e, component);
    			}

    			if (self.table.options.cellMouseLeave) {
    				self.table.options.cellMouseLeave.call(self.table, e, component);
    			}
    		});
    	}

    	if (cellEvents.cellMouseOver || self.table.options.cellMouseOver) {
    		element.addEventListener("mouseover", function (e) {
    			var component = self.getComponent();

    			if (cellEvents.cellMouseOver) {
    				cellEvents.cellMouseOver.call(self.table, e, component);
    			}

    			if (self.table.options.cellMouseOver) {
    				self.table.options.cellMouseOver.call(self.table, e, component);
    			}
    		});
    	}

    	if (cellEvents.cellMouseOut || self.table.options.cellMouseOut) {
    		element.addEventListener("mouseout", function (e) {
    			var component = self.getComponent();

    			if (cellEvents.cellMouseOut) {
    				cellEvents.cellMouseOut.call(self.table, e, component);
    			}

    			if (self.table.options.cellMouseOut) {
    				self.table.options.cellMouseOut.call(self.table, e, component);
    			}
    		});
    	}

    	if (cellEvents.cellMouseMove || self.table.options.cellMouseMove) {
    		element.addEventListener("mousemove", function (e) {
    			var component = self.getComponent();

    			if (cellEvents.cellMouseMove) {
    				cellEvents.cellMouseMove.call(self.table, e, component);
    			}

    			if (self.table.options.cellMouseMove) {
    				self.table.options.cellMouseMove.call(self.table, e, component);
    			}
    		});
    	}
    };

    Cell.prototype._bindTouchEvents = function (cellEvents) {
    	var self = this,
    	    element = self.element,
    	    dblTap,
    	    tapHold,
    	    tap;

    	if (cellEvents.cellTap || this.table.options.cellTap) {
    		tap = false;

    		element.addEventListener("touchstart", function (e) {
    			tap = true;
    		}, { passive: true });

    		element.addEventListener("touchend", function (e) {
    			if (tap) {
    				var component = self.getComponent();

    				if (cellEvents.cellTap) {
    					cellEvents.cellTap.call(self.table, e, component);
    				}

    				if (self.table.options.cellTap) {
    					self.table.options.cellTap.call(self.table, e, component);
    				}
    			}

    			tap = false;
    		});
    	}

    	if (cellEvents.cellDblTap || this.table.options.cellDblTap) {
    		dblTap = null;

    		element.addEventListener("touchend", function (e) {

    			if (dblTap) {
    				clearTimeout(dblTap);
    				dblTap = null;

    				var component = self.getComponent();

    				if (cellEvents.cellDblTap) {
    					cellEvents.cellDblTap.call(self.table, e, component);
    				}

    				if (self.table.options.cellDblTap) {
    					self.table.options.cellDblTap.call(self.table, e, component);
    				}
    			} else {

    				dblTap = setTimeout(function () {
    					clearTimeout(dblTap);
    					dblTap = null;
    				}, 300);
    			}
    		});
    	}

    	if (cellEvents.cellTapHold || this.table.options.cellTapHold) {
    		tapHold = null;

    		element.addEventListener("touchstart", function (e) {
    			clearTimeout(tapHold);

    			tapHold = setTimeout(function () {
    				clearTimeout(tapHold);
    				tapHold = null;
    				tap = false;
    				var component = self.getComponent();

    				if (cellEvents.cellTapHold) {
    					cellEvents.cellTapHold.call(self.table, e, component);
    				}

    				if (self.table.options.cellTapHold) {
    					self.table.options.cellTapHold.call(self.table, e, component);
    				}
    			}, 1000);
    		}, { passive: true });

    		element.addEventListener("touchend", function (e) {
    			clearTimeout(tapHold);
    			tapHold = null;
    		});
    	}
    };

    //generate cell contents
    Cell.prototype._generateContents = function () {
    	var val;

    	if (this.table.modExists("format")) {
    		val = this.table.modules.format.formatValue(this);
    	} else {
    		val = this.element.innerHTML = this.value;
    	}

    	switch (typeof val === 'undefined' ? 'undefined' : _typeof(val)) {
    		case "object":
    			if (val instanceof Node) {

    				//clear previous cell contents
    				while (this.element.firstChild) {
    					this.element.removeChild(this.element.firstChild);
    				}this.element.appendChild(val);
    			} else {
    				this.element.innerHTML = "";

    				if (val != null) {
    					console.warn("Format Error - Formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", val);
    				}
    			}
    			break;
    		case "undefined":
    		case "null":
    			this.element.innerHTML = "";
    			break;
    		default:
    			this.element.innerHTML = val;
    	}
    };

    Cell.prototype.cellRendered = function () {
    	if (this.table.modExists("format") && this.table.modules.format.cellRendered) {
    		this.table.modules.format.cellRendered(this);
    	}
    };

    //generate tooltip text
    Cell.prototype._generateTooltip = function () {
    	var tooltip = this.column.tooltip;

    	if (tooltip) {
    		if (tooltip === true) {
    			tooltip = this.value;
    		} else if (typeof tooltip == "function") {
    			tooltip = tooltip(this.getComponent());

    			if (tooltip === false) {
    				tooltip = "";
    			}
    		}

    		if (typeof tooltip === "undefined") {
    			tooltip = "";
    		}

    		this.element.setAttribute("title", tooltip);
    	} else {
    		this.element.setAttribute("title", "");
    	}
    };

    //////////////////// Getters ////////////////////
    Cell.prototype.getElement = function (containerOnly) {
    	if (!this.loaded) {
    		this.loaded = true;
    		if (!containerOnly) {
    			this.layoutElement();
    		}
    	}

    	return this.element;
    };

    Cell.prototype.getValue = function () {
    	return this.value;
    };

    Cell.prototype.getOldValue = function () {
    	return this.oldValue;
    };

    //////////////////// Actions ////////////////////

    Cell.prototype.setValue = function (value, mutate) {

    	var changed = this.setValueProcessData(value, mutate),
    	    component;

    	if (changed) {
    		if (this.table.options.history && this.table.modExists("history")) {
    			this.table.modules.history.action("cellEdit", this, { oldValue: this.oldValue, newValue: this.value });
    		}

    		component = this.getComponent();

    		if (this.column.cellEvents.cellEdited) {
    			this.column.cellEvents.cellEdited.call(this.table, component);
    		}

    		if (this.table.options.groupUpdateOnCellEdit && this.table.options.groupBy && this.table.modExists("groupRows")) {
    			this.table.modules.groupRows.reassignRowToGroup(this.row);
    		}

    		this.cellRendered();

    		this.table.options.cellEdited.call(this.table, component);

    		if (this.table.options.dataChanged) {
    			this.table.options.dataChanged.call(this.table, this.table.rowManager.getData());
    		}
    	}
    };

    Cell.prototype.setValueProcessData = function (value, mutate) {
    	var changed = false;

    	if (this.value != value) {

    		changed = true;

    		if (mutate) {
    			if (this.column.modules.mutate) {
    				value = this.table.modules.mutator.transformCell(this, value);
    			}
    		}
    	}

    	this.setValueActual(value);

    	if (changed && this.table.modExists("columnCalcs")) {
    		if (this.column.definition.topCalc || this.column.definition.bottomCalc) {
    			if (this.table.options.groupBy && this.table.modExists("groupRows")) {

    				if (this.table.options.columnCalcs == "table" || this.table.options.columnCalcs == "both") {
    					this.table.modules.columnCalcs.recalc(this.table.rowManager.activeRows);
    				}

    				if (this.table.options.columnCalcs != "table") {
    					this.table.modules.columnCalcs.recalcRowGroup(this.row);
    				}
    			} else {
    				this.table.modules.columnCalcs.recalc(this.table.rowManager.activeRows);
    			}
    		}
    	}

    	return changed;
    };

    Cell.prototype.setValueActual = function (value) {
    	this.oldValue = this.value;

    	this.value = value;

    	if (this.table.options.reactiveData && this.table.modExists("reactiveData")) {
    		this.table.modules.reactiveData.block();
    	}

    	this.column.setFieldValue(this.row.data, value);

    	if (this.table.options.reactiveData && this.table.modExists("reactiveData")) {
    		this.table.modules.reactiveData.unblock();
    	}

    	if (this.loaded) {
    		this.layoutElement();
    	}
    };

    Cell.prototype.layoutElement = function () {
    	this._generateContents();
    	this._generateTooltip();

    	//set resizable handles
    	if (this.table.options.resizableColumns && this.table.modExists("resizeColumns") && this.row.type === "row") {
    		this.table.modules.resizeColumns.initializeColumn("cell", this.column, this.element);
    	}

    	if ((this.column.definition.contextMenu || this.column.definition.clickMenu) && this.table.modExists("menu")) {
    		this.table.modules.menu.initializeCell(this);
    	}

    	//handle frozen cells
    	if (this.table.modExists("frozenColumns")) {
    		this.table.modules.frozenColumns.layoutElement(this.element, this.column);
    	}
    };

    Cell.prototype.setWidth = function () {
    	this.width = this.column.width;
    	this.element.style.width = this.column.widthStyled;
    };

    Cell.prototype.clearWidth = function () {
    	this.width = "";
    	this.element.style.width = "";
    };

    Cell.prototype.getWidth = function () {
    	return this.width || this.element.offsetWidth;
    };

    Cell.prototype.setMinWidth = function () {
    	this.minWidth = this.column.minWidth;
    	this.element.style.minWidth = this.column.minWidthStyled;
    };

    Cell.prototype.setMaxWidth = function () {
    	this.maxWidth = this.column.maxWidth;
    	this.element.style.maxWidth = this.column.maxWidthStyled;
    };

    Cell.prototype.checkHeight = function () {
    	// var height = this.element.css("height");
    	this.row.reinitializeHeight();
    };

    Cell.prototype.clearHeight = function () {
    	this.element.style.height = "";
    	this.height = null;
    };

    Cell.prototype.setHeight = function () {
    	this.height = this.row.height;
    	this.element.style.height = this.row.heightStyled;
    };

    Cell.prototype.getHeight = function () {
    	return this.height || this.element.offsetHeight;
    };

    Cell.prototype.show = function () {
    	this.element.style.display = this.column.vertAlign ? "inline-flex" : "";
    };

    Cell.prototype.hide = function () {
    	this.element.style.display = "none";
    };

    Cell.prototype.edit = function (force) {
    	if (this.table.modExists("edit", true)) {
    		return this.table.modules.edit.editCell(this, force);
    	}
    };

    Cell.prototype.cancelEdit = function () {
    	if (this.table.modExists("edit", true)) {
    		var editing = this.table.modules.edit.getCurrentCell();

    		if (editing && editing._getSelf() === this) {
    			this.table.modules.edit.cancelEdit();
    		} else {
    			console.warn("Cancel Editor Error - This cell is not currently being edited ");
    		}
    	}
    };

    Cell.prototype.validate = function () {
    	if (this.column.modules.validate && this.table.modExists("validate", true)) {
    		var valid = this.table.modules.validate.validate(this.column.modules.validate, this, this.getValue());

    		return valid === true;
    	} else {
    		return true;
    	}
    };

    Cell.prototype.delete = function () {
    	if (!this.table.rowManager.redrawBlock && this.element.parentNode) {
    		this.element.parentNode.removeChild(this.element);
    	}

    	if (this.modules.validate && this.modules.validate.invalid) {
    		this.table.modules.validate.clearValidation(this);
    	}

    	if (this.modules.edit && this.modules.edit.edited) {
    		this.table.modules.edit.clearEdited(this);
    	}

    	if (this.table.options.history) {
    		this.table.modules.history.clearComponentHistory(this);
    	}

    	this.element = false;
    	this.column.deleteCell(this);
    	this.row.deleteCell(this);
    	this.calcs = {};
    };

    //////////////// Navigation /////////////////

    Cell.prototype.nav = function () {

    	var self = this,
    	    nextCell = false,
    	    index = this.row.getCellIndex(this);

    	return {
    		next: function next() {
    			var nextCell = this.right(),
    			    nextRow;

    			if (!nextCell) {
    				nextRow = self.table.rowManager.nextDisplayRow(self.row, true);

    				if (nextRow) {
    					nextCell = nextRow.findNextEditableCell(-1);

    					if (nextCell) {
    						nextCell.edit();
    						return true;
    					}
    				}
    			} else {
    				return true;
    			}

    			return false;
    		},
    		prev: function prev() {
    			var nextCell = this.left(),
    			    prevRow;

    			if (!nextCell) {
    				prevRow = self.table.rowManager.prevDisplayRow(self.row, true);

    				if (prevRow) {
    					nextCell = prevRow.findPrevEditableCell(prevRow.cells.length);

    					if (nextCell) {
    						nextCell.edit();
    						return true;
    					}
    				}
    			} else {
    				return true;
    			}

    			return false;
    		},
    		left: function left() {

    			nextCell = self.row.findPrevEditableCell(index);

    			if (nextCell) {
    				nextCell.edit();
    				return true;
    			} else {
    				return false;
    			}
    		},
    		right: function right() {
    			nextCell = self.row.findNextEditableCell(index);

    			if (nextCell) {
    				nextCell.edit();
    				return true;
    			} else {
    				return false;
    			}
    		},
    		up: function up() {
    			var nextRow = self.table.rowManager.prevDisplayRow(self.row, true);

    			if (nextRow) {
    				nextRow.cells[index].edit();
    			}
    		},
    		down: function down() {
    			var nextRow = self.table.rowManager.nextDisplayRow(self.row, true);

    			if (nextRow) {
    				nextRow.cells[index].edit();
    			}
    		}

    	};
    };

    Cell.prototype.getIndex = function () {
    	this.row.getCellIndex(this);
    };

    //////////////// Object Generation /////////////////
    Cell.prototype.getComponent = function () {

    	if (!this.component) {
    		this.component = new CellComponent(this);
    	}

    	return this.component;
    };
    var FooterManager = function FooterManager(table) {
    	this.table = table;
    	this.active = false;
    	this.element = this.createElement(); //containing element
    	this.external = false;
    	this.links = [];

    	this._initialize();
    };

    FooterManager.prototype.createElement = function () {
    	var el = document.createElement("div");

    	el.classList.add("tabulator-footer");

    	return el;
    };

    FooterManager.prototype._initialize = function (element) {
    	if (this.table.options.footerElement) {

    		switch (_typeof(this.table.options.footerElement)) {
    			case "string":

    				if (this.table.options.footerElement[0] === "<") {
    					this.element.innerHTML = this.table.options.footerElement;
    				} else {
    					this.external = true;
    					this.element = document.querySelector(this.table.options.footerElement);
    				}
    				break;
    			default:
    				this.element = this.table.options.footerElement;
    				break;
    		}
    	}
    };

    FooterManager.prototype.getElement = function () {
    	return this.element;
    };

    FooterManager.prototype.append = function (element, parent) {
    	this.activate(parent);

    	this.element.appendChild(element);
    	this.table.rowManager.adjustTableSize();
    };

    FooterManager.prototype.prepend = function (element, parent) {
    	this.activate(parent);

    	this.element.insertBefore(element, this.element.firstChild);
    	this.table.rowManager.adjustTableSize();
    };

    FooterManager.prototype.remove = function (element) {
    	element.parentNode.removeChild(element);
    	this.deactivate();
    };

    FooterManager.prototype.deactivate = function (force) {
    	if (!this.element.firstChild || force) {
    		if (!this.external) {
    			this.element.parentNode.removeChild(this.element);
    		}
    		this.active = false;
    	}

    	// this.table.rowManager.adjustTableSize();
    };

    FooterManager.prototype.activate = function (parent) {
    	if (!this.active) {
    		this.active = true;
    		if (!this.external) {
    			this.table.element.appendChild(this.getElement());
    			this.table.element.style.display = '';
    		}
    	}

    	if (parent) {
    		this.links.push(parent);
    	}
    };

    FooterManager.prototype.redraw = function () {
    	this.links.forEach(function (link) {
    		link.footerRedraw();
    	});
    };

    var Tabulator = function Tabulator(element, options) {

    	this.options = {};

    	this.columnManager = null; // hold Column Manager
    	this.rowManager = null; //hold Row Manager
    	this.footerManager = null; //holder Footer Manager
    	this.vdomHoz = null; //holder horizontal virtual dom


    	this.browser = ""; //hold current browser type
    	this.browserSlow = false; //handle reduced functionality for slower browsers
    	this.browserMobile = false; //check if running on moble, prevent resize cancelling edit on keyboard appearence
    	this.rtl = false; //check if the table is in RTL mode

    	this.modules = {}; //hold all modules bound to this table

    	if (this.initializeElement(element)) {
    		this.initializeOptions(options || {});
    		this._create();
    	}

    	Tabulator.prototype.comms.register(this); //register table for inderdevice communication
    };

    //default setup options
    Tabulator.prototype.defaultOptions = {

    	height: false, //height of tabulator
    	minHeight: false, //minimum height of tabulator
    	maxHeight: false, //maximum height of tabulator

    	layout: "fitData", ///layout type "fitColumns" | "fitData"
    	layoutColumnsOnNewData: false, //update column widths on setData

    	columnMinWidth: 40, //minimum global width for a column
    	columnMaxWidth: false, //minimum global width for a column
    	columnHeaderVertAlign: "top", //vertical alignment of column headers
    	columnVertAlign: false, // DEPRECATED - Left to allow warning

    	resizableColumns: true, //resizable columns
    	resizableRows: false, //resizable rows
    	autoResize: true, //auto resize table

    	columns: [], //store for colum header info

    	cellHozAlign: "", //horizontal align columns
    	cellVertAlign: "", //vertical align columns
    	headerHozAlign: "", //horizontal header alignment


    	data: [], //default starting data

    	autoColumns: false, //build columns from data row structure
    	autoColumnsDefinitions: false,

    	reactiveData: false, //enable data reactivity

    	nestedFieldSeparator: ".", //seperatpr for nested data

    	tooltips: false, //Tool tip value
    	tooltipsHeader: false, //Tool tip for headers
    	tooltipGenerationMode: "load", //when to generate tooltips

    	initialSort: false, //initial sorting criteria
    	initialFilter: false, //initial filtering criteria
    	initialHeaderFilter: false, //initial header filtering criteria

    	columnHeaderSortMulti: true, //multiple or single column sorting

    	sortOrderReverse: false, //reverse internal sort ordering

    	headerSort: true, //set default global header sort
    	headerSortTristate: false, //set default tristate header sorting
    	headerSortElement: "<div class='tabulator-arrow'></div>", //header sort element

    	footerElement: false, //hold footer element

    	index: "id", //filed for row index

    	textDirection: "auto",

    	keybindings: [], //array for keybindings

    	tabEndNewRow: false, //create new row when tab to end of table

    	invalidOptionWarnings: true, //allow toggling of invalid option warnings

    	clipboard: false, //enable clipboard
    	clipboardCopyStyled: true, //formatted table data
    	clipboardCopyConfig: false, //clipboard config
    	clipboardCopyFormatter: false, //DEPRICATED - REMOVE in 5.0
    	clipboardCopyRowRange: "active", //restrict clipboard to visible rows only
    	clipboardPasteParser: "table", //convert pasted clipboard data to rows
    	clipboardPasteAction: "insert", //how to insert pasted data into the table

    	clipboardCopied: function clipboardCopied() {}, //data has been copied to the clipboard
    	clipboardPasted: function clipboardPasted() {}, //data has been pasted into the table
    	clipboardPasteError: function clipboardPasteError() {}, //data has not successfully been pasted into the table

    	downloadDataFormatter: false, //function to manipulate table data before it is downloaded
    	downloadReady: function downloadReady(data, blob) {
    		return blob;
    	}, //function to manipulate download data
    	downloadComplete: false, //function to manipulate download data
    	downloadConfig: {}, //download config
    	downloadRowRange: "active", //restrict download to active rows only

    	dataTree: false, //enable data tree
    	dataTreeFilter: true, //filter child rows
    	dataTreeSort: true, //sort child rows
    	dataTreeElementColumn: false,
    	dataTreeBranchElement: true, //show data tree branch element
    	dataTreeChildIndent: 9, //data tree child indent in px
    	dataTreeChildField: "_children", //data tre column field to look for child rows
    	dataTreeCollapseElement: false, //data tree row collapse element
    	dataTreeExpandElement: false, //data tree row expand element
    	dataTreeStartExpanded: false,
    	dataTreeRowExpanded: function dataTreeRowExpanded() {}, //row has been expanded
    	dataTreeRowCollapsed: function dataTreeRowCollapsed() {}, //row has been collapsed
    	dataTreeChildColumnCalcs: false, //include visible data tree rows in column calculations
    	dataTreeSelectPropagate: false, //seleccting a parent row selects its children

    	printAsHtml: false, //enable print as html
    	printFormatter: false, //printing page formatter
    	printHeader: false, //page header contents
    	printFooter: false, //page footer contents
    	printCopyStyle: true, //DEPRICATED - REMOVE in 5.0
    	printStyled: true, //enable print as html styling
    	printVisibleRows: true, //DEPRICATED - REMOVE in 5.0
    	printRowRange: "visible", //restrict print to visible rows only
    	printConfig: {}, //print config options

    	addRowPos: "bottom", //position to insert blank rows, top|bottom

    	selectable: "highlight", //highlight rows on hover
    	selectableRangeMode: "drag", //highlight rows on hover
    	selectableRollingSelection: true, //roll selection once maximum number of selectable rows is reached
    	selectablePersistence: true, // maintain selection when table view is updated
    	selectableCheck: function selectableCheck(data, row) {
    		return true;
    	}, //check wheather row is selectable

    	headerFilterLiveFilterDelay: 300, //delay before updating column after user types in header filter
    	headerFilterPlaceholder: false, //placeholder text to display in header filters

    	headerVisible: true, //hide header

    	history: false, //enable edit history

    	locale: false, //current system language
    	langs: {},

    	virtualDom: true, //enable DOM virtualization
    	virtualDomBuffer: 0, // set virtual DOM buffer size
    	virtualDomHoz: false, //enable horizontal DOM virtualization

    	persistentLayout: false, //DEPRICATED - REMOVE in 5.0
    	persistentSort: false, //DEPRICATED - REMOVE in 5.0
    	persistentFilter: false, //DEPRICATED - REMOVE in 5.0
    	persistenceID: "", //key for persistent storage
    	persistenceMode: true, //mode for storing persistence information
    	persistenceReaderFunc: false, //function for handling persistence data reading
    	persistenceWriterFunc: false, //function for handling persistence data writing

    	persistence: false,

    	responsiveLayout: false, //responsive layout flags
    	responsiveLayoutCollapseStartOpen: true, //start showing collapsed data
    	responsiveLayoutCollapseUseFormatters: true, //responsive layout collapse formatter
    	responsiveLayoutCollapseFormatter: false, //responsive layout collapse formatter

    	pagination: false, //set pagination type
    	paginationSize: false, //set number of rows to a page
    	paginationInitialPage: 1, //initail page to show on load
    	paginationButtonCount: 5, // set count of page button
    	paginationSizeSelector: false, //add pagination size selector element
    	paginationElement: false, //element to hold pagination numbers
    	paginationDataSent: {}, //pagination data sent to the server
    	paginationDataReceived: {}, //pagination data received from the server
    	paginationAddRow: "page", //add rows on table or page

    	ajaxURL: false, //url for ajax loading
    	ajaxURLGenerator: false,
    	ajaxParams: {}, //params for ajax loading
    	ajaxConfig: "get", //ajax request type
    	ajaxContentType: "form", //ajax request type
    	ajaxRequestFunc: false, //promise function
    	ajaxLoader: true, //show loader
    	ajaxLoaderLoading: false, //loader element
    	ajaxLoaderError: false, //loader element
    	ajaxFiltering: false,
    	ajaxSorting: false,
    	ajaxProgressiveLoad: false, //progressive loading
    	ajaxProgressiveLoadDelay: 0, //delay between requests
    	ajaxProgressiveLoadScrollMargin: 0, //margin before scroll begins

    	groupBy: false, //enable table grouping and set field to group by
    	groupStartOpen: true, //starting state of group
    	groupValues: false,
    	groupUpdateOnCellEdit: false,

    	groupHeader: false, //header generation function
    	groupHeaderPrint: null,
    	groupHeaderClipboard: null,
    	groupHeaderHtmlOutput: null,
    	groupHeaderDownload: null,

    	htmlOutputConfig: false, //html outypu config

    	movableColumns: false, //enable movable columns

    	movableRows: false, //enable movable rows
    	movableRowsConnectedTables: false, //tables for movable rows to be connected to
    	movableRowsConnectedElements: false, //other elements for movable rows to be connected to
    	movableRowsSender: false,
    	movableRowsReceiver: "insert",
    	movableRowsSendingStart: function movableRowsSendingStart() {},
    	movableRowsSent: function movableRowsSent() {},
    	movableRowsSentFailed: function movableRowsSentFailed() {},
    	movableRowsSendingStop: function movableRowsSendingStop() {},
    	movableRowsReceivingStart: function movableRowsReceivingStart() {},
    	movableRowsReceived: function movableRowsReceived() {},
    	movableRowsReceivedFailed: function movableRowsReceivedFailed() {},
    	movableRowsReceivingStop: function movableRowsReceivingStop() {},
    	movableRowsElementDrop: function movableRowsElementDrop() {},

    	scrollToRowPosition: "top",
    	scrollToRowIfVisible: true,

    	scrollToColumnPosition: "left",
    	scrollToColumnIfVisible: true,

    	rowFormatter: false,
    	rowFormatterPrint: null,
    	rowFormatterClipboard: null,
    	rowFormatterHtmlOutput: null,

    	placeholder: false,

    	//table building callbacks
    	tableBuilding: function tableBuilding() {},
    	tableBuilt: function tableBuilt() {},

    	//render callbacks
    	renderStarted: function renderStarted() {},
    	renderComplete: function renderComplete() {},

    	//row callbacks
    	rowClick: false,
    	rowDblClick: false,
    	rowContext: false,
    	rowTap: false,
    	rowDblTap: false,
    	rowTapHold: false,
    	rowMouseEnter: false,
    	rowMouseLeave: false,
    	rowMouseOver: false,
    	rowMouseOut: false,
    	rowMouseMove: false,
    	rowContextMenu: false,
    	rowClickMenu: false,
    	rowAdded: function rowAdded() {},
    	rowDeleted: function rowDeleted() {},
    	rowMoved: function rowMoved() {},
    	rowUpdated: function rowUpdated() {},
    	rowSelectionChanged: function rowSelectionChanged() {},
    	rowSelected: function rowSelected() {},
    	rowDeselected: function rowDeselected() {},
    	rowResized: function rowResized() {},

    	//cell callbacks
    	//row callbacks
    	cellClick: false,
    	cellDblClick: false,
    	cellContext: false,
    	cellTap: false,
    	cellDblTap: false,
    	cellTapHold: false,
    	cellMouseEnter: false,
    	cellMouseLeave: false,
    	cellMouseOver: false,
    	cellMouseOut: false,
    	cellMouseMove: false,
    	cellEditing: function cellEditing() {},
    	cellEdited: function cellEdited() {},
    	cellEditCancelled: function cellEditCancelled() {},

    	//column callbacks
    	columnMoved: false,
    	columnResized: function columnResized() {},
    	columnTitleChanged: function columnTitleChanged() {},
    	columnVisibilityChanged: function columnVisibilityChanged() {},

    	//HTML iport callbacks
    	htmlImporting: function htmlImporting() {},
    	htmlImported: function htmlImported() {},

    	//data callbacks
    	dataLoading: function dataLoading() {},
    	dataLoaded: function dataLoaded() {},
    	dataEdited: false, //DEPRECATED
    	dataChanged: false,

    	//ajax callbacks
    	ajaxRequesting: function ajaxRequesting() {},
    	ajaxResponse: false,
    	ajaxError: function ajaxError() {},

    	//filtering callbacks
    	dataFiltering: false,
    	dataFiltered: false,

    	//sorting callbacks
    	dataSorting: function dataSorting() {},
    	dataSorted: function dataSorted() {},

    	//grouping callbacks
    	groupToggleElement: "arrow",
    	groupClosedShowCalcs: false,
    	dataGrouping: function dataGrouping() {},
    	dataGrouped: false,
    	groupVisibilityChanged: function groupVisibilityChanged() {},
    	groupClick: false,
    	groupDblClick: false,
    	groupContext: false,
    	groupContextMenu: false,
    	groupClickMenu: false,
    	groupTap: false,
    	groupDblTap: false,
    	groupTapHold: false,

    	columnCalcs: true,

    	//pagination callbacks
    	pageLoaded: function pageLoaded() {},

    	//localization callbacks
    	localized: function localized() {},

    	//validation callbacks
    	validationMode: "blocking",
    	validationFailed: function validationFailed() {},

    	//history callbacks
    	historyUndo: function historyUndo() {},
    	historyRedo: function historyRedo() {},

    	//scroll callbacks
    	scrollHorizontal: function scrollHorizontal() {},
    	scrollVertical: function scrollVertical() {}
    };

    Tabulator.prototype.initializeOptions = function (options) {

    	//warn user if option is not available
    	if (options.invalidOptionWarnings !== false) {
    		for (var key in options) {
    			if (typeof this.defaultOptions[key] === "undefined") {
    				console.warn("Invalid table constructor option:", key);
    			}
    		}
    	}

    	//assign options to table
    	for (var key in this.defaultOptions) {
    		if (key in options) {
    			this.options[key] = options[key];
    		} else {
    			if (Array.isArray(this.defaultOptions[key])) {
    				this.options[key] = Object.assign([], this.defaultOptions[key]);
    			} else if (_typeof(this.defaultOptions[key]) === "object" && this.defaultOptions[key] !== null) {
    				this.options[key] = Object.assign({}, this.defaultOptions[key]);
    			} else {
    				this.options[key] = this.defaultOptions[key];
    			}
    		}
    	}
    };

    Tabulator.prototype.initializeElement = function (element) {

    	if (typeof HTMLElement !== "undefined" && element instanceof HTMLElement) {
    		this.element = element;
    		return true;
    	} else if (typeof element === "string") {
    		this.element = document.querySelector(element);

    		if (this.element) {
    			return true;
    		} else {
    			console.error("Tabulator Creation Error - no element found matching selector: ", element);
    			return false;
    		}
    	} else {
    		console.error("Tabulator Creation Error - Invalid element provided:", element);
    		return false;
    	}
    };

    Tabulator.prototype.rtlCheck = function () {
    	var style = window.getComputedStyle(this.element);

    	switch (this.options.textDirection) {
    		case "auto":
    			if (style.direction !== "rtl") {
    				break;
    			}
    		case "rtl":
    			this.element.classList.add("tabulator-rtl");
    			this.rtl = true;
    			break;

    		case "ltr":
    			this.element.classList.add("tabulator-ltr");

    		default:
    			this.rtl = false;
    	}
    };

    //convert depricated functionality to new functions
    Tabulator.prototype._mapDepricatedFunctionality = function () {

    	//map depricated persistance setup options
    	if (this.options.persistentLayout || this.options.persistentSort || this.options.persistentFilter) {
    		if (!this.options.persistence) {
    			this.options.persistence = {};
    		}
    	}

    	if (this.options.dataEdited) {
    		console.warn("DEPRECATION WARNING - dataEdited option has been deprecated, please use the dataChanged option instead");
    		this.options.dataChanged = this.options.dataEdited;
    	}

    	if (this.options.downloadDataFormatter) {
    		console.warn("DEPRECATION WARNING - downloadDataFormatter option has been deprecated");
    	}

    	if (typeof this.options.clipboardCopyHeader !== "undefined") {
    		this.options.columnHeaders = this.options.clipboardCopyHeader;
    		console.warn("DEPRECATION WARNING - clipboardCopyHeader option has been deprecated, please use the columnHeaders property on the clipboardCopyConfig option");
    	}

    	if (this.options.printVisibleRows !== true) {
    		console.warn("printVisibleRows option is deprecated, you should now use the printRowRange option");

    		this.options.persistence.printRowRange = "active";
    	}

    	if (this.options.printCopyStyle !== true) {
    		console.warn("printCopyStyle option is deprecated, you should now use the printStyled option");

    		this.options.persistence.printStyled = this.options.printCopyStyle;
    	}

    	if (this.options.persistentLayout) {
    		console.warn("persistentLayout option is deprecated, you should now use the persistence option");

    		if (this.options.persistence !== true && typeof this.options.persistence.columns === "undefined") {
    			this.options.persistence.columns = true;
    		}
    	}

    	if (this.options.persistentSort) {
    		console.warn("persistentSort option is deprecated, you should now use the persistence option");

    		if (this.options.persistence !== true && typeof this.options.persistence.sort === "undefined") {
    			this.options.persistence.sort = true;
    		}
    	}

    	if (this.options.persistentFilter) {
    		console.warn("persistentFilter option is deprecated, you should now use the persistence option");

    		if (this.options.persistence !== true && typeof this.options.persistence.filter === "undefined") {
    			this.options.persistence.filter = true;
    		}
    	}

    	if (this.options.columnVertAlign) {
    		console.warn("columnVertAlign option is deprecated, you should now use the columnHeaderVertAlign option");

    		this.options.columnHeaderVertAlign = this.options.columnVertAlign;
    	}
    };

    Tabulator.prototype._clearSelection = function () {

    	this.element.classList.add("tabulator-block-select");

    	if (window.getSelection) {
    		if (window.getSelection().empty) {
    			// Chrome
    			window.getSelection().empty();
    		} else if (window.getSelection().removeAllRanges) {
    			// Firefox
    			window.getSelection().removeAllRanges();
    		}
    	} else if (document.selection) {
    		// IE?
    		document.selection.empty();
    	}

    	this.element.classList.remove("tabulator-block-select");
    };

    //concreate table
    Tabulator.prototype._create = function () {
    	this._clearObjectPointers();

    	this._mapDepricatedFunctionality();

    	this.bindModules();

    	this.rtlCheck();

    	if (this.element.tagName === "TABLE") {
    		if (this.modExists("htmlTableImport", true)) {
    			this.modules.htmlTableImport.parseTable();
    		}
    	}

    	this.columnManager = new ColumnManager(this);
    	this.rowManager = new RowManager(this);
    	this.footerManager = new FooterManager(this);

    	this.columnManager.setRowManager(this.rowManager);
    	this.rowManager.setColumnManager(this.columnManager);

    	if (this.options.virtualDomHoz) {
    		this.vdomHoz = new VDomHoz(this);
    	}

    	this._buildElement();

    	this._loadInitialData();
    };

    //clear pointers to objects in default config object
    Tabulator.prototype._clearObjectPointers = function () {
    	this.options.columns = this.options.columns.slice(0);

    	if (!this.options.reactiveData) {
    		this.options.data = this.options.data.slice(0);
    	}
    };

    //build tabulator element
    Tabulator.prototype._buildElement = function () {
    	var _this24 = this;

    	var element = this.element,
    	    mod = this.modules,
    	    options = this.options;

    	options.tableBuilding.call(this);

    	element.classList.add("tabulator");
    	element.setAttribute("role", "grid");

    	//empty element
    	while (element.firstChild) {
    		element.removeChild(element.firstChild);
    	} //set table height
    	if (options.height) {
    		options.height = isNaN(options.height) ? options.height : options.height + "px";
    		element.style.height = options.height;
    	}

    	//set table min height
    	if (options.minHeight !== false) {
    		options.minHeight = isNaN(options.minHeight) ? options.minHeight : options.minHeight + "px";
    		element.style.minHeight = options.minHeight;
    	}

    	//set table maxHeight
    	if (options.maxHeight !== false) {
    		options.maxHeight = isNaN(options.maxHeight) ? options.maxHeight : options.maxHeight + "px";
    		element.style.maxHeight = options.maxHeight;
    	}

    	this.columnManager.initialize();
    	this.rowManager.initialize();

    	this._detectBrowser();

    	if (this.modExists("layout", true)) {
    		mod.layout.initialize(options.layout);
    	}

    	//set localization

    	mod.localize.initialize();

    	if (options.headerFilterPlaceholder !== false) {
    		mod.localize.setHeaderFilterPlaceholder(options.headerFilterPlaceholder);
    	}

    	for (var locale in options.langs) {
    		mod.localize.installLang(locale, options.langs[locale]);
    	}

    	mod.localize.setLocale(options.locale);

    	//configure placeholder element
    	if (typeof options.placeholder == "string") {

    		var el = document.createElement("div");
    		el.classList.add("tabulator-placeholder");

    		var span = document.createElement("span");
    		span.innerHTML = options.placeholder;

    		el.appendChild(span);

    		options.placeholder = el;
    	}

    	//build table elements
    	element.appendChild(this.columnManager.getElement());
    	element.appendChild(this.rowManager.getElement());

    	if (options.footerElement) {
    		this.footerManager.activate();
    	}

    	if (options.persistence && this.modExists("persistence", true)) {
    		mod.persistence.initialize();
    	}

    	if (options.movableRows && this.modExists("moveRow")) {
    		mod.moveRow.initialize();
    	}

    	if (options.autoColumns && this.options.data) {
    		this.columnManager.generateColumnsFromRowData(this.options.data);
    	}

    	if (this.modExists("columnCalcs")) {
    		mod.columnCalcs.initialize();
    	}

    	this.columnManager.setColumns(options.columns);

    	if (options.dataTree && this.modExists("dataTree", true)) {
    		mod.dataTree.initialize();
    	}

    	if (this.modExists("frozenRows")) {
    		this.modules.frozenRows.initialize();
    	}

    	if ((options.persistence && this.modExists("persistence", true) && mod.persistence.config.sort || options.initialSort) && this.modExists("sort", true)) {
    		var sorters = [];

    		if (options.persistence && this.modExists("persistence", true) && mod.persistence.config.sort) {
    			sorters = mod.persistence.load("sort");

    			if (sorters === false && options.initialSort) {
    				sorters = options.initialSort;
    			}
    		} else if (options.initialSort) {
    			sorters = options.initialSort;
    		}

    		mod.sort.setSort(sorters);
    	}

    	if ((options.persistence && this.modExists("persistence", true) && mod.persistence.config.filter || options.initialFilter) && this.modExists("filter", true)) {
    		var filters = [];

    		if (options.persistence && this.modExists("persistence", true) && mod.persistence.config.filter) {
    			filters = mod.persistence.load("filter");

    			if (filters === false && options.initialFilter) {
    				filters = options.initialFilter;
    			}
    		} else if (options.initialFilter) {
    			filters = options.initialFilter;
    		}

    		mod.filter.setFilter(filters);
    	}

    	if (options.initialHeaderFilter && this.modExists("filter", true)) {
    		options.initialHeaderFilter.forEach(function (item) {

    			var column = _this24.columnManager.findColumn(item.field);

    			if (column) {
    				mod.filter.setHeaderFilterValue(column, item.value);
    			} else {
    				console.warn("Column Filter Error - No matching column found:", item.field);
    				return false;
    			}
    		});
    	}

    	if (this.modExists("ajax")) {
    		mod.ajax.initialize();
    	}

    	if (options.pagination && this.modExists("page", true)) {
    		mod.page.initialize();
    	}

    	if (options.groupBy && this.modExists("groupRows", true)) {
    		mod.groupRows.initialize();
    	}

    	if (this.modExists("keybindings")) {
    		mod.keybindings.initialize();
    	}

    	if (this.modExists("selectRow")) {
    		mod.selectRow.clearSelectionData(true);
    	}

    	if (options.autoResize && this.modExists("resizeTable")) {
    		mod.resizeTable.initialize();
    	}

    	if (this.modExists("clipboard")) {
    		mod.clipboard.initialize();
    	}

    	if (options.printAsHtml && this.modExists("print")) {
    		mod.print.initialize();
    	}

    	options.tableBuilt.call(this);
    };

    Tabulator.prototype._loadInitialData = function () {
    	var self = this;

    	if (self.options.pagination && self.modExists("page")) {
    		self.modules.page.reset(true, true);

    		if (self.options.pagination == "local") {
    			if (self.options.data.length) {
    				self.rowManager.setData(self.options.data, false, true);
    			} else {
    				if ((self.options.ajaxURL || self.options.ajaxURLGenerator) && self.modExists("ajax")) {
    					self.modules.ajax.loadData(false, true).then(function () {}).catch(function () {
    						if (self.options.paginationInitialPage) {
    							self.modules.page.setPage(self.options.paginationInitialPage);
    						}
    					});

    					return;
    				} else {
    					self.rowManager.setData(self.options.data, false, true);
    				}
    			}

    			if (self.options.paginationInitialPage) {
    				self.modules.page.setPage(self.options.paginationInitialPage);
    			}
    		} else {
    			if (self.options.ajaxURL) {
    				self.modules.page.setPage(self.options.paginationInitialPage).then(function () {}).catch(function () {});
    			} else {
    				self.rowManager.setData([], false, true);
    			}
    		}
    	} else {
    		if (self.options.data.length) {
    			self.rowManager.setData(self.options.data);
    		} else {
    			if ((self.options.ajaxURL || self.options.ajaxURLGenerator) && self.modExists("ajax")) {
    				self.modules.ajax.loadData(false, true).then(function () {}).catch(function () {});
    			} else {
    				self.rowManager.setData(self.options.data, false, true);
    			}
    		}
    	}
    };

    //deconstructor
    Tabulator.prototype.destroy = function () {
    	var element = this.element;

    	Tabulator.prototype.comms.deregister(this); //deregister table from inderdevice communication

    	if (this.options.reactiveData && this.modExists("reactiveData", true)) {
    		this.modules.reactiveData.unwatchData();
    	}

    	//clear row data
    	this.rowManager.rows.forEach(function (row) {
    		row.wipe();
    	});

    	this.rowManager.rows = [];
    	this.rowManager.activeRows = [];
    	this.rowManager.displayRows = [];

    	//clear event bindings
    	if (this.options.autoResize && this.modExists("resizeTable")) {
    		this.modules.resizeTable.clearBindings();
    	}

    	if (this.modExists("keybindings")) {
    		this.modules.keybindings.clearBindings();
    	}

    	//clear DOM
    	while (element.firstChild) {
    		element.removeChild(element.firstChild);
    	}element.classList.remove("tabulator");
    };

    Tabulator.prototype._detectBrowser = function () {
    	var ua = navigator.userAgent || navigator.vendor || window.opera;

    	if (ua.indexOf("Trident") > -1) {
    		this.browser = "ie";
    		this.browserSlow = true;
    	} else if (ua.indexOf("Edge") > -1) {
    		this.browser = "edge";
    		this.browserSlow = true;
    	} else if (ua.indexOf("Firefox") > -1) {
    		this.browser = "firefox";
    		this.browserSlow = false;
    	} else {
    		this.browser = "other";
    		this.browserSlow = false;
    	}

    	this.browserMobile = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(ua) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(ua.substr(0, 4));
    };

    ////////////////// Data Handling //////////////////

    //block table redrawing
    Tabulator.prototype.blockRedraw = function () {
    	return this.rowManager.blockRedraw();
    };

    //restore table redrawing
    Tabulator.prototype.restoreRedraw = function () {
    	return this.rowManager.restoreRedraw();
    };

    //local data from local file
    Tabulator.prototype.setDataFromLocalFile = function (extensions) {
    	var _this25 = this;

    	return new Promise(function (resolve, reject) {
    		var input = document.createElement("input");
    		input.type = "file";
    		input.accept = extensions || ".json,application/json";

    		input.addEventListener("change", function (e) {
    			var file = input.files[0],
    			    reader = new FileReader(),
    			    data;

    			reader.readAsText(file);

    			reader.onload = function (e) {

    				try {
    					data = JSON.parse(reader.result);
    				} catch (e) {
    					console.warn("File Load Error - File contents is invalid JSON", e);
    					reject(e);
    					return;
    				}

    				_this25.setData(data).then(function (data) {
    					resolve(data);
    				}).catch(function (err) {
    					resolve(err);
    				});
    			};

    			reader.onerror = function (e) {
    				console.warn("File Load Error - Unable to read file");
    				reject();
    			};
    		});

    		input.click();
    	});
    };

    //load data
    Tabulator.prototype.setData = function (data, params, config) {
    	if (this.modExists("ajax")) {
    		this.modules.ajax.blockActiveRequest();
    	}

    	return this._setData(data, params, config, false, true);
    };

    Tabulator.prototype._setData = function (data, params, config, inPosition, columnsChanged) {
    	var self = this;

    	if (typeof data === "string") {
    		if (data.indexOf("{") == 0 || data.indexOf("[") == 0) {
    			//data is a json encoded string
    			return self.rowManager.setData(JSON.parse(data), inPosition, columnsChanged);
    		} else {

    			if (self.modExists("ajax", true)) {
    				if (params) {
    					self.modules.ajax.setParams(params);
    				}

    				if (config) {
    					self.modules.ajax.setConfig(config);
    				}

    				self.modules.ajax.setUrl(data);

    				if (self.options.pagination == "remote" && self.modExists("page", true)) {
    					self.modules.page.reset(true, true);
    					return self.modules.page.setPage(1);
    				} else {
    					//assume data is url, make ajax call to url to get data
    					return self.modules.ajax.loadData(inPosition, columnsChanged);
    				}
    			}
    		}
    	} else {
    		if (data) {
    			//asume data is already an object
    			return self.rowManager.setData(data, inPosition, columnsChanged);
    		} else {

    			//no data provided, check if ajaxURL is present;
    			if (self.modExists("ajax") && (self.modules.ajax.getUrl || self.options.ajaxURLGenerator)) {

    				if (self.options.pagination == "remote" && self.modExists("page", true)) {
    					self.modules.page.reset(true, true);
    					return self.modules.page.setPage(1);
    				} else {
    					return self.modules.ajax.loadData(inPosition, columnsChanged);
    				}
    			} else {
    				//empty data
    				return self.rowManager.setData([], inPosition, columnsChanged);
    			}
    		}
    	}
    };

    //clear data
    Tabulator.prototype.clearData = function () {
    	if (this.modExists("ajax")) {
    		this.modules.ajax.blockActiveRequest();
    	}

    	this.rowManager.clearData();
    };

    //get table data array
    Tabulator.prototype.getData = function (active) {

    	if (active === true) {
    		console.warn("passing a boolean to the getData function is deprecated, you should now pass the string 'active'");
    		active = "active";
    	}

    	return this.rowManager.getData(active);
    };

    //get table data array count
    Tabulator.prototype.getDataCount = function (active) {

    	if (active === true) {
    		console.warn("passing a boolean to the getDataCount function is deprecated, you should now pass the string 'active'");
    		active = "active";
    	}

    	return this.rowManager.getDataCount(active);
    };

    //search for specific row components
    Tabulator.prototype.searchRows = function (field, type, value) {
    	if (this.modExists("filter", true)) {
    		return this.modules.filter.search("rows", field, type, value);
    	}
    };

    //search for specific data
    Tabulator.prototype.searchData = function (field, type, value) {
    	if (this.modExists("filter", true)) {
    		return this.modules.filter.search("data", field, type, value);
    	}
    };

    //get table html
    Tabulator.prototype.getHtml = function (visible, style, config) {
    	if (this.modExists("export", true)) {
    		return this.modules.export.getHtml(visible, style, config);
    	}
    };

    //get print html
    Tabulator.prototype.print = function (visible, style, config) {
    	if (this.modExists("print", true)) {
    		return this.modules.print.printFullscreen(visible, style, config);
    	}
    };

    //retrieve Ajax URL
    Tabulator.prototype.getAjaxUrl = function () {
    	if (this.modExists("ajax", true)) {
    		return this.modules.ajax.getUrl();
    	}
    };

    //replace data, keeping table in position with same sort
    Tabulator.prototype.replaceData = function (data, params, config) {
    	if (this.modExists("ajax")) {
    		this.modules.ajax.blockActiveRequest();
    	}

    	return this._setData(data, params, config, true);
    };

    //update table data
    Tabulator.prototype.updateData = function (data) {
    	var _this26 = this;

    	var self = this;
    	var responses = 0;

    	return new Promise(function (resolve, reject) {
    		if (_this26.modExists("ajax")) {
    			_this26.modules.ajax.blockActiveRequest();
    		}

    		if (typeof data === "string") {
    			data = JSON.parse(data);
    		}

    		if (data) {
    			data.forEach(function (item) {
    				var row = self.rowManager.findRow(item[self.options.index]);

    				if (row) {
    					responses++;

    					row.updateData(item).then(function () {
    						responses--;

    						if (!responses) {
    							resolve();
    						}
    					});
    				}
    			});
    		} else {
    			console.warn("Update Error - No data provided");
    			reject("Update Error - No data provided");
    		}
    	});
    };

    Tabulator.prototype.addData = function (data, pos, index) {
    	var _this27 = this;

    	return new Promise(function (resolve, reject) {
    		if (_this27.modExists("ajax")) {
    			_this27.modules.ajax.blockActiveRequest();
    		}

    		if (typeof data === "string") {
    			data = JSON.parse(data);
    		}

    		if (data) {
    			_this27.rowManager.addRows(data, pos, index).then(function (rows) {
    				var output = [];

    				rows.forEach(function (row) {
    					output.push(row.getComponent());
    				});

    				resolve(output);
    			});
    		} else {
    			console.warn("Update Error - No data provided");
    			reject("Update Error - No data provided");
    		}
    	});
    };

    //update table data
    Tabulator.prototype.updateOrAddData = function (data) {
    	var _this28 = this;

    	var self = this,
    	    rows = [],
    	    responses = 0;

    	return new Promise(function (resolve, reject) {
    		if (_this28.modExists("ajax")) {
    			_this28.modules.ajax.blockActiveRequest();
    		}

    		if (typeof data === "string") {
    			data = JSON.parse(data);
    		}

    		if (data) {
    			data.forEach(function (item) {
    				var row = self.rowManager.findRow(item[self.options.index]);

    				responses++;

    				if (row) {
    					row.updateData(item).then(function () {
    						responses--;
    						rows.push(row.getComponent());

    						if (!responses) {
    							resolve(rows);
    						}
    					});
    				} else {
    					self.rowManager.addRows(item).then(function (newRows) {
    						responses--;
    						rows.push(newRows[0].getComponent());

    						if (!responses) {
    							resolve(rows);
    						}
    					});
    				}
    			});
    		} else {
    			console.warn("Update Error - No data provided");
    			reject("Update Error - No data provided");
    		}
    	});
    };

    //get row object
    Tabulator.prototype.getRow = function (index) {
    	var row = this.rowManager.findRow(index);

    	if (row) {
    		return row.getComponent();
    	} else {
    		console.warn("Find Error - No matching row found:", index);
    		return false;
    	}
    };

    //get row object
    Tabulator.prototype.getRowFromPosition = function (position, active) {
    	var row = this.rowManager.getRowFromPosition(position, active);

    	if (row) {
    		return row.getComponent();
    	} else {
    		console.warn("Find Error - No matching row found:", position);
    		return false;
    	}
    };

    //delete row from table
    Tabulator.prototype.deleteRow = function (index) {
    	var _this29 = this;

    	return new Promise(function (resolve, reject) {
    		var self = _this29,
    		    count = 0,
    		    successCount = 0,
    		    foundRows = [];

    		function doneCheck() {
    			count++;

    			if (count == index.length) {
    				if (successCount) {
    					self.rowManager.reRenderInPosition();
    					resolve();
    				}
    			}
    		}

    		if (!Array.isArray(index)) {
    			index = [index];
    		}

    		//find matching rows
    		index.forEach(function (item) {
    			var row = _this29.rowManager.findRow(item, true);

    			if (row) {
    				foundRows.push(row);
    			} else {
    				console.warn("Delete Error - No matching row found:", item);
    				reject("Delete Error - No matching row found");
    				doneCheck();
    			}
    		});

    		//sort rows into correct order to ensure smooth delete from table
    		foundRows.sort(function (a, b) {
    			return _this29.rowManager.rows.indexOf(a) > _this29.rowManager.rows.indexOf(b) ? 1 : -1;
    		});

    		foundRows.forEach(function (row) {
    			row.delete().then(function () {
    				successCount++;
    				doneCheck();
    			}).catch(function (err) {
    				doneCheck();
    				reject(err);
    			});
    		});
    	});
    };

    //add row to table
    Tabulator.prototype.addRow = function (data, pos, index) {
    	var _this30 = this;

    	return new Promise(function (resolve, reject) {
    		if (typeof data === "string") {
    			data = JSON.parse(data);
    		}

    		_this30.rowManager.addRows(data, pos, index).then(function (rows) {
    			//recalc column calculations if present
    			if (_this30.modExists("columnCalcs")) {
    				_this30.modules.columnCalcs.recalc(_this30.rowManager.activeRows);
    			}

    			resolve(rows[0].getComponent());
    		});
    	});
    };

    //update a row if it exitsts otherwise create it
    Tabulator.prototype.updateOrAddRow = function (index, data) {
    	var _this31 = this;

    	return new Promise(function (resolve, reject) {
    		var row = _this31.rowManager.findRow(index);

    		if (typeof data === "string") {
    			data = JSON.parse(data);
    		}

    		if (row) {
    			row.updateData(data).then(function () {
    				//recalc column calculations if present
    				if (_this31.modExists("columnCalcs")) {
    					_this31.modules.columnCalcs.recalc(_this31.rowManager.activeRows);
    				}

    				resolve(row.getComponent());
    			}).catch(function (err) {
    				reject(err);
    			});
    		} else {
    			row = _this31.rowManager.addRows(data).then(function (rows) {
    				//recalc column calculations if present
    				if (_this31.modExists("columnCalcs")) {
    					_this31.modules.columnCalcs.recalc(_this31.rowManager.activeRows);
    				}

    				resolve(rows[0].getComponent());
    			}).catch(function (err) {
    				reject(err);
    			});
    		}
    	});
    };

    //update row data
    Tabulator.prototype.updateRow = function (index, data) {
    	var _this32 = this;

    	return new Promise(function (resolve, reject) {
    		var row = _this32.rowManager.findRow(index);

    		if (typeof data === "string") {
    			data = JSON.parse(data);
    		}

    		if (row) {
    			row.updateData(data).then(function () {
    				resolve(row.getComponent());
    			}).catch(function (err) {
    				reject(err);
    			});
    		} else {
    			console.warn("Update Error - No matching row found:", index);
    			reject("Update Error - No matching row found");
    		}
    	});
    };

    //scroll to row in DOM
    Tabulator.prototype.scrollToRow = function (index, position, ifVisible) {
    	var _this33 = this;

    	return new Promise(function (resolve, reject) {
    		var row = _this33.rowManager.findRow(index);

    		if (row) {
    			_this33.rowManager.scrollToRow(row, position, ifVisible).then(function () {
    				resolve();
    			}).catch(function (err) {
    				reject(err);
    			});
    		} else {
    			console.warn("Scroll Error - No matching row found:", index);
    			reject("Scroll Error - No matching row found");
    		}
    	});
    };

    Tabulator.prototype.moveRow = function (from, to, after) {
    	var fromRow = this.rowManager.findRow(from);

    	if (fromRow) {
    		fromRow.moveToRow(to, after);
    	} else {
    		console.warn("Move Error - No matching row found:", from);
    	}
    };

    Tabulator.prototype.getRows = function (active) {

    	if (active === true) {
    		console.warn("passing a boolean to the getRows function is deprecated, you should now pass the string 'active'");
    		active = "active";
    	}

    	return this.rowManager.getComponents(active);
    };

    //get position of row in table
    Tabulator.prototype.getRowPosition = function (index, active) {
    	var row = this.rowManager.findRow(index);

    	if (row) {
    		return this.rowManager.getRowPosition(row, active);
    	} else {
    		console.warn("Position Error - No matching row found:", index);
    		return false;
    	}
    };

    //copy table data to clipboard
    Tabulator.prototype.copyToClipboard = function (selector) {
    	if (this.modExists("clipboard", true)) {
    		this.modules.clipboard.copy(selector);
    	}
    };

    /////////////// Column Functions  ///////////////

    Tabulator.prototype.setColumns = function (definition) {
    	this.columnManager.setColumns(definition);
    };

    Tabulator.prototype.getColumns = function (structured) {
    	return this.columnManager.getComponents(structured);
    };

    Tabulator.prototype.getColumn = function (field) {
    	var col = this.columnManager.findColumn(field);

    	if (col) {
    		return col.getComponent();
    	} else {
    		console.warn("Find Error - No matching column found:", field);
    		return false;
    	}
    };

    Tabulator.prototype.getColumnDefinitions = function () {
    	return this.columnManager.getDefinitionTree();
    };

    Tabulator.prototype.getColumnLayout = function () {
    	if (this.modExists("persistence", true)) {
    		return this.modules.persistence.parseColumns(this.columnManager.getColumns());
    	}
    };

    Tabulator.prototype.setColumnLayout = function (layout) {
    	if (this.modExists("persistence", true)) {
    		this.columnManager.setColumns(this.modules.persistence.mergeDefinition(this.options.columns, layout));
    		return true;
    	}
    	return false;
    };

    Tabulator.prototype.showColumn = function (field) {
    	var column = this.columnManager.findColumn(field);

    	if (column) {
    		column.show();

    		if (this.options.responsiveLayout && this.modExists("responsiveLayout", true)) {
    			this.modules.responsiveLayout.update();
    		}
    	} else {
    		console.warn("Column Show Error - No matching column found:", field);
    		return false;
    	}
    };

    Tabulator.prototype.hideColumn = function (field) {
    	var column = this.columnManager.findColumn(field);

    	if (column) {
    		column.hide();

    		if (this.options.responsiveLayout && this.modExists("responsiveLayout", true)) {
    			this.modules.responsiveLayout.update();
    		}
    	} else {
    		console.warn("Column Hide Error - No matching column found:", field);
    		return false;
    	}
    };

    Tabulator.prototype.toggleColumn = function (field) {
    	var column = this.columnManager.findColumn(field);

    	if (column) {
    		if (column.visible) {
    			column.hide();
    		} else {
    			column.show();
    		}
    	} else {
    		console.warn("Column Visibility Toggle Error - No matching column found:", field);
    		return false;
    	}
    };

    Tabulator.prototype.addColumn = function (definition, before, field) {
    	var _this34 = this;

    	return new Promise(function (resolve, reject) {
    		var column = _this34.columnManager.findColumn(field);

    		_this34.columnManager.addColumn(definition, before, column).then(function (column) {
    			resolve(column.getComponent());
    		}).catch(function (err) {
    			reject(err);
    		});
    	});
    };

    Tabulator.prototype.deleteColumn = function (field) {
    	var _this35 = this;

    	return new Promise(function (resolve, reject) {
    		var column = _this35.columnManager.findColumn(field);

    		if (column) {
    			column.delete().then(function () {
    				resolve();
    			}).catch(function (err) {
    				reject(err);
    			});
    		} else {
    			console.warn("Column Delete Error - No matching column found:", field);
    			reject();
    		}
    	});
    };

    Tabulator.prototype.updateColumnDefinition = function (field, definition) {
    	var _this36 = this;

    	return new Promise(function (resolve, reject) {
    		var column = _this36.columnManager.findColumn(field);

    		if (column) {
    			column.updateDefinition(definition).then(function (col) {
    				resolve(col);
    			}).catch(function (err) {
    				reject(err);
    			});
    		} else {
    			console.warn("Column Update Error - No matching column found:", field);
    			reject();
    		}
    	});
    };

    Tabulator.prototype.moveColumn = function (from, to, after) {
    	var fromColumn = this.columnManager.findColumn(from);
    	var toColumn = this.columnManager.findColumn(to);

    	if (fromColumn) {
    		if (toColumn) {
    			this.columnManager.moveColumn(fromColumn, toColumn, after);
    		} else {
    			console.warn("Move Error - No matching column found:", toColumn);
    		}
    	} else {
    		console.warn("Move Error - No matching column found:", from);
    	}
    };

    //scroll to column in DOM
    Tabulator.prototype.scrollToColumn = function (field, position, ifVisible) {
    	var _this37 = this;

    	return new Promise(function (resolve, reject) {
    		var column = _this37.columnManager.findColumn(field);

    		if (column) {
    			_this37.columnManager.scrollToColumn(column, position, ifVisible).then(function () {
    				resolve();
    			}).catch(function (err) {
    				reject(err);
    			});
    		} else {
    			console.warn("Scroll Error - No matching column found:", field);
    			reject("Scroll Error - No matching column found");
    		}
    	});
    };

    //////////// Localization Functions  ////////////
    Tabulator.prototype.setLocale = function (locale) {
    	this.modules.localize.setLocale(locale);
    };

    Tabulator.prototype.getLocale = function () {
    	return this.modules.localize.getLocale();
    };

    Tabulator.prototype.getLang = function (locale) {
    	return this.modules.localize.getLang(locale);
    };

    //////////// General Public Functions ////////////

    //redraw list without updating data
    Tabulator.prototype.redraw = function (force) {
    	this.columnManager.redraw(force);
    	this.rowManager.redraw(force);
    };

    Tabulator.prototype.setHeight = function (height) {

    	if (this.rowManager.renderMode !== "classic") {
    		this.options.height = isNaN(height) ? height : height + "px";
    		this.element.style.height = this.options.height;
    		this.rowManager.setRenderMode();
    		this.rowManager.redraw();
    	} else {
    		console.warn("setHeight function is not available in classic render mode");
    	}
    };

    ///////////////////// Sorting ////////////////////

    //trigger sort
    Tabulator.prototype.setSort = function (sortList, dir) {
    	if (this.modExists("sort", true)) {
    		this.modules.sort.setSort(sortList, dir);
    		this.rowManager.sorterRefresh();
    	}
    };

    Tabulator.prototype.getSorters = function () {
    	if (this.modExists("sort", true)) {
    		return this.modules.sort.getSort();
    	}
    };

    Tabulator.prototype.clearSort = function () {
    	if (this.modExists("sort", true)) {
    		this.modules.sort.clear();
    		this.rowManager.sorterRefresh();
    	}
    };

    ///////////////////// Filtering ////////////////////

    //set standard filters
    Tabulator.prototype.setFilter = function (field, type, value, params) {
    	if (this.modExists("filter", true)) {
    		this.modules.filter.setFilter(field, type, value, params);
    		this.rowManager.filterRefresh();
    	}
    };

    //set standard filters
    Tabulator.prototype.refreshFilter = function () {
    	if (this.modExists("filter", true)) {
    		this.rowManager.filterRefresh();
    	}
    };

    //add filter to array
    Tabulator.prototype.addFilter = function (field, type, value, params) {
    	if (this.modExists("filter", true)) {
    		this.modules.filter.addFilter(field, type, value, params);
    		this.rowManager.filterRefresh();
    	}
    };

    //get all filters
    Tabulator.prototype.getFilters = function (all) {
    	if (this.modExists("filter", true)) {
    		return this.modules.filter.getFilters(all);
    	}
    };

    Tabulator.prototype.setHeaderFilterFocus = function (field) {
    	if (this.modExists("filter", true)) {
    		var column = this.columnManager.findColumn(field);

    		if (column) {
    			this.modules.filter.setHeaderFilterFocus(column);
    		} else {
    			console.warn("Column Filter Focus Error - No matching column found:", field);
    			return false;
    		}
    	}
    };

    Tabulator.prototype.getHeaderFilterValue = function (field) {
    	if (this.modExists("filter", true)) {
    		var column = this.columnManager.findColumn(field);

    		if (column) {
    			return this.modules.filter.getHeaderFilterValue(column);
    		} else {
    			console.warn("Column Filter Error - No matching column found:", field);
    		}
    	}
    };

    Tabulator.prototype.setHeaderFilterValue = function (field, value) {
    	if (this.modExists("filter", true)) {
    		var column = this.columnManager.findColumn(field);

    		if (column) {
    			this.modules.filter.setHeaderFilterValue(column, value);
    		} else {
    			console.warn("Column Filter Error - No matching column found:", field);
    			return false;
    		}
    	}
    };

    Tabulator.prototype.getHeaderFilters = function () {
    	if (this.modExists("filter", true)) {
    		return this.modules.filter.getHeaderFilters();
    	}
    };

    //remove filter from array
    Tabulator.prototype.removeFilter = function (field, type, value) {
    	if (this.modExists("filter", true)) {
    		this.modules.filter.removeFilter(field, type, value);
    		this.rowManager.filterRefresh();
    	}
    };

    //clear filters
    Tabulator.prototype.clearFilter = function (all) {
    	if (this.modExists("filter", true)) {
    		this.modules.filter.clearFilter(all);
    		this.rowManager.filterRefresh();
    	}
    };

    //clear header filters
    Tabulator.prototype.clearHeaderFilter = function () {
    	if (this.modExists("filter", true)) {
    		this.modules.filter.clearHeaderFilter();
    		this.rowManager.filterRefresh();
    	}
    };

    ///////////////////// select ////////////////////
    Tabulator.prototype.selectRow = function (rows) {
    	if (this.modExists("selectRow", true)) {
    		if (rows === true) {
    			console.warn("passing a boolean to the selectRowselectRow function is deprecated, you should now pass the string 'active'");
    			rows = "active";
    		}
    		this.modules.selectRow.selectRows(rows);
    	}
    };

    Tabulator.prototype.deselectRow = function (rows) {
    	if (this.modExists("selectRow", true)) {
    		this.modules.selectRow.deselectRows(rows);
    	}
    };

    Tabulator.prototype.toggleSelectRow = function (row) {
    	if (this.modExists("selectRow", true)) {
    		this.modules.selectRow.toggleRow(row);
    	}
    };

    Tabulator.prototype.getSelectedRows = function () {
    	if (this.modExists("selectRow", true)) {
    		return this.modules.selectRow.getSelectedRows();
    	}
    };

    Tabulator.prototype.getSelectedData = function () {
    	if (this.modExists("selectRow", true)) {
    		return this.modules.selectRow.getSelectedData();
    	}
    };

    ///////////////////// validation  ////////////////////
    Tabulator.prototype.getInvalidCells = function () {
    	if (this.modExists("validate", true)) {
    		return this.modules.validate.getInvalidCells();
    	}
    };

    Tabulator.prototype.clearCellValidation = function (cells) {
    	var _this38 = this;

    	if (this.modExists("validate", true)) {

    		if (!cells) {
    			cells = this.modules.validate.getInvalidCells();
    		}

    		if (!Array.isArray(cells)) {
    			cells = [cells];
    		}

    		cells.forEach(function (cell) {
    			_this38.modules.validate.clearValidation(cell._getSelf());
    		});
    	}
    };

    Tabulator.prototype.validate = function (cells) {
    	var output = [];

    	//clear row data
    	this.rowManager.rows.forEach(function (row) {
    		var valid = row.validate();

    		if (valid !== true) {
    			output = output.concat(valid);
    		}
    	});

    	return output.length ? output : true;
    };

    //////////// Pagination Functions  ////////////

    Tabulator.prototype.setMaxPage = function (max) {
    	if (this.options.pagination && this.modExists("page")) {
    		this.modules.page.setMaxPage(max);
    	} else {
    		return false;
    	}
    };

    Tabulator.prototype.setPage = function (page) {
    	if (this.options.pagination && this.modExists("page")) {
    		return this.modules.page.setPage(page);
    	} else {
    		return new Promise(function (resolve, reject) {
    			reject();
    		});
    	}
    };

    Tabulator.prototype.setPageToRow = function (row) {
    	var _this39 = this;

    	return new Promise(function (resolve, reject) {
    		if (_this39.options.pagination && _this39.modExists("page")) {
    			row = _this39.rowManager.findRow(row);

    			if (row) {
    				_this39.modules.page.setPageToRow(row).then(function () {
    					resolve();
    				}).catch(function () {
    					reject();
    				});
    			} else {
    				reject();
    			}
    		} else {
    			reject();
    		}
    	});
    };

    Tabulator.prototype.setPageSize = function (size) {
    	if (this.options.pagination && this.modExists("page")) {
    		this.modules.page.setPageSize(size);
    		this.modules.page.setPage(1).then(function () {}).catch(function () {});
    	} else {
    		return false;
    	}
    };

    Tabulator.prototype.getPageSize = function () {
    	if (this.options.pagination && this.modExists("page", true)) {
    		return this.modules.page.getPageSize();
    	}
    };

    Tabulator.prototype.previousPage = function () {
    	if (this.options.pagination && this.modExists("page")) {
    		this.modules.page.previousPage();
    	} else {
    		return false;
    	}
    };

    Tabulator.prototype.nextPage = function () {
    	if (this.options.pagination && this.modExists("page")) {
    		this.modules.page.nextPage();
    	} else {
    		return false;
    	}
    };

    Tabulator.prototype.getPage = function () {
    	if (this.options.pagination && this.modExists("page")) {
    		return this.modules.page.getPage();
    	} else {
    		return false;
    	}
    };

    Tabulator.prototype.getPageMax = function () {
    	if (this.options.pagination && this.modExists("page")) {
    		return this.modules.page.getPageMax();
    	} else {
    		return false;
    	}
    };

    ///////////////// Grouping Functions ///////////////

    Tabulator.prototype.setGroupBy = function (groups) {
    	if (this.modExists("groupRows", true)) {
    		this.options.groupBy = groups;
    		this.modules.groupRows.initialize();
    		this.rowManager.refreshActiveData("display");

    		if (this.options.persistence && this.modExists("persistence", true) && this.modules.persistence.config.group) {
    			this.modules.persistence.save("group");
    		}
    	} else {
    		return false;
    	}
    };

    Tabulator.prototype.setGroupValues = function (groupValues) {
    	if (this.modExists("groupRows", true)) {
    		this.options.groupValues = groupValues;
    		this.modules.groupRows.initialize();
    		this.rowManager.refreshActiveData("display");

    		if (this.options.persistence && this.modExists("persistence", true) && this.modules.persistence.config.group) {
    			this.modules.persistence.save("group");
    		}
    	} else {
    		return false;
    	}
    };

    Tabulator.prototype.setGroupStartOpen = function (values) {
    	if (this.modExists("groupRows", true)) {
    		this.options.groupStartOpen = values;
    		this.modules.groupRows.initialize();
    		if (this.options.groupBy) {
    			this.rowManager.refreshActiveData("group");

    			if (this.options.persistence && this.modExists("persistence", true) && this.modules.persistence.config.group) {
    				this.modules.persistence.save("group");
    			}
    		} else {
    			console.warn("Grouping Update - cant refresh view, no groups have been set");
    		}
    	} else {
    		return false;
    	}
    };

    Tabulator.prototype.setGroupHeader = function (values) {
    	if (this.modExists("groupRows", true)) {
    		this.options.groupHeader = values;
    		this.modules.groupRows.initialize();
    		if (this.options.groupBy) {
    			this.rowManager.refreshActiveData("group");

    			if (this.options.persistence && this.modExists("persistence", true) && this.modules.persistence.config.group) {
    				this.modules.persistence.save("group");
    			}
    		} else {
    			console.warn("Grouping Update - cant refresh view, no groups have been set");
    		}
    	} else {
    		return false;
    	}
    };

    Tabulator.prototype.getGroups = function (values) {
    	if (this.modExists("groupRows", true)) {
    		return this.modules.groupRows.getGroups(true);
    	} else {
    		return false;
    	}
    };

    // get grouped table data in the same format as getData()
    Tabulator.prototype.getGroupedData = function () {
    	if (this.modExists("groupRows", true)) {
    		return this.options.groupBy ? this.modules.groupRows.getGroupedData() : this.getData();
    	}
    };

    Tabulator.prototype.getEditedCells = function () {
    	if (this.modExists("edit", true)) {
    		return this.modules.edit.getEditedCells();
    	}
    };

    Tabulator.prototype.clearCellEdited = function (cells) {
    	var _this40 = this;

    	if (this.modExists("edit", true)) {

    		if (!cells) {
    			cells = this.modules.edit.getEditedCells();
    		}

    		if (!Array.isArray(cells)) {
    			cells = [cells];
    		}

    		cells.forEach(function (cell) {
    			_this40.modules.edit.clearEdited(cell._getSelf());
    		});
    	}
    };

    ///////////////// Column Calculation Functions ///////////////
    Tabulator.prototype.getCalcResults = function () {
    	if (this.modExists("columnCalcs", true)) {
    		return this.modules.columnCalcs.getResults();
    	} else {
    		return false;
    	}
    };

    Tabulator.prototype.recalc = function () {
    	if (this.modExists("columnCalcs", true)) {
    		this.modules.columnCalcs.recalcAll(this.rowManager.activeRows);
    	}
    };

    /////////////// Navigation Management //////////////

    Tabulator.prototype.navigatePrev = function () {
    	var cell = false;

    	if (this.modExists("edit", true)) {
    		cell = this.modules.edit.currentCell;

    		if (cell) {
    			return cell.nav().prev();
    		}
    	}

    	return false;
    };

    Tabulator.prototype.navigateNext = function () {
    	var cell = false;

    	if (this.modExists("edit", true)) {
    		cell = this.modules.edit.currentCell;

    		if (cell) {
    			return cell.nav().next();
    		}
    	}

    	return false;
    };

    Tabulator.prototype.navigateLeft = function () {
    	var cell = false;

    	if (this.modExists("edit", true)) {
    		cell = this.modules.edit.currentCell;

    		if (cell) {
    			e.preventDefault();
    			return cell.nav().left();
    		}
    	}

    	return false;
    };

    Tabulator.prototype.navigateRight = function () {
    	var cell = false;

    	if (this.modExists("edit", true)) {
    		cell = this.modules.edit.currentCell;

    		if (cell) {
    			e.preventDefault();
    			return cell.nav().right();
    		}
    	}

    	return false;
    };

    Tabulator.prototype.navigateUp = function () {
    	var cell = false;

    	if (this.modExists("edit", true)) {
    		cell = this.modules.edit.currentCell;

    		if (cell) {
    			e.preventDefault();
    			return cell.nav().up();
    		}
    	}

    	return false;
    };

    Tabulator.prototype.navigateDown = function () {
    	var cell = false;

    	if (this.modExists("edit", true)) {
    		cell = this.modules.edit.currentCell;

    		if (cell) {
    			e.preventDefault();
    			return cell.nav().down();
    		}
    	}

    	return false;
    };

    /////////////// History Management //////////////
    Tabulator.prototype.undo = function () {
    	if (this.options.history && this.modExists("history", true)) {
    		return this.modules.history.undo();
    	} else {
    		return false;
    	}
    };

    Tabulator.prototype.redo = function () {
    	if (this.options.history && this.modExists("history", true)) {
    		return this.modules.history.redo();
    	} else {
    		return false;
    	}
    };

    Tabulator.prototype.getHistoryUndoSize = function () {
    	if (this.options.history && this.modExists("history", true)) {
    		return this.modules.history.getHistoryUndoSize();
    	} else {
    		return false;
    	}
    };

    Tabulator.prototype.getHistoryRedoSize = function () {
    	if (this.options.history && this.modExists("history", true)) {
    		return this.modules.history.getHistoryRedoSize();
    	} else {
    		return false;
    	}
    };

    Tabulator.prototype.clearHistory = function () {
    	if (this.options.history && this.modExists("history", true)) {
    		return this.modules.history.clear();
    	} else {
    		return false;
    	}
    };

    /////////////// Download Management //////////////

    Tabulator.prototype.download = function (type, filename, options, active) {
    	if (this.modExists("download", true)) {
    		this.modules.download.download(type, filename, options, active);
    	}
    };

    Tabulator.prototype.downloadToTab = function (type, filename, options, active) {
    	if (this.modExists("download", true)) {
    		this.modules.download.download(type, filename, options, active, true);
    	}
    };

    /////////// Inter Table Communications ///////////

    Tabulator.prototype.tableComms = function (table, module, action, data) {
    	this.modules.comms.receive(table, module, action, data);
    };

    ////////////// Extension Management //////////////

    //object to hold module
    Tabulator.prototype.moduleBindings = {};

    //extend module
    Tabulator.prototype.extendModule = function (name, property, values) {

    	if (Tabulator.prototype.moduleBindings[name]) {
    		var source = Tabulator.prototype.moduleBindings[name].prototype[property];

    		if (source) {
    			if ((typeof values === 'undefined' ? 'undefined' : _typeof(values)) == "object") {
    				for (var key in values) {
    					source[key] = values[key];
    				}
    			} else {
    				console.warn("Module Error - Invalid value type, it must be an object");
    			}
    		} else {
    			console.warn("Module Error - property does not exist:", property);
    		}
    	} else {
    		console.warn("Module Error - module does not exist:", name);
    	}
    };

    //add module to tabulator
    Tabulator.prototype.registerModule = function (name, module) {
    	Tabulator.prototype.moduleBindings[name] = module;
    };

    //ensure that module are bound to instantiated function
    Tabulator.prototype.bindModules = function () {
    	this.modules = {};

    	for (var name in Tabulator.prototype.moduleBindings) {
    		this.modules[name] = new Tabulator.prototype.moduleBindings[name](this);
    	}
    };

    //Check for module
    Tabulator.prototype.modExists = function (plugin, required) {
    	if (this.modules[plugin]) {
    		return true;
    	} else {
    		if (required) {
    			console.error("Tabulator Module Not Installed: " + plugin);
    		}
    		return false;
    	}
    };

    Tabulator.prototype.helpers = {

    	elVisible: function elVisible(el) {
    		return !(el.offsetWidth <= 0 && el.offsetHeight <= 0);
    	},

    	elOffset: function elOffset(el) {
    		var box = el.getBoundingClientRect();

    		return {
    			top: box.top + window.pageYOffset - document.documentElement.clientTop,
    			left: box.left + window.pageXOffset - document.documentElement.clientLeft
    		};
    	},

    	deepClone: function deepClone(obj) {
    		var clone = Object.assign(Array.isArray(obj) ? [] : {}, obj);

    		for (var i in obj) {
    			if (obj[i] != null && _typeof(obj[i]) === "object") {
    				if (obj[i] instanceof Date) {
    					clone[i] = new Date(obj[i]);
    				} else {
    					clone[i] = this.deepClone(obj[i]);
    				}
    			}
    		}
    		return clone;
    	}
    };

    Tabulator.prototype.comms = {
    	tables: [],
    	register: function register(table) {
    		Tabulator.prototype.comms.tables.push(table);
    	},
    	deregister: function deregister(table) {
    		var index = Tabulator.prototype.comms.tables.indexOf(table);

    		if (index > -1) {
    			Tabulator.prototype.comms.tables.splice(index, 1);
    		}
    	},
    	lookupTable: function lookupTable(query, silent) {
    		var results = [],
    		    matches,
    		    match;

    		if (typeof query === "string") {
    			matches = document.querySelectorAll(query);

    			if (matches.length) {
    				for (var i = 0; i < matches.length; i++) {
    					match = Tabulator.prototype.comms.matchElement(matches[i]);

    					if (match) {
    						results.push(match);
    					}
    				}
    			}
    		} else if (typeof HTMLElement !== "undefined" && query instanceof HTMLElement || query instanceof Tabulator) {
    			match = Tabulator.prototype.comms.matchElement(query);

    			if (match) {
    				results.push(match);
    			}
    		} else if (Array.isArray(query)) {
    			query.forEach(function (item) {
    				results = results.concat(Tabulator.prototype.comms.lookupTable(item));
    			});
    		} else {
    			if (!silent) {
    				console.warn("Table Connection Error - Invalid Selector", query);
    			}
    		}

    		return results;
    	},
    	matchElement: function matchElement(element) {
    		return Tabulator.prototype.comms.tables.find(function (table) {
    			return element instanceof Tabulator ? table === element : table.element === element;
    		});
    	}
    };

    Tabulator.prototype.findTable = function (query) {
    	var results = Tabulator.prototype.comms.lookupTable(query, true);
    	return Array.isArray(results) && !results.length ? false : results;
    };

    var Layout = function Layout(table) {

    	this.table = table;

    	this.mode = null;
    };

    //initialize layout system

    Layout.prototype.initialize = function (layout) {

    	if (this.modes[layout]) {

    		this.mode = layout;
    	} else {

    		console.warn("Layout Error - invalid mode set, defaulting to 'fitData' : " + layout);

    		this.mode = 'fitData';
    	}

    	this.table.element.setAttribute("tabulator-layout", this.mode);
    };

    Layout.prototype.getMode = function () {

    	return this.mode;
    };

    //trigger table layout

    Layout.prototype.layout = function () {

    	this.modes[this.mode].call(this, this.table.columnManager.columnsByIndex);

    	if (this.mode.indexOf("fitData") === 0 && this.table.options.persistence && this.table.modExists("persistence", true) && this.table.modules.persistence.config.columns) {

    		this.table.modules.persistence.save("columns");
    	}
    };

    //layout render functions

    Layout.prototype.modes = {

    	//resize columns to fit data they contain

    	"fitData": function fitData(columns) {

    		if (this.table.options.virtualDomHoz) {

    			this.table.vdomHoz.fitDataLayoutOverride();
    		} else {

    			columns.forEach(function (column) {

    				column.reinitializeWidth();
    			});
    		}

    		if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {

    			this.table.modules.responsiveLayout.update();
    		}
    	},

    	//resize columns to fit data they contain and stretch row to fill table

    	"fitDataFill": function fitDataFill(columns) {

    		columns.forEach(function (column) {

    			column.reinitializeWidth();
    		});

    		if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {

    			this.table.modules.responsiveLayout.update();
    		}
    	},

    	//resize columns to fit data they contain

    	"fitDataTable": function fitDataTable(columns) {

    		columns.forEach(function (column) {

    			column.reinitializeWidth();
    		});

    		if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {

    			this.table.modules.responsiveLayout.update();
    		}
    	},

    	//resize columns to fit data the contain and stretch last column to fill table

    	"fitDataStretch": function fitDataStretch(columns) {
    		var _this41 = this;

    		var colsWidth = 0,
    		    tableWidth = this.table.rowManager.element.clientWidth,
    		    gap = 0,
    		    lastCol = false;

    		columns.forEach(function (column, i) {

    			if (!column.widthFixed) {

    				column.reinitializeWidth();
    			}

    			if (_this41.table.options.responsiveLayout ? column.modules.responsive.visible : column.visible) {

    				lastCol = column;
    			}

    			if (column.visible) {

    				colsWidth += column.getWidth();
    			}
    		});

    		if (lastCol) {

    			gap = tableWidth - colsWidth + lastCol.getWidth();

    			if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {

    				lastCol.setWidth(0);

    				this.table.modules.responsiveLayout.update();
    			}

    			if (gap > 0) {

    				lastCol.setWidth(gap);
    			} else {

    				lastCol.reinitializeWidth();
    			}
    		} else {

    			if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {

    				this.table.modules.responsiveLayout.update();
    			}
    		}
    	},

    	//resize columns to fit

    	"fitColumns": function fitColumns(columns) {

    		var self = this;

    		var totalWidth = self.table.element.clientWidth; //table element width

    		var fixedWidth = 0; //total width of columns with a defined width

    		var flexWidth = 0; //total width available to flexible columns

    		var flexGrowUnits = 0; //total number of widthGrow blocks accross all columns

    		var flexColWidth = 0; //desired width of flexible columns

    		var flexColumns = []; //array of flexible width columns

    		var fixedShrinkColumns = []; //array of fixed width columns that can shrink

    		var flexShrinkUnits = 0; //total number of widthShrink blocks accross all columns

    		var overflowWidth = 0; //horizontal overflow width

    		var gapFill = 0; //number of pixels to be added to final column to close and half pixel gaps


    		function calcWidth(width) {

    			var colWidth;

    			if (typeof width == "string") {

    				if (width.indexOf("%") > -1) {

    					colWidth = totalWidth / 100 * parseInt(width);
    				} else {

    					colWidth = parseInt(width);
    				}
    			} else {

    				colWidth = width;
    			}

    			return colWidth;
    		}

    		//ensure columns resize to take up the correct amount of space

    		function scaleColumns(columns, freeSpace, colWidth, shrinkCols) {

    			var oversizeCols = [],
    			    oversizeSpace = 0,
    			    remainingSpace = 0,
    			    nextColWidth = 0,
    			    remainingFlexGrowUnits = flexGrowUnits,
    			    gap = 0,
    			    changeUnits = 0,
    			    undersizeCols = [];

    			function calcGrow(col) {

    				return colWidth * (col.column.definition.widthGrow || 1);
    			}

    			function calcShrink(col) {

    				return calcWidth(col.width) - colWidth * (col.column.definition.widthShrink || 0);
    			}

    			columns.forEach(function (col, i) {

    				var width = shrinkCols ? calcShrink(col) : calcGrow(col);

    				if (col.column.minWidth >= width) {

    					oversizeCols.push(col);
    				} else {

    					if (col.column.maxWidth && col.column.maxWidth < width) {

    						col.width = col.column.maxWidth;

    						freeSpace -= col.column.maxWidth;

    						remainingFlexGrowUnits -= shrinkCols ? col.column.definition.widthShrink || 1 : col.column.definition.widthGrow || 1;

    						if (remainingFlexGrowUnits) {

    							colWidth = Math.floor(freeSpace / remainingFlexGrowUnits);
    						}
    					} else {

    						undersizeCols.push(col);

    						changeUnits += shrinkCols ? col.column.definition.widthShrink || 1 : col.column.definition.widthGrow || 1;
    					}
    				}
    			});

    			if (oversizeCols.length) {

    				oversizeCols.forEach(function (col) {

    					oversizeSpace += shrinkCols ? col.width - col.column.minWidth : col.column.minWidth;

    					col.width = col.column.minWidth;
    				});

    				remainingSpace = freeSpace - oversizeSpace;

    				nextColWidth = changeUnits ? Math.floor(remainingSpace / changeUnits) : remainingSpace;

    				gap = remainingSpace - nextColWidth * changeUnits;

    				gap += scaleColumns(undersizeCols, remainingSpace, nextColWidth, shrinkCols);
    			} else {

    				gap = changeUnits ? freeSpace - Math.floor(freeSpace / changeUnits) * changeUnits : freeSpace;

    				undersizeCols.forEach(function (column) {

    					column.width = shrinkCols ? calcShrink(column) : calcGrow(column);
    				});
    			}

    			return gap;
    		}

    		if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {

    			this.table.modules.responsiveLayout.update();
    		}

    		//adjust for vertical scrollbar if present

    		if (this.table.rowManager.element.scrollHeight > this.table.rowManager.element.clientHeight) {

    			totalWidth -= this.table.rowManager.element.offsetWidth - this.table.rowManager.element.clientWidth;
    		}

    		columns.forEach(function (column) {

    			var width, minWidth, colWidth;

    			if (column.visible) {

    				width = column.definition.width;

    				minWidth = parseInt(column.minWidth);

    				if (width) {

    					colWidth = calcWidth(width);

    					fixedWidth += colWidth > minWidth ? colWidth : minWidth;

    					if (column.definition.widthShrink) {

    						fixedShrinkColumns.push({

    							column: column,

    							width: colWidth > minWidth ? colWidth : minWidth

    						});

    						flexShrinkUnits += column.definition.widthShrink;
    					}
    				} else {

    					flexColumns.push({

    						column: column,

    						width: 0

    					});

    					flexGrowUnits += column.definition.widthGrow || 1;
    				}
    			}
    		});

    		//calculate available space

    		flexWidth = totalWidth - fixedWidth;

    		//calculate correct column size

    		flexColWidth = Math.floor(flexWidth / flexGrowUnits);

    		//generate column widths

    		var gapFill = scaleColumns(flexColumns, flexWidth, flexColWidth, false);

    		//increase width of last column to account for rounding errors

    		if (flexColumns.length && gapFill > 0) {

    			flexColumns[flexColumns.length - 1].width += +gapFill;
    		}

    		//caculate space for columns to be shrunk into

    		flexColumns.forEach(function (col) {

    			flexWidth -= col.width;
    		});

    		overflowWidth = Math.abs(gapFill) + flexWidth;

    		//shrink oversize columns if there is no available space

    		if (overflowWidth > 0 && flexShrinkUnits) {

    			gapFill = scaleColumns(fixedShrinkColumns, overflowWidth, Math.floor(overflowWidth / flexShrinkUnits), true);
    		}

    		//decrease width of last column to account for rounding errors

    		if (fixedShrinkColumns.length) {

    			fixedShrinkColumns[fixedShrinkColumns.length - 1].width -= gapFill;
    		}

    		flexColumns.forEach(function (col) {

    			col.column.setWidth(col.width);
    		});

    		fixedShrinkColumns.forEach(function (col) {

    			col.column.setWidth(col.width);
    		});
    	}

    };

    Tabulator.prototype.registerModule("layout", Layout);
    var Localize = function Localize(table) {
    	this.table = table; //hold Tabulator object
    	this.locale = "default"; //current locale
    	this.lang = false; //current language
    	this.bindings = {}; //update events to call when locale is changed
    	this.langList = {};
    };

    Localize.prototype.initialize = function () {
    	this.langList = Tabulator.prototype.helpers.deepClone(this.langs);
    };

    //set header placehoder
    Localize.prototype.setHeaderFilterPlaceholder = function (placeholder) {
    	this.langList.default.headerFilters.default = placeholder;
    };

    //set header filter placeholder by column
    Localize.prototype.setHeaderFilterColumnPlaceholder = function (column, placeholder) {
    	this.langList.default.headerFilters.columns[column] = placeholder;

    	if (this.lang && !this.lang.headerFilters.columns[column]) {
    		this.lang.headerFilters.columns[column] = placeholder;
    	}
    };

    //setup a lang description object
    Localize.prototype.installLang = function (locale, lang) {
    	if (this.langList[locale]) {
    		this._setLangProp(this.langList[locale], lang);
    	} else {
    		this.langList[locale] = lang;
    	}
    };

    Localize.prototype._setLangProp = function (lang, values) {
    	for (var key in values) {
    		if (lang[key] && _typeof(lang[key]) == "object") {
    			this._setLangProp(lang[key], values[key]);
    		} else {
    			lang[key] = values[key];
    		}
    	}
    };

    //set current locale
    Localize.prototype.setLocale = function (desiredLocale) {
    	var self = this;

    	desiredLocale = desiredLocale || "default";

    	//fill in any matching languge values
    	function traverseLang(trans, path) {
    		for (var prop in trans) {
    			if (_typeof(trans[prop]) == "object") {
    				if (!path[prop]) {
    					path[prop] = {};
    				}
    				traverseLang(trans[prop], path[prop]);
    			} else {
    				path[prop] = trans[prop];
    			}
    		}
    	}

    	//determing correct locale to load
    	if (desiredLocale === true && navigator.language) {
    		//get local from system
    		desiredLocale = navigator.language.toLowerCase();
    	}

    	if (desiredLocale) {

    		//if locale is not set, check for matching top level locale else use default
    		if (!self.langList[desiredLocale]) {
    			var prefix = desiredLocale.split("-")[0];

    			if (self.langList[prefix]) {
    				console.warn("Localization Error - Exact matching locale not found, using closest match: ", desiredLocale, prefix);
    				desiredLocale = prefix;
    			} else {
    				console.warn("Localization Error - Matching locale not found, using default: ", desiredLocale);
    				desiredLocale = "default";
    			}
    		}
    	}

    	self.locale = desiredLocale;

    	//load default lang template
    	self.lang = Tabulator.prototype.helpers.deepClone(self.langList.default || {});

    	if (desiredLocale != "default") {
    		traverseLang(self.langList[desiredLocale], self.lang);
    	}

    	self.table.options.localized.call(self.table, self.locale, self.lang);

    	self._executeBindings();
    };

    //get current locale
    Localize.prototype.getLocale = function (locale) {
    	return self.locale;
    };

    //get lang object for given local or current if none provided
    Localize.prototype.getLang = function (locale) {
    	return locale ? this.langList[locale] : this.lang;
    };

    //get text for current locale
    Localize.prototype.getText = function (path, value) {
    	var path = value ? path + "|" + value : path,
    	    pathArray = path.split("|"),
    	    text = this._getLangElement(pathArray, this.locale);

    	// if(text === false){
    	// 	console.warn("Localization Error - Matching localized text not found for given path: ", path);
    	// }

    	return text || "";
    };

    //traverse langs object and find localized copy
    Localize.prototype._getLangElement = function (path, locale) {
    	var self = this;
    	var root = self.lang;

    	path.forEach(function (level) {
    		var rootPath;

    		if (root) {
    			rootPath = root[level];

    			if (typeof rootPath != "undefined") {
    				root = rootPath;
    			} else {
    				root = false;
    			}
    		}
    	});

    	return root;
    };

    //set update binding
    Localize.prototype.bind = function (path, callback) {
    	if (!this.bindings[path]) {
    		this.bindings[path] = [];
    	}

    	this.bindings[path].push(callback);

    	callback(this.getText(path), this.lang);
    };

    //itterate through bindings and trigger updates
    Localize.prototype._executeBindings = function () {
    	var self = this;

    	var _loop = function _loop(path) {
    		self.bindings[path].forEach(function (binding) {
    			binding(self.getText(path), self.lang);
    		});
    	};

    	for (var path in self.bindings) {
    		_loop(path);
    	}
    };

    //Localized text listings
    Localize.prototype.langs = {
    	"default": { //hold default locale text
    		"groups": {
    			"item": "item",
    			"items": "items"
    		},
    		"columns": {},
    		"ajax": {
    			"loading": "Loading",
    			"error": "Error"
    		},
    		"pagination": {
    			"page_size": "Page Size",
    			"page_title": "Show Page",
    			"first": "First",
    			"first_title": "First Page",
    			"last": "Last",
    			"last_title": "Last Page",
    			"prev": "Prev",
    			"prev_title": "Prev Page",
    			"next": "Next",
    			"next_title": "Next Page",
    			"all": "All"
    		},
    		"headerFilters": {
    			"default": "filter column...",
    			"columns": {}
    		}
    	}
    };

    Tabulator.prototype.registerModule("localize", Localize);
    var Comms = function Comms(table) {
    	this.table = table;
    };

    Comms.prototype.getConnections = function (selectors) {
    	var self = this,
    	    connections = [],
    	    connection;

    	connection = Tabulator.prototype.comms.lookupTable(selectors);

    	connection.forEach(function (con) {
    		if (self.table !== con) {
    			connections.push(con);
    		}
    	});

    	return connections;
    };

    Comms.prototype.send = function (selectors, module, action, data) {
    	var self = this,
    	    connections = this.getConnections(selectors);

    	connections.forEach(function (connection) {
    		connection.tableComms(self.table.element, module, action, data);
    	});

    	if (!connections.length && selectors) {
    		console.warn("Table Connection Error - No tables matching selector found", selectors);
    	}
    };

    Comms.prototype.receive = function (table, module, action, data) {
    	if (this.table.modExists(module)) {
    		return this.table.modules[module].commsReceived(table, action, data);
    	} else {
    		console.warn("Inter-table Comms Error - no such module:", module);
    	}
    };

    Tabulator.prototype.registerModule("comms", Comms);

    var Accessor = function Accessor(table) {
    	this.table = table; //hold Tabulator object
    	this.allowedTypes = ["", "data", "download", "clipboard", "print", "htmlOutput"]; //list of accessor types
    };

    //initialize column accessor
    Accessor.prototype.initializeColumn = function (column) {
    	var self = this,
    	    match = false,
    	    config = {};

    	this.allowedTypes.forEach(function (type) {
    		var key = "accessor" + (type.charAt(0).toUpperCase() + type.slice(1)),
    		    accessor;

    		if (column.definition[key]) {
    			accessor = self.lookupAccessor(column.definition[key]);

    			if (accessor) {
    				match = true;

    				config[key] = {
    					accessor: accessor,
    					params: column.definition[key + "Params"] || {}
    				};
    			}
    		}
    	});

    	if (match) {
    		column.modules.accessor = config;
    	}
    };

    Accessor.prototype.lookupAccessor = function (value) {
    	var accessor = false;

    	//set column accessor
    	switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
    		case "string":
    			if (this.accessors[value]) {
    				accessor = this.accessors[value];
    			} else {
    				console.warn("Accessor Error - No such accessor found, ignoring: ", value);
    			}
    			break;

    		case "function":
    			accessor = value;
    			break;
    	}

    	return accessor;
    };

    //apply accessor to row
    Accessor.prototype.transformRow = function (row, type) {
    	var key = "accessor" + (type.charAt(0).toUpperCase() + type.slice(1)),
    	    rowComponent = row.getComponent();

    	//clone data object with deep copy to isolate internal data from returned result
    	var data = Tabulator.prototype.helpers.deepClone(row.data || {});

    	this.table.columnManager.traverse(function (column) {
    		var value, accessor, params, colCompnent;

    		if (column.modules.accessor) {

    			accessor = column.modules.accessor[key] || column.modules.accessor.accessor || false;

    			if (accessor) {
    				value = column.getFieldValue(data);

    				if (value != "undefined") {
    					colCompnent = column.getComponent();
    					params = typeof accessor.params === "function" ? accessor.params(value, data, type, colCompnent, rowComponent) : accessor.params;
    					column.setFieldValue(data, accessor.accessor(value, data, type, params, colCompnent, rowComponent));
    				}
    			}
    		}
    	});

    	return data;
    },

    //default accessors
    Accessor.prototype.accessors = {};

    Tabulator.prototype.registerModule("accessor", Accessor);
    var Ajax = function Ajax(table) {

    	this.table = table; //hold Tabulator object
    	this.config = false; //hold config object for ajax request
    	this.url = ""; //request URL
    	this.urlGenerator = false;
    	this.params = false; //request parameters

    	this.loaderElement = this.createLoaderElement(); //loader message div
    	this.msgElement = this.createMsgElement(); //message element
    	this.loadingElement = false;
    	this.errorElement = false;
    	this.loaderPromise = false;

    	this.progressiveLoad = false;
    	this.loading = false;

    	this.requestOrder = 0; //prevent requests comming out of sequence if overridden by another load request
    };

    //initialize setup options
    Ajax.prototype.initialize = function () {
    	var template;

    	this.loaderElement.appendChild(this.msgElement);

    	if (this.table.options.ajaxLoaderLoading) {
    		if (typeof this.table.options.ajaxLoaderLoading == "string") {
    			template = document.createElement('template');
    			template.innerHTML = this.table.options.ajaxLoaderLoading.trim();
    			this.loadingElement = template.content.firstChild;
    		} else {
    			this.loadingElement = this.table.options.ajaxLoaderLoading;
    		}
    	}

    	this.loaderPromise = this.table.options.ajaxRequestFunc || this.defaultLoaderPromise;

    	this.urlGenerator = this.table.options.ajaxURLGenerator || this.defaultURLGenerator;

    	if (this.table.options.ajaxLoaderError) {
    		if (typeof this.table.options.ajaxLoaderError == "string") {
    			template = document.createElement('template');
    			template.innerHTML = this.table.options.ajaxLoaderError.trim();
    			this.errorElement = template.content.firstChild;
    		} else {
    			this.errorElement = this.table.options.ajaxLoaderError;
    		}
    	}

    	if (this.table.options.ajaxParams) {
    		this.setParams(this.table.options.ajaxParams);
    	}

    	if (this.table.options.ajaxConfig) {
    		this.setConfig(this.table.options.ajaxConfig);
    	}

    	if (this.table.options.ajaxURL) {
    		this.setUrl(this.table.options.ajaxURL);
    	}

    	if (this.table.options.ajaxProgressiveLoad) {
    		if (this.table.options.pagination) {
    			this.progressiveLoad = false;
    			console.error("Progressive Load Error - Pagination and progressive load cannot be used at the same time");
    		} else {
    			if (this.table.modExists("page")) {
    				this.progressiveLoad = this.table.options.ajaxProgressiveLoad;
    				this.table.modules.page.initializeProgressive(this.progressiveLoad);
    			} else {
    				console.error("Pagination plugin is required for progressive ajax loading");
    			}
    		}
    	}
    };

    Ajax.prototype.createLoaderElement = function () {
    	var el = document.createElement("div");
    	el.classList.add("tabulator-loader");
    	return el;
    };

    Ajax.prototype.createMsgElement = function () {
    	var el = document.createElement("div");

    	el.classList.add("tabulator-loader-msg");
    	el.setAttribute("role", "alert");

    	return el;
    };

    //set ajax params
    Ajax.prototype.setParams = function (params, update) {
    	if (update) {
    		this.params = this.params || {};

    		for (var key in params) {
    			this.params[key] = params[key];
    		}
    	} else {
    		this.params = params;
    	}
    };

    Ajax.prototype.getParams = function () {
    	return this.params || {};
    };

    //load config object
    Ajax.prototype.setConfig = function (config) {
    	this._loadDefaultConfig();

    	if (typeof config == "string") {
    		this.config.method = config;
    	} else {
    		for (var key in config) {
    			this.config[key] = config[key];
    		}
    	}
    };

    //create config object from default
    Ajax.prototype._loadDefaultConfig = function (force) {
    	var self = this;
    	if (!self.config || force) {

    		self.config = {};

    		//load base config from defaults
    		for (var key in self.defaultConfig) {
    			self.config[key] = self.defaultConfig[key];
    		}
    	}
    };

    //set request url
    Ajax.prototype.setUrl = function (url) {
    	this.url = url;
    };

    //get request url
    Ajax.prototype.getUrl = function () {
    	return this.url;
    };

    //lstandard loading function
    Ajax.prototype.loadData = function (inPosition, columnsChanged) {

    	if (this.progressiveLoad) {
    		return this._loadDataProgressive();
    	} else {
    		return this._loadDataStandard(inPosition, columnsChanged);
    	}
    };

    Ajax.prototype.nextPage = function (diff) {
    	var margin;

    	if (!this.loading) {

    		margin = this.table.options.ajaxProgressiveLoadScrollMargin || this.table.rowManager.getElement().clientHeight * 2;

    		if (diff < margin) {
    			this.table.modules.page.nextPage().then(function () {}).catch(function () {});
    		}
    	}
    };

    Ajax.prototype.blockActiveRequest = function () {
    	this.requestOrder++;
    };

    Ajax.prototype._loadDataProgressive = function () {
    	this.table.rowManager.setData([]);
    	return this.table.modules.page.setPage(1);
    };

    Ajax.prototype._loadDataStandard = function (inPosition, columnsChanged) {
    	var _this42 = this;

    	return new Promise(function (resolve, reject) {
    		_this42.sendRequest(inPosition).then(function (data) {
    			_this42.table.rowManager.setData(data, inPosition, columnsChanged).then(function () {
    				resolve();
    			}).catch(function (e) {
    				reject(e);
    			});
    		}).catch(function (e) {
    			reject(e);
    		});
    	});
    };

    Ajax.prototype.generateParamsList = function (data, prefix) {
    	var self = this,
    	    output = [];

    	prefix = prefix || "";

    	if (Array.isArray(data)) {
    		data.forEach(function (item, i) {
    			output = output.concat(self.generateParamsList(item, prefix ? prefix + "[" + i + "]" : i));
    		});
    	} else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === "object") {
    		for (var key in data) {
    			output = output.concat(self.generateParamsList(data[key], prefix ? prefix + "[" + key + "]" : key));
    		}
    	} else {
    		output.push({ key: prefix, value: data });
    	}

    	return output;
    };

    Ajax.prototype.serializeParams = function (params) {
    	var output = this.generateParamsList(params),
    	    encoded = [];

    	output.forEach(function (item) {
    		encoded.push(encodeURIComponent(item.key) + "=" + encodeURIComponent(item.value));
    	});

    	return encoded.join("&");
    };

    //send ajax request
    Ajax.prototype.sendRequest = function (silent) {
    	var _this43 = this;

    	var self = this,
    	    url = self.url,
    	    requestNo;

    	self.requestOrder++;
    	requestNo = self.requestOrder;

    	self._loadDefaultConfig();

    	return new Promise(function (resolve, reject) {
    		if (self.table.options.ajaxRequesting.call(_this43.table, self.url, self.params) !== false) {

    			self.loading = true;

    			if (!silent) {
    				self.showLoader();
    			}

    			_this43.loaderPromise(url, self.config, self.params).then(function (data) {
    				if (requestNo === self.requestOrder) {
    					if (self.table.options.ajaxResponse) {
    						data = self.table.options.ajaxResponse.call(self.table, self.url, self.params, data);
    					}
    					resolve(data);

    					self.hideLoader();
    					self.loading = false;
    				} else {
    					console.warn("Ajax Response Blocked - An active ajax request was blocked by an attempt to change table data while the request was being made");
    				}
    			}).catch(function (error) {
    				console.error("Ajax Load Error: ", error);
    				self.table.options.ajaxError.call(self.table, error);

    				self.showError();

    				setTimeout(function () {
    					self.hideLoader();
    				}, 3000);

    				self.loading = false;

    				reject(error);
    			});
    		} else {
    			reject();
    		}
    	});
    };

    Ajax.prototype.showLoader = function () {
    	var shouldLoad = typeof this.table.options.ajaxLoader === "function" ? this.table.options.ajaxLoader() : this.table.options.ajaxLoader;

    	if (shouldLoad) {

    		this.hideLoader();

    		while (this.msgElement.firstChild) {
    			this.msgElement.removeChild(this.msgElement.firstChild);
    		}this.msgElement.classList.remove("tabulator-error");
    		this.msgElement.classList.add("tabulator-loading");

    		if (this.loadingElement) {
    			this.msgElement.appendChild(this.loadingElement);
    		} else {
    			this.msgElement.innerHTML = this.table.modules.localize.getText("ajax|loading");
    		}

    		this.table.element.appendChild(this.loaderElement);
    	}
    };

    Ajax.prototype.showError = function () {
    	this.hideLoader();

    	while (this.msgElement.firstChild) {
    		this.msgElement.removeChild(this.msgElement.firstChild);
    	}this.msgElement.classList.remove("tabulator-loading");
    	this.msgElement.classList.add("tabulator-error");

    	if (this.errorElement) {
    		this.msgElement.appendChild(this.errorElement);
    	} else {
    		this.msgElement.innerHTML = this.table.modules.localize.getText("ajax|error");
    	}

    	this.table.element.appendChild(this.loaderElement);
    };

    Ajax.prototype.hideLoader = function () {
    	if (this.loaderElement.parentNode) {
    		this.loaderElement.parentNode.removeChild(this.loaderElement);
    	}
    };

    //default ajax config object
    Ajax.prototype.defaultConfig = {
    	method: "GET"
    };

    Ajax.prototype.defaultURLGenerator = function (url, config, params) {

    	if (url) {
    		if (params && Object.keys(params).length) {
    			if (!config.method || config.method.toLowerCase() == "get") {
    				config.method = "get";

    				url += (url.includes("?") ? "&" : "?") + this.modules.ajax.serializeParams(params);
    			}
    		}
    	}

    	return url;
    };

    Ajax.prototype.defaultLoaderPromise = function (url, config, params) {
    	var self = this,
    	    contentType;

    	return new Promise(function (resolve, reject) {

    		//set url
    		url = self.urlGenerator.call(self.table, url, config, params);

    		//set body content if not GET request
    		if (config.method.toUpperCase() != "GET") {
    			contentType = _typeof(self.table.options.ajaxContentType) === "object" ? self.table.options.ajaxContentType : self.contentTypeFormatters[self.table.options.ajaxContentType];
    			if (contentType) {

    				for (var key in contentType.headers) {
    					if (!config.headers) {
    						config.headers = {};
    					}

    					if (typeof config.headers[key] === "undefined") {
    						config.headers[key] = contentType.headers[key];
    					}
    				}

    				config.body = contentType.body.call(self, url, config, params);
    			} else {
    				console.warn("Ajax Error - Invalid ajaxContentType value:", self.table.options.ajaxContentType);
    			}
    		}

    		if (url) {

    			//configure headers
    			if (typeof config.headers === "undefined") {
    				config.headers = {};
    			}

    			if (typeof config.headers.Accept === "undefined") {
    				config.headers.Accept = "application/json";
    			}

    			if (typeof config.headers["X-Requested-With"] === "undefined") {
    				config.headers["X-Requested-With"] = "XMLHttpRequest";
    			}

    			if (typeof config.mode === "undefined") {
    				config.mode = "cors";
    			}

    			if (config.mode == "cors") {

    				if (typeof config.headers["Access-Control-Allow-Origin"] === "undefined") {
    					config.headers["Access-Control-Allow-Origin"] = window.location.origin;
    				}

    				if (typeof config.credentials === "undefined") {
    					config.credentials = 'same-origin';
    				}
    			} else {
    				if (typeof config.credentials === "undefined") {
    					config.credentials = 'include';
    				}
    			}

    			//send request
    			fetch(url, config).then(function (response) {
    				if (response.ok) {
    					response.json().then(function (data) {
    						resolve(data);
    					}).catch(function (error) {
    						reject(error);
    						console.warn("Ajax Load Error - Invalid JSON returned", error);
    					});
    				} else {
    					console.error("Ajax Load Error - Connection Error: " + response.status, response.statusText);
    					reject(response);
    				}
    			}).catch(function (error) {
    				console.error("Ajax Load Error - Connection Error: ", error);
    				reject(error);
    			});
    		} else {
    			console.warn("Ajax Load Error - No URL Set");
    			resolve([]);
    		}
    	});
    };

    Ajax.prototype.contentTypeFormatters = {
    	"json": {
    		headers: {
    			'Content-Type': 'application/json'
    		},
    		body: function body(url, config, params) {
    			return JSON.stringify(params);
    		}
    	},
    	"form": {
    		headers: {},
    		body: function body(url, config, params) {
    			var output = this.generateParamsList(params),
    			    form = new FormData();

    			output.forEach(function (item) {
    				form.append(item.key, item.value);
    			});

    			return form;
    		}
    	}
    };

    Tabulator.prototype.registerModule("ajax", Ajax);

    //public calc object
    var CalcComponent = function CalcComponent(row) {
    	this._row = row;
    };

    CalcComponent.prototype.getData = function (transform) {
    	return this._row.getData(transform);
    };

    CalcComponent.prototype.getElement = function () {
    	return this._row.getElement();
    };

    CalcComponent.prototype.getTable = function () {
    	return this._row.table;
    };

    CalcComponent.prototype.getCells = function () {
    	var cells = [];

    	this._row.getCells().forEach(function (cell) {
    		cells.push(cell.getComponent());
    	});

    	return cells;
    };

    CalcComponent.prototype.getCell = function (column) {
    	var cell = this._row.getCell(column);
    	return cell ? cell.getComponent() : false;
    };

    CalcComponent.prototype._getSelf = function () {
    	return this._row;
    };

    var ColumnCalcs = function ColumnCalcs(table) {
    	this.table = table; //hold Tabulator object
    	this.topCalcs = [];
    	this.botCalcs = [];
    	this.genColumn = false;
    	this.topElement = this.createElement();
    	this.botElement = this.createElement();
    	this.topRow = false;
    	this.botRow = false;
    	this.topInitialized = false;
    	this.botInitialized = false;

    	this.initialize();
    };

    ColumnCalcs.prototype.createElement = function () {
    	var el = document.createElement("div");
    	el.classList.add("tabulator-calcs-holder");
    	return el;
    };

    ColumnCalcs.prototype.initialize = function () {
    	this.genColumn = new Column({ field: "value" }, this);
    };

    //dummy functions to handle being mock column manager
    ColumnCalcs.prototype.registerColumnField = function () {};

    //initialize column calcs
    ColumnCalcs.prototype.initializeColumn = function (column) {
    	var def = column.definition;

    	var config = {
    		topCalcParams: def.topCalcParams || {},
    		botCalcParams: def.bottomCalcParams || {}
    	};

    	if (def.topCalc) {

    		switch (_typeof(def.topCalc)) {
    			case "string":
    				if (this.calculations[def.topCalc]) {
    					config.topCalc = this.calculations[def.topCalc];
    				} else {
    					console.warn("Column Calc Error - No such calculation found, ignoring: ", def.topCalc);
    				}
    				break;

    			case "function":
    				config.topCalc = def.topCalc;
    				break;

    		}

    		if (config.topCalc) {
    			column.modules.columnCalcs = config;
    			this.topCalcs.push(column);

    			if (this.table.options.columnCalcs != "group") {
    				this.initializeTopRow();
    			}
    		}
    	}

    	if (def.bottomCalc) {
    		switch (_typeof(def.bottomCalc)) {
    			case "string":
    				if (this.calculations[def.bottomCalc]) {
    					config.botCalc = this.calculations[def.bottomCalc];
    				} else {
    					console.warn("Column Calc Error - No such calculation found, ignoring: ", def.bottomCalc);
    				}
    				break;

    			case "function":
    				config.botCalc = def.bottomCalc;
    				break;

    		}

    		if (config.botCalc) {
    			column.modules.columnCalcs = config;
    			this.botCalcs.push(column);

    			if (this.table.options.columnCalcs != "group") {
    				this.initializeBottomRow();
    			}
    		}
    	}
    };

    ColumnCalcs.prototype.removeCalcs = function () {
    	var changed = false;

    	if (this.topInitialized) {
    		this.topInitialized = false;
    		this.topElement.parentNode.removeChild(this.topElement);
    		changed = true;
    	}

    	if (this.botInitialized) {
    		this.botInitialized = false;
    		this.table.footerManager.remove(this.botElement);
    		changed = true;
    	}

    	if (changed) {
    		this.table.rowManager.adjustTableSize();
    	}
    };

    ColumnCalcs.prototype.initializeTopRow = function () {
    	if (!this.topInitialized) {
    		this.table.columnManager.getElement().insertBefore(this.topElement, this.table.columnManager.headersElement.nextSibling);
    		this.topInitialized = true;
    	}
    };

    ColumnCalcs.prototype.initializeBottomRow = function () {
    	if (!this.botInitialized) {
    		this.table.footerManager.prepend(this.botElement);
    		this.botInitialized = true;
    	}
    };

    ColumnCalcs.prototype.scrollHorizontal = function (left) {
    	if (this.botInitialized && this.botRow) {
    		this.botRow.getElement().style.marginLeft = -left + "px";
    	}
    };

    ColumnCalcs.prototype.recalc = function (rows) {
    	var row;

    	if (this.topInitialized || this.botInitialized) {
    		this.rowsToData(rows);

    		if (this.topInitialized) {
    			if (this.topRow) {
    				this.topRow.deleteCells();
    			}

    			row = this.generateRow("top", this.rowsToData(rows));
    			this.topRow = row;
    			while (this.topElement.firstChild) {
    				this.topElement.removeChild(this.topElement.firstChild);
    			}this.topElement.appendChild(row.getElement());
    			row.initialize(true);
    		}

    		if (this.botInitialized) {
    			if (this.botRow) {
    				this.botRow.deleteCells();
    			}

    			row = this.generateRow("bottom", this.rowsToData(rows));
    			this.botRow = row;
    			while (this.botElement.firstChild) {
    				this.botElement.removeChild(this.botElement.firstChild);
    			}this.botElement.appendChild(row.getElement());
    			row.initialize(true);
    		}

    		this.table.rowManager.adjustTableSize();

    		//set resizable handles
    		if (this.table.modExists("frozenColumns")) {
    			this.table.modules.frozenColumns.layout();
    		}
    	}
    };

    ColumnCalcs.prototype.recalcRowGroup = function (row) {
    	this.recalcGroup(this.table.modules.groupRows.getRowGroup(row));
    };

    ColumnCalcs.prototype.recalcAll = function () {
    	var _this44 = this;

    	if (this.topCalcs.length || this.botCalcs.length) {
    		if (this.table.options.columnCalcs !== "group") {
    			this.recalc(this.table.rowManager.activeRows);
    		}

    		if (this.table.options.groupBy && this.table.options.columnCalcs !== "table") {

    			var groups = table.modules.groupRows.getChildGroups();

    			groups.forEach(function (group) {
    				_this44.recalcGroup(group);
    			});
    		}
    	}
    };

    ColumnCalcs.prototype.recalcGroup = function (group) {
    	var data, rowData;

    	if (group) {
    		if (group.calcs) {
    			if (group.calcs.bottom) {
    				data = this.rowsToData(group.rows);
    				rowData = this.generateRowData("bottom", data);

    				group.calcs.bottom.updateData(rowData);
    				group.calcs.bottom.reinitialize();
    			}

    			if (group.calcs.top) {
    				data = this.rowsToData(group.rows);
    				rowData = this.generateRowData("top", data);

    				group.calcs.top.updateData(rowData);
    				group.calcs.top.reinitialize();
    			}
    		}
    	}
    };

    //generate top stats row
    ColumnCalcs.prototype.generateTopRow = function (rows) {
    	return this.generateRow("top", this.rowsToData(rows));
    };
    //generate bottom stats row
    ColumnCalcs.prototype.generateBottomRow = function (rows) {
    	return this.generateRow("bottom", this.rowsToData(rows));
    };

    ColumnCalcs.prototype.rowsToData = function (rows) {
    	var _this45 = this;

    	var data = [];

    	rows.forEach(function (row) {
    		data.push(row.getData());

    		if (_this45.table.options.dataTree && _this45.table.options.dataTreeChildColumnCalcs) {
    			if (row.modules.dataTree.open) {
    				var children = _this45.rowsToData(_this45.table.modules.dataTree.getFilteredTreeChildren(row));
    				data = data.concat(children);
    			}
    		}
    	});

    	return data;
    };

    //generate stats row
    ColumnCalcs.prototype.generateRow = function (pos, data) {
    	var self = this,
    	    rowData = this.generateRowData(pos, data),
    	    row;

    	if (self.table.modExists("mutator")) {
    		self.table.modules.mutator.disable();
    	}

    	row = new Row(rowData, this, "calc");

    	if (self.table.modExists("mutator")) {
    		self.table.modules.mutator.enable();
    	}

    	row.getElement().classList.add("tabulator-calcs", "tabulator-calcs-" + pos);

    	row.component = false;

    	row.getComponent = function () {
    		if (!this.component) {
    			this.component = new CalcComponent(this);
    		}

    		return this.component;
    	};

    	row.generateCells = function () {

    		var cells = [];

    		self.table.columnManager.columnsByIndex.forEach(function (column) {

    			//set field name of mock column
    			self.genColumn.setField(column.getField());
    			self.genColumn.hozAlign = column.hozAlign;

    			if (column.definition[pos + "CalcFormatter"] && self.table.modExists("format")) {
    				self.genColumn.modules.format = {
    					formatter: self.table.modules.format.getFormatter(column.definition[pos + "CalcFormatter"]),
    					params: column.definition[pos + "CalcFormatterParams"] || {}
    				};
    			} else {
    				self.genColumn.modules.format = {
    					formatter: self.table.modules.format.getFormatter("plaintext"),
    					params: {}
    				};
    			}

    			//ensure css class defintion is replicated to calculation cell
    			self.genColumn.definition.cssClass = column.definition.cssClass;

    			//generate cell and assign to correct column
    			var cell = new Cell(self.genColumn, row);
    			cell.getElement();
    			cell.column = column;
    			cell.setWidth();

    			column.cells.push(cell);
    			cells.push(cell);

    			if (!column.visible) {
    				cell.hide();
    			}
    		});

    		this.cells = cells;
    	};

    	return row;
    };

    //generate stats row
    ColumnCalcs.prototype.generateRowData = function (pos, data) {
    	var rowData = {},
    	    calcs = pos == "top" ? this.topCalcs : this.botCalcs,
    	    type = pos == "top" ? "topCalc" : "botCalc",
    	    params,
    	    paramKey;

    	calcs.forEach(function (column) {
    		var values = [];

    		if (column.modules.columnCalcs && column.modules.columnCalcs[type]) {
    			data.forEach(function (item) {
    				values.push(column.getFieldValue(item));
    			});

    			paramKey = type + "Params";
    			params = typeof column.modules.columnCalcs[paramKey] === "function" ? column.modules.columnCalcs[paramKey](values, data) : column.modules.columnCalcs[paramKey];

    			column.setFieldValue(rowData, column.modules.columnCalcs[type](values, data, params));
    		}
    	});

    	return rowData;
    };

    ColumnCalcs.prototype.hasTopCalcs = function () {
    	return !!this.topCalcs.length;
    };

    ColumnCalcs.prototype.hasBottomCalcs = function () {
    	return !!this.botCalcs.length;
    };

    //handle table redraw
    ColumnCalcs.prototype.redraw = function () {
    	if (this.topRow) {
    		this.topRow.normalizeHeight(true);
    	}
    	if (this.botRow) {
    		this.botRow.normalizeHeight(true);
    	}
    };

    //return the calculated
    ColumnCalcs.prototype.getResults = function () {
    	var self = this,
    	    results = {},
    	    groups;

    	if (this.table.options.groupBy && this.table.modExists("groupRows")) {
    		groups = this.table.modules.groupRows.getGroups(true);

    		groups.forEach(function (group) {
    			results[group.getKey()] = self.getGroupResults(group);
    		});
    	} else {
    		results = {
    			top: this.topRow ? this.topRow.getData() : {},
    			bottom: this.botRow ? this.botRow.getData() : {}
    		};
    	}

    	return results;
    };

    //get results from a group
    ColumnCalcs.prototype.getGroupResults = function (group) {
    	var self = this,
    	    groupObj = group._getSelf(),
    	    subGroups = group.getSubGroups(),
    	    subGroupResults = {},
    	    results = {};

    	subGroups.forEach(function (subgroup) {
    		subGroupResults[subgroup.getKey()] = self.getGroupResults(subgroup);
    	});

    	results = {
    		top: groupObj.calcs.top ? groupObj.calcs.top.getData() : {},
    		bottom: groupObj.calcs.bottom ? groupObj.calcs.bottom.getData() : {},
    		groups: subGroupResults
    	};

    	return results;
    };

    //default calculations
    ColumnCalcs.prototype.calculations = {
    	"avg": function avg(values, data, calcParams) {
    		var output = 0,
    		    precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : 2;

    		if (values.length) {
    			output = values.reduce(function (sum, value) {
    				return Number(sum) + Number(value);
    			});

    			output = output / values.length;

    			output = precision !== false ? output.toFixed(precision) : output;
    		}

    		return parseFloat(output).toString();
    	},
    	"max": function max(values, data, calcParams) {
    		var output = null,
    		    precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : false;

    		values.forEach(function (value) {

    			value = Number(value);

    			if (value > output || output === null) {
    				output = value;
    			}
    		});

    		return output !== null ? precision !== false ? output.toFixed(precision) : output : "";
    	},
    	"min": function min(values, data, calcParams) {
    		var output = null,
    		    precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : false;

    		values.forEach(function (value) {

    			value = Number(value);

    			if (value < output || output === null) {
    				output = value;
    			}
    		});

    		return output !== null ? precision !== false ? output.toFixed(precision) : output : "";
    	},
    	"sum": function sum(values, data, calcParams) {
    		var output = 0,
    		    precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : false;

    		if (values.length) {
    			values.forEach(function (value) {
    				value = Number(value);

    				output += !isNaN(value) ? Number(value) : 0;
    			});
    		}

    		return precision !== false ? output.toFixed(precision) : output;
    	},
    	"concat": function concat(values, data, calcParams) {
    		var output = 0;

    		if (values.length) {
    			output = values.reduce(function (sum, value) {
    				return String(sum) + String(value);
    			});
    		}

    		return output;
    	},
    	"count": function count(values, data, calcParams) {
    		var output = 0;

    		if (values.length) {
    			values.forEach(function (value) {
    				if (value) {
    					output++;
    				}
    			});
    		}

    		return output;
    	}
    };

    Tabulator.prototype.registerModule("columnCalcs", ColumnCalcs);

    var Clipboard = function Clipboard(table) {
    	this.table = table;
    	this.mode = true;

    	this.pasteParser = function () {};
    	this.pasteAction = function () {};
    	this.customSelection = false;
    	this.rowRange = false;
    	this.blocked = true; //block copy actions not originating from this command
    };

    Clipboard.prototype.initialize = function () {
    	var _this46 = this;

    	this.mode = this.table.options.clipboard;

    	this.rowRange = this.table.options.clipboardCopyRowRange;

    	if (this.mode === true || this.mode === "copy") {
    		this.table.element.addEventListener("copy", function (e) {
    			var plain, html, list;

    			if (!_this46.blocked) {
    				e.preventDefault();

    				if (_this46.customSelection) {
    					plain = _this46.customSelection;

    					if (_this46.table.options.clipboardCopyFormatter) {
    						plain = _this46.table.options.clipboardCopyFormatter("plain", plain);
    					}
    				} else {

    					var list = _this46.table.modules.export.generateExportList(_this46.table.options.clipboardCopyConfig, _this46.table.options.clipboardCopyStyled, _this46.rowRange, "clipboard");

    					html = _this46.table.modules.export.genereateHTMLTable(list);
    					plain = html ? _this46.generatePlainContent(list) : "";

    					if (_this46.table.options.clipboardCopyFormatter) {
    						plain = _this46.table.options.clipboardCopyFormatter("plain", plain);
    						html = _this46.table.options.clipboardCopyFormatter("html", html);
    					}
    				}

    				if (window.clipboardData && window.clipboardData.setData) {
    					window.clipboardData.setData('Text', plain);
    				} else if (e.clipboardData && e.clipboardData.setData) {
    					e.clipboardData.setData('text/plain', plain);
    					if (html) {
    						e.clipboardData.setData('text/html', html);
    					}
    				} else if (e.originalEvent && e.originalEvent.clipboardData.setData) {
    					e.originalEvent.clipboardData.setData('text/plain', plain);
    					if (html) {
    						e.originalEvent.clipboardData.setData('text/html', html);
    					}
    				}

    				_this46.table.options.clipboardCopied.call(_this46.table, plain, html);

    				_this46.reset();
    			}
    		});
    	}

    	if (this.mode === true || this.mode === "paste") {
    		this.table.element.addEventListener("paste", function (e) {
    			_this46.paste(e);
    		});
    	}

    	this.setPasteParser(this.table.options.clipboardPasteParser);
    	this.setPasteAction(this.table.options.clipboardPasteAction);
    };

    Clipboard.prototype.reset = function () {
    	this.blocked = true;
    	this.customSelection = false;
    };

    Clipboard.prototype.generatePlainContent = function (list) {
    	var output = [];

    	list.forEach(function (row) {
    		var rowData = [];

    		row.columns.forEach(function (col) {
    			var value = "";

    			if (col) {

    				if (row.type === "group") {
    					col.value = col.component.getKey();
    				}

    				if (col.value === null) {
    					value = "";
    				} else {
    					switch (_typeof(col.value)) {
    						case "object":
    							value = JSON.stringify(col.value);
    							break;

    						case "undefined":
    							value = "";
    							break;

    						default:
    							value = col.value;
    					}
    				}
    			}

    			rowData.push(value);
    		});

    		output.push(rowData.join("\t"));
    	});

    	return output.join("\n");
    };

    Clipboard.prototype.copy = function (range, internal) {
    	var range, sel, textRange;
    	this.blocked = false;
    	this.customSelection = false;

    	if (this.mode === true || this.mode === "copy") {

    		this.rowRange = range || this.table.options.clipboardCopyRowRange;

    		if (typeof window.getSelection != "undefined" && typeof document.createRange != "undefined") {
    			range = document.createRange();
    			range.selectNodeContents(this.table.element);
    			sel = window.getSelection();

    			if (sel.toString() && internal) {
    				this.customSelection = sel.toString();
    			}

    			sel.removeAllRanges();
    			sel.addRange(range);
    		} else if (typeof document.selection != "undefined" && typeof document.body.createTextRange != "undefined") {
    			textRange = document.body.createTextRange();
    			textRange.moveToElementText(this.table.element);
    			textRange.select();
    		}

    		document.execCommand('copy');

    		if (sel) {
    			sel.removeAllRanges();
    		}
    	}
    };

    //PASTE EVENT HANDLING

    Clipboard.prototype.setPasteAction = function (action) {

    	switch (typeof action === 'undefined' ? 'undefined' : _typeof(action)) {
    		case "string":
    			this.pasteAction = this.pasteActions[action];

    			if (!this.pasteAction) {
    				console.warn("Clipboard Error - No such paste action found:", action);
    			}
    			break;

    		case "function":
    			this.pasteAction = action;
    			break;
    	}
    };

    Clipboard.prototype.setPasteParser = function (parser) {
    	switch (typeof parser === 'undefined' ? 'undefined' : _typeof(parser)) {
    		case "string":
    			this.pasteParser = this.pasteParsers[parser];

    			if (!this.pasteParser) {
    				console.warn("Clipboard Error - No such paste parser found:", parser);
    			}
    			break;

    		case "function":
    			this.pasteParser = parser;
    			break;
    	}
    };

    Clipboard.prototype.paste = function (e) {
    	var data, rowData, rows;

    	if (this.checkPaseOrigin(e)) {

    		data = this.getPasteData(e);

    		rowData = this.pasteParser.call(this, data);

    		if (rowData) {
    			e.preventDefault();

    			if (this.table.modExists("mutator")) {
    				rowData = this.mutateData(rowData);
    			}

    			rows = this.pasteAction.call(this, rowData);
    			this.table.options.clipboardPasted.call(this.table, data, rowData, rows);
    		} else {
    			this.table.options.clipboardPasteError.call(this.table, data);
    		}
    	}
    };

    Clipboard.prototype.mutateData = function (data) {
    	var self = this,
    	    output = [];

    	if (Array.isArray(data)) {
    		data.forEach(function (row) {
    			output.push(self.table.modules.mutator.transformRow(row, "clipboard"));
    		});
    	} else {
    		output = data;
    	}

    	return output;
    };

    Clipboard.prototype.checkPaseOrigin = function (e) {
    	var valid = true;

    	if (e.target.tagName != "DIV" || this.table.modules.edit.currentCell) {
    		valid = false;
    	}

    	return valid;
    };

    Clipboard.prototype.getPasteData = function (e) {
    	var data;

    	if (window.clipboardData && window.clipboardData.getData) {
    		data = window.clipboardData.getData('Text');
    	} else if (e.clipboardData && e.clipboardData.getData) {
    		data = e.clipboardData.getData('text/plain');
    	} else if (e.originalEvent && e.originalEvent.clipboardData.getData) {
    		data = e.originalEvent.clipboardData.getData('text/plain');
    	}

    	return data;
    };

    Clipboard.prototype.pasteParsers = {
    	table: function table(clipboard) {
    		var data = [],
    		    headerFindSuccess = true,
    		    columns = this.table.columnManager.columns,
    		    columnMap = [],
    		    rows = [];

    		//get data from clipboard into array of columns and rows.
    		clipboard = clipboard.split("\n");

    		clipboard.forEach(function (row) {
    			data.push(row.split("\t"));
    		});

    		if (data.length && !(data.length === 1 && data[0].length < 2)) {

    			//check if headers are present by title
    			data[0].forEach(function (value) {
    				var column = columns.find(function (column) {
    					return value && column.definition.title && value.trim() && column.definition.title.trim() === value.trim();
    				});

    				if (column) {
    					columnMap.push(column);
    				} else {
    					headerFindSuccess = false;
    				}
    			});

    			//check if column headers are present by field
    			if (!headerFindSuccess) {
    				headerFindSuccess = true;
    				columnMap = [];

    				data[0].forEach(function (value) {
    					var column = columns.find(function (column) {
    						return value && column.field && value.trim() && column.field.trim() === value.trim();
    					});

    					if (column) {
    						columnMap.push(column);
    					} else {
    						headerFindSuccess = false;
    					}
    				});

    				if (!headerFindSuccess) {
    					columnMap = this.table.columnManager.columnsByIndex;
    				}
    			}

    			//remove header row if found
    			if (headerFindSuccess) {
    				data.shift();
    			}

    			data.forEach(function (item) {
    				var row = {};

    				item.forEach(function (value, i) {
    					if (columnMap[i]) {
    						row[columnMap[i].field] = value;
    					}
    				});

    				rows.push(row);
    			});

    			return rows;
    		} else {
    			return false;
    		}
    	}
    };

    Clipboard.prototype.pasteActions = {
    	replace: function replace(rows) {
    		return this.table.setData(rows);
    	},
    	update: function update(rows) {
    		return this.table.updateOrAddData(rows);
    	},
    	insert: function insert(rows) {
    		return this.table.addData(rows);
    	}
    };

    Tabulator.prototype.registerModule("clipboard", Clipboard);

    var DataTree = function DataTree(table) {
    	this.table = table;
    	this.indent = 10;
    	this.field = "";
    	this.collapseEl = null;
    	this.expandEl = null;
    	this.branchEl = null;
    	this.elementField = false;

    	this.startOpen = function () {};

    	this.displayIndex = 0;
    };

    DataTree.prototype.initialize = function () {
    	var dummyEl = null,
    	    firstCol = this.table.columnManager.getFirstVisibileColumn(),
    	    options = this.table.options;

    	this.field = options.dataTreeChildField;
    	this.indent = options.dataTreeChildIndent;
    	this.elementField = options.dataTreeElementColumn || (firstCol ? firstCol.field : false);

    	if (options.dataTreeBranchElement) {

    		if (options.dataTreeBranchElement === true) {
    			this.branchEl = document.createElement("div");
    			this.branchEl.classList.add("tabulator-data-tree-branch");
    		} else {
    			if (typeof options.dataTreeBranchElement === "string") {
    				dummyEl = document.createElement("div");
    				dummyEl.innerHTML = options.dataTreeBranchElement;
    				this.branchEl = dummyEl.firstChild;
    			} else {
    				this.branchEl = options.dataTreeBranchElement;
    			}
    		}
    	}

    	if (options.dataTreeCollapseElement) {
    		if (typeof options.dataTreeCollapseElement === "string") {
    			dummyEl = document.createElement("div");
    			dummyEl.innerHTML = options.dataTreeCollapseElement;
    			this.collapseEl = dummyEl.firstChild;
    		} else {
    			this.collapseEl = options.dataTreeCollapseElement;
    		}
    	} else {
    		this.collapseEl = document.createElement("div");
    		this.collapseEl.classList.add("tabulator-data-tree-control");
    		this.collapseEl.tabIndex = 0;
    		this.collapseEl.innerHTML = "<div class='tabulator-data-tree-control-collapse'></div>";
    	}

    	if (options.dataTreeExpandElement) {
    		if (typeof options.dataTreeExpandElement === "string") {
    			dummyEl = document.createElement("div");
    			dummyEl.innerHTML = options.dataTreeExpandElement;
    			this.expandEl = dummyEl.firstChild;
    		} else {
    			this.expandEl = options.dataTreeExpandElement;
    		}
    	} else {
    		this.expandEl = document.createElement("div");
    		this.expandEl.classList.add("tabulator-data-tree-control");
    		this.expandEl.tabIndex = 0;
    		this.expandEl.innerHTML = "<div class='tabulator-data-tree-control-expand'></div>";
    	}

    	switch (_typeof(options.dataTreeStartExpanded)) {
    		case "boolean":
    			this.startOpen = function (row, index) {
    				return options.dataTreeStartExpanded;
    			};
    			break;

    		case "function":
    			this.startOpen = options.dataTreeStartExpanded;
    			break;

    		default:
    			this.startOpen = function (row, index) {
    				return options.dataTreeStartExpanded[index];
    			};
    			break;
    	}
    };

    DataTree.prototype.initializeRow = function (row) {
    	var childArray = row.getData()[this.field];
    	var isArray = Array.isArray(childArray);

    	var children = isArray || !isArray && (typeof childArray === 'undefined' ? 'undefined' : _typeof(childArray)) === "object" && childArray !== null;

    	if (!children && row.modules.dataTree && row.modules.dataTree.branchEl) {
    		row.modules.dataTree.branchEl.parentNode.removeChild(row.modules.dataTree.branchEl);
    	}

    	if (!children && row.modules.dataTree && row.modules.dataTree.controlEl) {
    		row.modules.dataTree.controlEl.parentNode.removeChild(row.modules.dataTree.controlEl);
    	}

    	row.modules.dataTree = {
    		index: row.modules.dataTree ? row.modules.dataTree.index : 0,
    		open: children ? row.modules.dataTree ? row.modules.dataTree.open : this.startOpen(row.getComponent(), 0) : false,
    		controlEl: row.modules.dataTree && children ? row.modules.dataTree.controlEl : false,
    		branchEl: row.modules.dataTree && children ? row.modules.dataTree.branchEl : false,
    		parent: row.modules.dataTree ? row.modules.dataTree.parent : false,
    		children: children
    	};
    };

    DataTree.prototype.layoutRow = function (row) {
    	var cell = this.elementField ? row.getCell(this.elementField) : row.getCells()[0],
    	    el = cell.getElement(),
    	    config = row.modules.dataTree;

    	if (config.branchEl) {
    		if (config.branchEl.parentNode) {
    			config.branchEl.parentNode.removeChild(config.branchEl);
    		}
    		config.branchEl = false;
    	}

    	if (config.controlEl) {
    		if (config.controlEl.parentNode) {
    			config.controlEl.parentNode.removeChild(config.controlEl);
    		}
    		config.controlEl = false;
    	}

    	this.generateControlElement(row, el);

    	row.getElement().classList.add("tabulator-tree-level-" + config.index);

    	if (config.index) {
    		if (this.branchEl) {
    			config.branchEl = this.branchEl.cloneNode(true);
    			el.insertBefore(config.branchEl, el.firstChild);

    			if (this.table.rtl) {
    				config.branchEl.style.marginRight = (config.branchEl.offsetWidth + config.branchEl.style.marginLeft) * (config.index - 1) + config.index * this.indent + "px";
    			} else {
    				config.branchEl.style.marginLeft = (config.branchEl.offsetWidth + config.branchEl.style.marginRight) * (config.index - 1) + config.index * this.indent + "px";
    			}
    		} else {

    			if (this.table.rtl) {
    				el.style.paddingRight = parseInt(window.getComputedStyle(el, null).getPropertyValue('padding-right')) + config.index * this.indent + "px";
    			} else {
    				el.style.paddingLeft = parseInt(window.getComputedStyle(el, null).getPropertyValue('padding-left')) + config.index * this.indent + "px";
    			}
    		}
    	}
    };

    DataTree.prototype.generateControlElement = function (row, el) {
    	var _this47 = this;

    	var config = row.modules.dataTree,
    	    el = el || row.getCells()[0].getElement(),
    	    oldControl = config.controlEl;

    	if (config.children !== false) {

    		if (config.open) {
    			config.controlEl = this.collapseEl.cloneNode(true);
    			config.controlEl.addEventListener("click", function (e) {
    				e.stopPropagation();
    				_this47.collapseRow(row);
    			});
    		} else {
    			config.controlEl = this.expandEl.cloneNode(true);
    			config.controlEl.addEventListener("click", function (e) {
    				e.stopPropagation();
    				_this47.expandRow(row);
    			});
    		}

    		config.controlEl.addEventListener("mousedown", function (e) {
    			e.stopPropagation();
    		});

    		if (oldControl && oldControl.parentNode === el) {
    			oldControl.parentNode.replaceChild(config.controlEl, oldControl);
    		} else {
    			el.insertBefore(config.controlEl, el.firstChild);
    		}
    	}
    };

    DataTree.prototype.setDisplayIndex = function (index) {
    	this.displayIndex = index;
    };

    DataTree.prototype.getDisplayIndex = function () {
    	return this.displayIndex;
    };

    DataTree.prototype.getRows = function (rows) {
    	var _this48 = this;

    	var output = [];

    	rows.forEach(function (row, i) {
    		var config, children;

    		output.push(row);

    		if (row instanceof Row) {

    			row.create();

    			config = row.modules.dataTree.children;

    			if (!config.index && config.children !== false) {
    				children = _this48.getChildren(row);

    				children.forEach(function (child) {
    					child.create();
    					output.push(child);
    				});
    			}
    		}
    	});

    	return output;
    };

    DataTree.prototype.getChildren = function (row, allChildren) {
    	var _this49 = this;

    	var config = row.modules.dataTree,
    	    children = [],
    	    output = [];

    	if (config.children !== false && (config.open || allChildren)) {
    		if (!Array.isArray(config.children)) {
    			config.children = this.generateChildren(row);
    		}

    		if (this.table.modExists("filter") && this.table.options.dataTreeFilter) {
    			children = this.table.modules.filter.filter(config.children);
    		} else {
    			children = config.children;
    		}

    		if (this.table.modExists("sort") && this.table.options.dataTreeSort) {
    			this.table.modules.sort.sort(children);
    		}

    		children.forEach(function (child) {
    			output.push(child);

    			var subChildren = _this49.getChildren(child);

    			subChildren.forEach(function (sub) {
    				output.push(sub);
    			});
    		});
    	}

    	return output;
    };

    DataTree.prototype.generateChildren = function (row) {
    	var _this50 = this;

    	var children = [];

    	var childArray = row.getData()[this.field];

    	if (!Array.isArray(childArray)) {
    		childArray = [childArray];
    	}

    	childArray.forEach(function (childData) {
    		var childRow = new Row(childData || {}, _this50.table.rowManager);

    		childRow.create();

    		childRow.modules.dataTree.index = row.modules.dataTree.index + 1;
    		childRow.modules.dataTree.parent = row;

    		if (childRow.modules.dataTree.children) {
    			childRow.modules.dataTree.open = _this50.startOpen(childRow.getComponent(), childRow.modules.dataTree.index);
    		}
    		children.push(childRow);
    	});

    	return children;
    };

    DataTree.prototype.expandRow = function (row, silent) {
    	var config = row.modules.dataTree;

    	if (config.children !== false) {
    		config.open = true;

    		row.reinitialize();

    		this.table.rowManager.refreshActiveData("tree", false, true);

    		this.table.options.dataTreeRowExpanded(row.getComponent(), row.modules.dataTree.index);
    	}
    };

    DataTree.prototype.collapseRow = function (row) {
    	var config = row.modules.dataTree;

    	if (config.children !== false) {
    		config.open = false;

    		row.reinitialize();

    		this.table.rowManager.refreshActiveData("tree", false, true);

    		this.table.options.dataTreeRowCollapsed(row.getComponent(), row.modules.dataTree.index);
    	}
    };

    DataTree.prototype.toggleRow = function (row) {
    	var config = row.modules.dataTree;

    	if (config.children !== false) {
    		if (config.open) {
    			this.collapseRow(row);
    		} else {
    			this.expandRow(row);
    		}
    	}
    };

    DataTree.prototype.getTreeParent = function (row) {
    	return row.modules.dataTree.parent ? row.modules.dataTree.parent.getComponent() : false;
    };

    DataTree.prototype.getFilteredTreeChildren = function (row) {
    	var config = row.modules.dataTree,
    	    output = [],
    	    children;

    	if (config.children) {

    		if (!Array.isArray(config.children)) {
    			config.children = this.generateChildren(row);
    		}

    		if (this.table.modExists("filter") && this.table.options.dataTreeFilter) {
    			children = this.table.modules.filter.filter(config.children);
    		} else {
    			children = config.children;
    		}

    		children.forEach(function (childRow) {
    			if (childRow instanceof Row) {
    				output.push(childRow);
    			}
    		});
    	}

    	return output;
    };

    DataTree.prototype.rowDelete = function (row) {
    	var parent = row.modules.dataTree.parent,
    	    childIndex;

    	if (parent) {
    		childIndex = this.findChildIndex(row, parent);

    		if (childIndex !== false) {
    			parent.data[this.field].splice(childIndex, 1);
    		}

    		if (!parent.data[this.field].length) {
    			delete parent.data[this.field];
    		}

    		this.initializeRow(parent);
    		this.layoutRow(parent);
    	}

    	this.table.rowManager.refreshActiveData("tree", false, true);
    };

    DataTree.prototype.addTreeChildRow = function (row, data, top, index) {
    	var childIndex = false;

    	if (typeof data === "string") {
    		data = JSON.parse(data);
    	}

    	if (!Array.isArray(row.data[this.field])) {
    		row.data[this.field] = [];

    		row.modules.dataTree.open = this.startOpen(row.getComponent(), row.modules.dataTree.index);
    	}

    	if (typeof index !== "undefined") {
    		childIndex = this.findChildIndex(index, row);

    		if (childIndex !== false) {
    			row.data[this.field].splice(top ? childIndex : childIndex + 1, 0, data);
    		}
    	}

    	if (childIndex === false) {
    		if (top) {
    			row.data[this.field].unshift(data);
    		} else {
    			row.data[this.field].push(data);
    		}
    	}

    	this.initializeRow(row);
    	this.layoutRow(row);

    	this.table.rowManager.refreshActiveData("tree", false, true);
    };

    DataTree.prototype.findChildIndex = function (subject, parent) {
    	var _this51 = this;

    	var match = false;

    	if ((typeof subject === 'undefined' ? 'undefined' : _typeof(subject)) == "object") {

    		if (subject instanceof Row) {
    			//subject is row element
    			match = subject.data;
    		} else if (subject instanceof RowComponent) {
    			//subject is public row component
    			match = subject._getSelf().data;
    		} else if (typeof HTMLElement !== "undefined" && subject instanceof HTMLElement) {
    			if (parent.modules.dataTree) {
    				match = parent.modules.dataTree.children.find(function (childRow) {
    					return childRow instanceof Row ? childRow.element === subject : false;
    				});

    				if (match) {
    					match = match.data;
    				}
    			}
    		}
    	} else if (typeof subject == "undefined" || subject === null) {
    		match = false;
    	} else {
    		//subject should be treated as the index of the row
    		match = parent.data[this.field].find(function (row) {
    			return row.data[_this51.table.options.index] == subject;
    		});
    	}

    	if (match) {

    		if (Array.isArray(parent.data[this.field])) {
    			match = parent.data[this.field].indexOf(match);
    		}

    		if (match == -1) {
    			match = false;
    		}
    	}

    	//catch all for any other type of input

    	return match;
    };

    DataTree.prototype.getTreeChildren = function (row, component, recurse) {
    	var _this52 = this;

    	var config = row.modules.dataTree,
    	    output = [];

    	if (config.children) {

    		if (!Array.isArray(config.children)) {
    			config.children = this.generateChildren(row);
    		}

    		config.children.forEach(function (childRow) {
    			if (childRow instanceof Row) {
    				output.push(component ? childRow.getComponent() : childRow);

    				if (recurse) {
    					output = output.concat(_this52.getTreeChildren(childRow, component, recurse));
    				}
    			}
    		});
    	}

    	return output;
    };

    DataTree.prototype.checkForRestyle = function (cell) {
    	if (!cell.row.cells.indexOf(cell)) {
    		cell.row.reinitialize();
    	}
    };

    DataTree.prototype.getChildField = function () {
    	return this.field;
    };

    DataTree.prototype.redrawNeeded = function (data) {
    	return (this.field ? typeof data[this.field] !== "undefined" : false) || (this.elementField ? typeof data[this.elementField] !== "undefined" : false);
    };

    Tabulator.prototype.registerModule("dataTree", DataTree);

    var Download = function Download(table) {
    	this.table = table; //hold Tabulator object
    };

    //trigger file download
    Download.prototype.download = function (type, filename, options, range, interceptCallback) {
    	var self = this,
    	    downloadFunc = false;

    	function buildLink(data, mime) {
    		if (interceptCallback) {
    			if (interceptCallback === true) {
    				self.triggerDownload(data, mime, type, filename, true);
    			} else {
    				interceptCallback(data);
    			}
    		} else {
    			self.triggerDownload(data, mime, type, filename);
    		}
    	}

    	if (typeof type == "function") {
    		downloadFunc = type;
    	} else {
    		if (self.downloaders[type]) {
    			downloadFunc = self.downloaders[type];
    		} else {
    			console.warn("Download Error - No such download type found: ", type);
    		}
    	}

    	if (downloadFunc) {
    		var list = this.generateExportList(range);

    		downloadFunc.call(this.table, list, options || {}, buildLink);
    	}
    };

    Download.prototype.generateExportList = function (range) {
    	var list = this.table.modules.export.generateExportList(this.table.options.downloadConfig, false, range || this.table.options.downloadRowRange, "download");

    	//assign group header formatter
    	var groupHeader = this.table.options.groupHeaderDownload;

    	if (groupHeader && !Array.isArray(groupHeader)) {
    		groupHeader = [groupHeader];
    	}

    	list.forEach(function (row) {
    		var group;

    		if (row.type === "group") {
    			group = row.columns[0];

    			if (groupHeader && groupHeader[row.indent]) {
    				group.value = groupHeader[row.indent](group.value, row.component._group.getRowCount(), row.component._group.getData(), row.component);
    			}
    		}
    	});

    	return list;
    };

    Download.prototype.triggerDownload = function (data, mime, type, filename, newTab) {
    	var element = document.createElement('a'),
    	    blob = new Blob([data], { type: mime }),
    	    filename = filename || "Tabulator." + (typeof type === "function" ? "txt" : type);

    	blob = this.table.options.downloadReady.call(this.table, data, blob);

    	if (blob) {

    		if (newTab) {
    			window.open(window.URL.createObjectURL(blob));
    		} else {
    			if (navigator.msSaveOrOpenBlob) {
    				navigator.msSaveOrOpenBlob(blob, filename);
    			} else {
    				element.setAttribute('href', window.URL.createObjectURL(blob));

    				//set file title
    				element.setAttribute('download', filename);

    				//trigger download
    				element.style.display = 'none';
    				document.body.appendChild(element);
    				element.click();

    				//remove temporary link element
    				document.body.removeChild(element);
    			}
    		}

    		if (this.table.options.downloadComplete) {
    			this.table.options.downloadComplete();
    		}
    	}
    };

    Download.prototype.commsReceived = function (table, action, data) {
    	switch (action) {
    		case "intercept":
    			this.download(data.type, "", data.options, data.active, data.intercept);
    			break;
    	}
    };

    //downloaders
    Download.prototype.downloaders = {
    	csv: function csv(list, options, setFileContents) {
    		var delimiter = options && options.delimiter ? options.delimiter : ",",
    		    fileContents = [],
    		    headers = [];

    		list.forEach(function (row) {
    			var item = [];

    			switch (row.type) {
    				case "group":
    					console.warn("Download Warning - CSV downloader cannot process row groups");
    					break;

    				case "calc":
    					console.warn("Download Warning - CSV downloader cannot process column calculations");
    					break;

    				case "header":
    					row.columns.forEach(function (col, i) {
    						if (col && col.depth === 1) {
    							headers[i] = typeof col.value == "undefined" || col.value === null ? "" : '"' + String(col.value).split('"').join('""') + '"';
    						}
    					});
    					break;

    				case "row":
    					row.columns.forEach(function (col) {

    						if (col) {

    							switch (_typeof(col.value)) {
    								case "object":
    									col.value = JSON.stringify(col.value);
    									break;

    								case "undefined":
    								case "null":
    									col.value = "";
    									break;
    							}

    							item.push('"' + String(col.value).split('"').join('""') + '"');
    						}
    					});

    					fileContents.push(item.join(delimiter));
    					break;
    			}
    		});

    		if (headers.length) {
    			fileContents.unshift(headers.join(delimiter));
    		}

    		fileContents = fileContents.join("\n");

    		if (options.bom) {
    			fileContents = '\uFEFF' + fileContents;
    		}

    		setFileContents(fileContents, "text/csv");
    	},

    	json: function json(list, options, setFileContents) {
    		var fileContents = [];

    		list.forEach(function (row) {
    			var item = {};

    			switch (row.type) {
    				case "header":
    					break;

    				case "group":
    					console.warn("Download Warning - JSON downloader cannot process row groups");
    					break;

    				case "calc":
    					console.warn("Download Warning - JSON downloader cannot process column calculations");
    					break;

    				case "row":
    					row.columns.forEach(function (col) {
    						if (col) {
    							item[col.component.getField()] = col.value;
    						}
    					});

    					fileContents.push(item);
    					break;
    			}
    		});

    		fileContents = JSON.stringify(fileContents, null, '\t');

    		setFileContents(fileContents, "application/json");
    	},

    	pdf: function pdf(list, options, setFileContents) {
    		var header = [],
    		    body = [],
    		    autoTableParams = {},
    		    rowGroupStyles = options.rowGroupStyles || {
    			fontStyle: "bold",
    			fontSize: 12,
    			cellPadding: 6,
    			fillColor: 220
    		},
    		    rowCalcStyles = options.rowCalcStyles || {
    			fontStyle: "bold",
    			fontSize: 10,
    			cellPadding: 4,
    			fillColor: 232
    		},
    		    jsPDFParams = options.jsPDF || {},
    		    title = options && options.title ? options.title : "";

    		if (!jsPDFParams.orientation) {
    			jsPDFParams.orientation = options.orientation || "landscape";
    		}

    		if (!jsPDFParams.unit) {
    			jsPDFParams.unit = "pt";
    		}

    		//parse row list
    		list.forEach(function (row) {

    			switch (row.type) {
    				case "header":
    					header.push(parseRow(row));
    					break;

    				case "group":
    					body.push(parseRow(row, rowGroupStyles));
    					break;

    				case "calc":
    					body.push(parseRow(row, rowCalcStyles));
    					break;

    				case "row":
    					body.push(parseRow(row));
    					break;
    			}
    		});

    		function parseRow(row, styles) {
    			var rowData = [];

    			row.columns.forEach(function (col) {
    				var cell;

    				if (col) {
    					switch (_typeof(col.value)) {
    						case "object":
    							col.value = JSON.stringify(col.value);
    							break;

    						case "undefined":
    						case "null":
    							col.value = "";
    							break;
    					}

    					cell = {
    						content: col.value,
    						colSpan: col.width,
    						rowSpan: col.height
    					};

    					if (styles) {
    						cell.styles = styles;
    					}

    					rowData.push(cell);
    				} else {
    					rowData.push("");
    				}
    			});

    			return rowData;
    		}

    		//configure PDF
    		var doc = new jsPDF(jsPDFParams); //set document to landscape, better for most tables

    		if (options && options.autoTable) {
    			if (typeof options.autoTable === "function") {
    				autoTableParams = options.autoTable(doc) || {};
    			} else {
    				autoTableParams = options.autoTable;
    			}
    		}

    		if (title) {
    			autoTableParams.addPageContent = function (data) {
    				doc.text(title, 40, 30);
    			};
    		}

    		autoTableParams.head = header;
    		autoTableParams.body = body;

    		doc.autoTable(autoTableParams);

    		if (options && options.documentProcessing) {
    			options.documentProcessing(doc);
    		}

    		setFileContents(doc.output("arraybuffer"), "application/pdf");
    	},

    	xlsx: function xlsx(list, options, setFileContents) {
    		var self = this,
    		    sheetName = options.sheetName || "Sheet1",
    		    workbook = XLSX.utils.book_new(),
    		    output;

    		workbook.SheetNames = [];
    		workbook.Sheets = {};

    		function generateSheet() {
    			var rows = [],
    			    merges = [],
    			    worksheet = {},
    			    range = { s: { c: 0, r: 0 }, e: { c: list[0] ? list[0].columns.reduce(function (a, b) {
    						return a + (b && b.width ? b.width : 1);
    					}, 0) : 0, r: list.length } };

    			//parse row list
    			list.forEach(function (row, i) {
    				var rowData = [];

    				row.columns.forEach(function (col, j) {

    					if (col) {
    						rowData.push(!(col.value instanceof Date) && _typeof(col.value) === "object" ? JSON.stringify(col.value) : col.value);

    						if (col.width > 1 || col.height > -1) {
    							merges.push({ s: { r: i, c: j }, e: { r: i + col.height - 1, c: j + col.width - 1 } });
    						}
    					} else {
    						rowData.push("");
    					}
    				});

    				rows.push(rowData);
    			});

    			//convert rows to worksheet
    			XLSX.utils.sheet_add_aoa(worksheet, rows);

    			worksheet['!ref'] = XLSX.utils.encode_range(range);

    			if (merges.length) {
    				worksheet["!merges"] = merges;
    			}

    			return worksheet;
    		}

    		if (options.sheetOnly) {
    			setFileContents(generateSheet());
    			return;
    		}

    		if (options.sheets) {
    			for (var sheet in options.sheets) {

    				if (options.sheets[sheet] === true) {
    					workbook.SheetNames.push(sheet);
    					workbook.Sheets[sheet] = generateSheet();
    				} else {

    					workbook.SheetNames.push(sheet);

    					this.modules.comms.send(options.sheets[sheet], "download", "intercept", {
    						type: "xlsx",
    						options: { sheetOnly: true },
    						active: self.active,
    						intercept: function intercept(data) {
    							workbook.Sheets[sheet] = data;
    						}
    					});
    				}
    			}
    		} else {
    			workbook.SheetNames.push(sheetName);
    			workbook.Sheets[sheetName] = generateSheet();
    		}

    		if (options.documentProcessing) {
    			workbook = options.documentProcessing(workbook);
    		}

    		//convert workbook to binary array
    		function s2ab(s) {
    			var buf = new ArrayBuffer(s.length);
    			var view = new Uint8Array(buf);
    			for (var i = 0; i != s.length; ++i) {
    				view[i] = s.charCodeAt(i) & 0xFF;
    			}return buf;
    		}

    		output = XLSX.write(workbook, { bookType: 'xlsx', bookSST: true, type: 'binary' });

    		setFileContents(s2ab(output), "application/octet-stream");
    	},

    	html: function html(list, options, setFileContents) {
    		if (this.modExists("export", true)) {
    			setFileContents(this.modules.export.genereateHTMLTable(list), "text/html");
    		}
    	}

    };

    Tabulator.prototype.registerModule("download", Download);

    var Edit = function Edit(table) {
    	this.table = table; //hold Tabulator object
    	this.currentCell = false; //hold currently editing cell
    	this.mouseClick = false; //hold mousedown state to prevent click binding being overriden by editor opening
    	this.recursionBlock = false; //prevent focus recursion
    	this.invalidEdit = false;
    	this.editedCells = [];
    };

    //initialize column editor
    Edit.prototype.initializeColumn = function (column) {
    	var self = this,
    	    config = {
    		editor: false,
    		blocked: false,
    		check: column.definition.editable,
    		params: column.definition.editorParams || {}
    	};

    	//set column editor
    	switch (_typeof(column.definition.editor)) {
    		case "string":

    			if (column.definition.editor === "tick") {
    				column.definition.editor = "tickCross";
    				console.warn("DEPRECATION WARNING - the tick editor has been deprecated, please use the tickCross editor");
    			}

    			if (self.editors[column.definition.editor]) {
    				config.editor = self.editors[column.definition.editor];
    			} else {
    				console.warn("Editor Error - No such editor found: ", column.definition.editor);
    			}
    			break;

    		case "function":
    			config.editor = column.definition.editor;
    			break;

    		case "boolean":

    			if (column.definition.editor === true) {

    				if (typeof column.definition.formatter !== "function") {

    					if (column.definition.formatter === "tick") {
    						column.definition.formatter = "tickCross";
    						console.warn("DEPRECATION WARNING - the tick editor has been deprecated, please use the tickCross editor");
    					}

    					if (self.editors[column.definition.formatter]) {
    						config.editor = self.editors[column.definition.formatter];
    					} else {
    						config.editor = self.editors["input"];
    					}
    				} else {
    					console.warn("Editor Error - Cannot auto lookup editor for a custom formatter: ", column.definition.formatter);
    				}
    			}
    			break;
    	}

    	if (config.editor) {
    		column.modules.edit = config;
    	}
    };

    Edit.prototype.getCurrentCell = function () {
    	return this.currentCell ? this.currentCell.getComponent() : false;
    };

    Edit.prototype.clearEditor = function (cancel) {
    	var cell = this.currentCell,
    	    cellEl;

    	this.invalidEdit = false;

    	if (cell) {
    		this.currentCell = false;

    		cellEl = cell.getElement();

    		if (cancel) {
    			cell.validate();
    		} else {
    			cellEl.classList.remove("tabulator-validation-fail");
    		}

    		cellEl.classList.remove("tabulator-editing");
    		while (cellEl.firstChild) {
    			cellEl.removeChild(cellEl.firstChild);
    		}cell.row.getElement().classList.remove("tabulator-row-editing");
    	}
    };

    Edit.prototype.cancelEdit = function () {

    	if (this.currentCell) {
    		var cell = this.currentCell;
    		var component = this.currentCell.getComponent();

    		this.clearEditor(true);
    		cell.setValueActual(cell.getValue());
    		cell.cellRendered();

    		if (cell.column.definition.editor == "textarea" || cell.column.definition.variableHeight) {
    			cell.row.normalizeHeight(true);
    		}

    		if (cell.column.cellEvents.cellEditCancelled) {
    			cell.column.cellEvents.cellEditCancelled.call(this.table, component);
    		}

    		this.table.options.cellEditCancelled.call(this.table, component);
    	}
    };

    //return a formatted value for a cell
    Edit.prototype.bindEditor = function (cell) {
    	var self = this,
    	    element = cell.getElement(true);

    	element.setAttribute("tabindex", 0);

    	element.addEventListener("click", function (e) {
    		if (!element.classList.contains("tabulator-editing")) {
    			element.focus({ preventScroll: true });
    		}
    	});

    	element.addEventListener("mousedown", function (e) {
    		if (e.button === 2) {
    			e.preventDefault();
    		} else {
    			self.mouseClick = true;
    		}
    	});

    	element.addEventListener("focus", function (e) {
    		if (!self.recursionBlock) {
    			self.edit(cell, e, false);
    		}
    	});
    };

    Edit.prototype.focusCellNoEvent = function (cell, block) {
    	this.recursionBlock = true;
    	if (!(block && this.table.browser === "ie")) {
    		cell.getElement().focus({ preventScroll: true });
    	}
    	this.recursionBlock = false;
    };

    Edit.prototype.editCell = function (cell, forceEdit) {
    	this.focusCellNoEvent(cell);
    	this.edit(cell, false, forceEdit);
    };

    Edit.prototype.focusScrollAdjust = function (cell) {
    	if (this.table.rowManager.getRenderMode() == "virtual") {
    		var topEdge = this.table.rowManager.element.scrollTop,
    		    bottomEdge = this.table.rowManager.element.clientHeight + this.table.rowManager.element.scrollTop,
    		    rowEl = cell.row.getElement();
    		    rowEl.offsetTop;

    		if (rowEl.offsetTop < topEdge) {
    			this.table.rowManager.element.scrollTop -= topEdge - rowEl.offsetTop;
    		} else {
    			if (rowEl.offsetTop + rowEl.offsetHeight > bottomEdge) {
    				this.table.rowManager.element.scrollTop += rowEl.offsetTop + rowEl.offsetHeight - bottomEdge;
    			}
    		}

    		var leftEdge = this.table.rowManager.element.scrollLeft,
    		    rightEdge = this.table.rowManager.element.clientWidth + this.table.rowManager.element.scrollLeft,
    		    cellEl = cell.getElement();
    		    cellEl.offsetLeft;

    		if (this.table.modExists("frozenColumns")) {
    			leftEdge += parseInt(this.table.modules.frozenColumns.leftMargin);
    			rightEdge -= parseInt(this.table.modules.frozenColumns.rightMargin);
    		}

    		if (this.table.options.virtualDomHoz) {
    			leftEdge -= parseInt(this.table.vdomHoz.vDomPadLeft);
    			rightEdge -= parseInt(this.table.vdomHoz.vDomPadLeft);
    		}

    		if (cellEl.offsetLeft < leftEdge) {

    			this.table.rowManager.element.scrollLeft -= leftEdge - cellEl.offsetLeft;
    		} else {
    			if (cellEl.offsetLeft + cellEl.offsetWidth > rightEdge) {
    				this.table.rowManager.element.scrollLeft += cellEl.offsetLeft + cellEl.offsetWidth - rightEdge;
    			}
    		}
    	}
    };

    Edit.prototype.edit = function (cell, e, forceEdit) {
    	var self = this,
    	    allowEdit = true,
    	    rendered = function rendered() {},
    	    element = cell.getElement(),
    	    cellEditor,
    	    component,
    	    params;

    	//prevent editing if another cell is refusing to leave focus (eg. validation fail)
    	if (this.currentCell) {
    		if (!this.invalidEdit) {
    			this.cancelEdit();
    		}
    		return;
    	}

    	//handle successfull value change
    	function success(value) {
    		if (self.currentCell === cell) {
    			var valid = true;

    			if (cell.column.modules.validate && self.table.modExists("validate") && self.table.options.validationMode != "manual") {
    				valid = self.table.modules.validate.validate(cell.column.modules.validate, cell, value);
    			}

    			if (valid === true || self.table.options.validationMode === "highlight") {
    				self.clearEditor();

    				if (!cell.modules.edit) {
    					cell.modules.edit = {};
    				}

    				cell.modules.edit.edited = true;

    				if (self.editedCells.indexOf(cell) == -1) {
    					self.editedCells.push(cell);
    				}

    				cell.setValue(value, true);

    				if (self.table.options.dataTree && self.table.modExists("dataTree")) {
    					self.table.modules.dataTree.checkForRestyle(cell);
    				}

    				if (valid !== true) {
    					element.classList.add("tabulator-validation-fail");
    					self.table.options.validationFailed.call(self.table, cell.getComponent(), value, valid);
    					return false;
    				}

    				return true;
    			} else {
    				self.invalidEdit = true;
    				element.classList.add("tabulator-validation-fail");
    				self.focusCellNoEvent(cell, true);
    				rendered();
    				self.table.options.validationFailed.call(self.table, cell.getComponent(), value, valid);

    				return false;
    			}
    		}
    	}

    	//handle aborted edit
    	function cancel() {
    		if (self.currentCell === cell) {
    			self.cancelEdit();

    			if (self.table.options.dataTree && self.table.modExists("dataTree")) {
    				self.table.modules.dataTree.checkForRestyle(cell);
    			}
    		}
    	}

    	function onRendered(callback) {
    		rendered = callback;
    	}

    	if (!cell.column.modules.edit.blocked) {
    		if (e) {
    			e.stopPropagation();
    		}

    		switch (_typeof(cell.column.modules.edit.check)) {
    			case "function":
    				allowEdit = cell.column.modules.edit.check(cell.getComponent());
    				break;

    			case "boolean":
    				allowEdit = cell.column.modules.edit.check;
    				break;
    		}

    		if (allowEdit || forceEdit) {

    			self.cancelEdit();

    			self.currentCell = cell;

    			this.focusScrollAdjust(cell);

    			component = cell.getComponent();

    			if (this.mouseClick) {
    				this.mouseClick = false;

    				if (cell.column.cellEvents.cellClick) {
    					cell.column.cellEvents.cellClick.call(this.table, e, component);
    				}
    			}

    			if (cell.column.cellEvents.cellEditing) {
    				cell.column.cellEvents.cellEditing.call(this.table, component);
    			}

    			self.table.options.cellEditing.call(this.table, component);

    			params = typeof cell.column.modules.edit.params === "function" ? cell.column.modules.edit.params(component) : cell.column.modules.edit.params;

    			cellEditor = cell.column.modules.edit.editor.call(self, component, onRendered, success, cancel, params);

    			//if editor returned, add to DOM, if false, abort edit
    			if (cellEditor !== false) {

    				if (cellEditor instanceof Node) {
    					element.classList.add("tabulator-editing");
    					cell.row.getElement().classList.add("tabulator-row-editing");
    					while (element.firstChild) {
    						element.removeChild(element.firstChild);
    					}element.appendChild(cellEditor);

    					//trigger onRendered Callback
    					rendered();

    					//prevent editing from triggering rowClick event
    					var children = element.children;

    					for (var i = 0; i < children.length; i++) {
    						children[i].addEventListener("click", function (e) {
    							e.stopPropagation();
    						});
    					}
    				} else {
    					console.warn("Edit Error - Editor should return an instance of Node, the editor returned:", cellEditor);
    					element.blur();
    					return false;
    				}
    			} else {
    				element.blur();
    				return false;
    			}

    			return true;
    		} else {
    			this.mouseClick = false;
    			element.blur();
    			return false;
    		}
    	} else {
    		this.mouseClick = false;
    		element.blur();
    		return false;
    	}
    };

    Edit.prototype.maskInput = function (el, options) {
    	var mask = options.mask,
    	    maskLetter = typeof options.maskLetterChar !== "undefined" ? options.maskLetterChar : "A",
    	    maskNumber = typeof options.maskNumberChar !== "undefined" ? options.maskNumberChar : "9",
    	    maskWildcard = typeof options.maskWildcardChar !== "undefined" ? options.maskWildcardChar : "*";

    	function fillSymbols(index) {
    		var symbol = mask[index];
    		if (typeof symbol !== "undefined" && symbol !== maskWildcard && symbol !== maskLetter && symbol !== maskNumber) {
    			el.value = el.value + "" + symbol;
    			fillSymbols(index + 1);
    		}
    	}

    	el.addEventListener("keydown", function (e) {
    		var index = el.value.length,
    		    char = e.key;

    		if (e.keyCode > 46) {
    			if (index >= mask.length) {
    				e.preventDefault();
    				e.stopPropagation();
    				return false;
    			} else {
    				switch (mask[index]) {
    					case maskLetter:
    						if (char.toUpperCase() == char.toLowerCase()) {
    							e.preventDefault();
    							e.stopPropagation();
    							return false;
    						}
    						break;

    					case maskNumber:
    						if (isNaN(char)) {
    							e.preventDefault();
    							e.stopPropagation();
    							return false;
    						}
    						break;

    					case maskWildcard:
    						break;

    					default:
    						if (char !== mask[index]) {
    							e.preventDefault();
    							e.stopPropagation();
    							return false;
    						}
    				}
    			}
    		}

    		return;
    	});

    	el.addEventListener("keyup", function (e) {
    		if (e.keyCode > 46) {
    			if (options.maskAutoFill) {
    				fillSymbols(el.value.length);
    			}
    		}
    	});

    	if (!el.placeholder) {
    		el.placeholder = mask;
    	}

    	if (options.maskAutoFill) {
    		fillSymbols(el.value.length);
    	}
    };

    Edit.prototype.getEditedCells = function () {
    	var output = [];

    	this.editedCells.forEach(function (cell) {
    		output.push(cell.getComponent());
    	});

    	return output;
    };

    Edit.prototype.clearEdited = function (cell) {
    	var editIndex;

    	if (cell.modules.edit && cell.modules.edit.edited) {
    		cell.modules.edit.edited = false;

    		if (cell.modules.validate) {
    			cell.modules.validate.invalid = false;
    		}
    	}

    	editIndex = this.editedCells.indexOf(cell);

    	if (editIndex > -1) {
    		this.editedCells.splice(editIndex, 1);
    	}
    };

    //default data editors
    Edit.prototype.editors = {

    	//input element
    	input: function input(cell, onRendered, success, cancel, editorParams) {

    		//create and style input
    		var cellValue = cell.getValue(),
    		    input = document.createElement("input");

    		input.setAttribute("type", editorParams.search ? "search" : "text");

    		input.style.padding = "4px";
    		input.style.width = "100%";
    		input.style.boxSizing = "border-box";

    		if (editorParams.elementAttributes && _typeof(editorParams.elementAttributes) == "object") {
    			for (var key in editorParams.elementAttributes) {
    				if (key.charAt(0) == "+") {
    					key = key.slice(1);
    					input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
    				} else {
    					input.setAttribute(key, editorParams.elementAttributes[key]);
    				}
    			}
    		}

    		input.value = typeof cellValue !== "undefined" ? cellValue : "";

    		onRendered(function () {
    			input.focus({ preventScroll: true });
    			input.style.height = "100%";
    		});

    		function onChange(e) {
    			if ((cellValue === null || typeof cellValue === "undefined") && input.value !== "" || input.value !== cellValue) {
    				if (success(input.value)) {
    					cellValue = input.value; //persist value if successfully validated incase editor is used as header filter
    				}
    			} else {
    				cancel();
    			}
    		}

    		//submit new value on blur or change
    		input.addEventListener("change", onChange);
    		input.addEventListener("blur", onChange);

    		//submit new value on enter
    		input.addEventListener("keydown", function (e) {
    			switch (e.keyCode) {
    				// case 9:
    				case 13:
    					onChange();
    					break;

    				case 27:
    					cancel();
    					break;

    				case 35:
    				case 36:
    					e.stopPropagation();
    					break;
    			}
    		});

    		if (editorParams.mask) {
    			this.table.modules.edit.maskInput(input, editorParams);
    		}

    		return input;
    	},

    	//resizable text area element
    	textarea: function textarea(cell, onRendered, success, cancel, editorParams) {
    		var cellValue = cell.getValue(),
    		    vertNav = editorParams.verticalNavigation || "hybrid",
    		    value = String(cellValue !== null && typeof cellValue !== "undefined" ? cellValue : "");
    		    (value.match(/(?:\r\n|\r|\n)/g) || []).length + 1;
    		    var input = document.createElement("textarea"),
    		    scrollHeight = 0;

    		//create and style input
    		input.style.display = "block";
    		input.style.padding = "2px";
    		input.style.height = "100%";
    		input.style.width = "100%";
    		input.style.boxSizing = "border-box";
    		input.style.whiteSpace = "pre-wrap";
    		input.style.resize = "none";

    		if (editorParams.elementAttributes && _typeof(editorParams.elementAttributes) == "object") {
    			for (var key in editorParams.elementAttributes) {
    				if (key.charAt(0) == "+") {
    					key = key.slice(1);
    					input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
    				} else {
    					input.setAttribute(key, editorParams.elementAttributes[key]);
    				}
    			}
    		}

    		input.value = value;

    		onRendered(function () {
    			input.focus({ preventScroll: true });
    			input.style.height = "100%";

    			input.scrollHeight;
    			input.style.height = input.scrollHeight + "px";
    			cell.getRow().normalizeHeight();
    		});

    		function onChange(e) {

    			if ((cellValue === null || typeof cellValue === "undefined") && input.value !== "" || input.value !== cellValue) {

    				if (success(input.value)) {
    					cellValue = input.value; //persist value if successfully validated incase editor is used as header filter
    				}

    				setTimeout(function () {
    					cell.getRow().normalizeHeight();
    				}, 300);
    			} else {
    				cancel();
    			}
    		}

    		//submit new value on blur or change
    		input.addEventListener("change", onChange);
    		input.addEventListener("blur", onChange);

    		input.addEventListener("keyup", function () {

    			input.style.height = "";

    			var heightNow = input.scrollHeight;

    			input.style.height = heightNow + "px";

    			if (heightNow != scrollHeight) {
    				scrollHeight = heightNow;
    				cell.getRow().normalizeHeight();
    			}
    		});

    		input.addEventListener("keydown", function (e) {

    			switch (e.keyCode) {
    				case 27:
    					cancel();
    					break;

    				case 38:
    					//up arrow
    					if (vertNav == "editor" || vertNav == "hybrid" && input.selectionStart) {
    						e.stopImmediatePropagation();
    						e.stopPropagation();
    					}

    					break;

    				case 40:
    					//down arrow
    					if (vertNav == "editor" || vertNav == "hybrid" && input.selectionStart !== input.value.length) {
    						e.stopImmediatePropagation();
    						e.stopPropagation();
    					}
    					break;

    				case 35:
    				case 36:
    					e.stopPropagation();
    					break;
    			}
    		});

    		if (editorParams.mask) {
    			this.table.modules.edit.maskInput(input, editorParams);
    		}

    		return input;
    	},

    	//input element with type of number
    	number: function number(cell, onRendered, success, cancel, editorParams) {

    		var cellValue = cell.getValue(),
    		    vertNav = editorParams.verticalNavigation || "editor",
    		    input = document.createElement("input");

    		input.setAttribute("type", "number");

    		if (typeof editorParams.max != "undefined") {
    			input.setAttribute("max", editorParams.max);
    		}

    		if (typeof editorParams.min != "undefined") {
    			input.setAttribute("min", editorParams.min);
    		}

    		if (typeof editorParams.step != "undefined") {
    			input.setAttribute("step", editorParams.step);
    		}

    		//create and style input
    		input.style.padding = "4px";
    		input.style.width = "100%";
    		input.style.boxSizing = "border-box";

    		if (editorParams.elementAttributes && _typeof(editorParams.elementAttributes) == "object") {
    			for (var key in editorParams.elementAttributes) {
    				if (key.charAt(0) == "+") {
    					key = key.slice(1);
    					input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
    				} else {
    					input.setAttribute(key, editorParams.elementAttributes[key]);
    				}
    			}
    		}

    		input.value = cellValue;

    		var blurFunc = function blurFunc(e) {
    			onChange();
    		};

    		onRendered(function () {
    			//submit new value on blur
    			input.removeEventListener("blur", blurFunc);

    			input.focus({ preventScroll: true });
    			input.style.height = "100%";

    			//submit new value on blur
    			input.addEventListener("blur", blurFunc);
    		});

    		function onChange() {
    			var value = input.value;

    			if (!isNaN(value) && value !== "") {
    				value = Number(value);
    			}

    			if (value !== cellValue) {
    				if (success(value)) {
    					cellValue = value; //persist value if successfully validated incase editor is used as header filter
    				}
    			} else {
    				cancel();
    			}
    		}

    		//submit new value on enter
    		input.addEventListener("keydown", function (e) {
    			switch (e.keyCode) {
    				case 13:
    					// case 9:
    					onChange();
    					break;

    				case 27:
    					cancel();
    					break;

    				case 38: //up arrow
    				case 40:
    					//down arrow
    					if (vertNav == "editor") {
    						e.stopImmediatePropagation();
    						e.stopPropagation();
    					}
    					break;

    				case 35:
    				case 36:
    					e.stopPropagation();
    					break;
    			}
    		});

    		if (editorParams.mask) {
    			this.table.modules.edit.maskInput(input, editorParams);
    		}

    		return input;
    	},

    	//input element with type of number
    	range: function range(cell, onRendered, success, cancel, editorParams) {

    		var cellValue = cell.getValue(),
    		    input = document.createElement("input");

    		input.setAttribute("type", "range");

    		if (typeof editorParams.max != "undefined") {
    			input.setAttribute("max", editorParams.max);
    		}

    		if (typeof editorParams.min != "undefined") {
    			input.setAttribute("min", editorParams.min);
    		}

    		if (typeof editorParams.step != "undefined") {
    			input.setAttribute("step", editorParams.step);
    		}

    		//create and style input
    		input.style.padding = "4px";
    		input.style.width = "100%";
    		input.style.boxSizing = "border-box";

    		if (editorParams.elementAttributes && _typeof(editorParams.elementAttributes) == "object") {
    			for (var key in editorParams.elementAttributes) {
    				if (key.charAt(0) == "+") {
    					key = key.slice(1);
    					input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
    				} else {
    					input.setAttribute(key, editorParams.elementAttributes[key]);
    				}
    			}
    		}

    		input.value = cellValue;

    		onRendered(function () {
    			input.focus({ preventScroll: true });
    			input.style.height = "100%";
    		});

    		function onChange() {
    			var value = input.value;

    			if (!isNaN(value) && value !== "") {
    				value = Number(value);
    			}

    			if (value != cellValue) {
    				if (success(value)) {
    					cellValue = value; //persist value if successfully validated incase editor is used as header filter
    				}
    			} else {
    				cancel();
    			}
    		}

    		//submit new value on blur
    		input.addEventListener("blur", function (e) {
    			onChange();
    		});

    		//submit new value on enter
    		input.addEventListener("keydown", function (e) {
    			switch (e.keyCode) {
    				case 13:
    					// case 9:
    					onChange();
    					break;

    				case 27:
    					cancel();
    					break;
    			}
    		});

    		return input;
    	},

    	//select
    	select: function select(cell, onRendered, success, cancel, editorParams) {
    		var _this53 = this;

    		var self = this,
    		    cellEl = cell.getElement(),
    		    initialValue = cell.getValue(),
    		    vertNav = editorParams.verticalNavigation || "editor",
    		    initialDisplayValue = typeof initialValue !== "undefined" || initialValue === null ? Array.isArray(initialValue) ? initialValue : [initialValue] : typeof editorParams.defaultValue !== "undefined" ? editorParams.defaultValue : [],
    		    input = document.createElement("input"),
    		    listEl = document.createElement("div"),
    		    multiselect = editorParams.multiselect,
    		    dataItems = [],
    		    currentItem = {},
    		    displayItems = [],
    		    currentItems = [],
    		    blurable = true,
    		    blockListShow = false,
    		    searchWord = "",
    		    searchWordTimeout = null;

    		if (Array.isArray(editorParams) || !Array.isArray(editorParams) && (typeof editorParams === 'undefined' ? 'undefined' : _typeof(editorParams)) === "object" && !editorParams.values) {
    			console.warn("DEPRECATION WARNING - values for the select editor must now be passed into the values property of the editorParams object, not as the editorParams object");
    			editorParams = { values: editorParams };
    		}

    		function getUniqueColumnValues(field) {
    			var output = {},
    			    data = self.table.getData(),
    			    column;

    			if (field) {
    				column = self.table.columnManager.getColumnByField(field);
    			} else {
    				column = cell.getColumn()._getSelf();
    			}

    			if (column) {
    				data.forEach(function (row) {
    					var val = column.getFieldValue(row);

    					if (val !== null && typeof val !== "undefined" && val !== "") {
    						output[val] = true;
    					}
    				});
    			} else {
    				console.warn("unable to find matching column to create select lookup list:", field);
    			}

    			return Object.keys(output);
    		}

    		function parseItems(inputValues, curentValues) {
    			var dataList = [];
    			var displayList = [];

    			function processComplexListItem(item) {
    				var item = {
    					label: item.label,
    					value: item.value,
    					itemParams: item.itemParams,
    					elementAttributes: item.elementAttributes,
    					element: false
    				};

    				// if(item.value === curentValue || (!isNaN(parseFloat(item.value)) && !isNaN(parseFloat(item.value)) && parseFloat(item.value) === parseFloat(curentValue))){
    				// 	setCurrentItem(item);
    				// }

    				if (curentValues.indexOf(item.value) > -1) {
    					setItem(item);
    				}

    				dataList.push(item);
    				displayList.push(item);

    				return item;
    			}

    			if (typeof inputValues == "function") {
    				inputValues = inputValues(cell);
    			}

    			if (Array.isArray(inputValues)) {
    				inputValues.forEach(function (value) {
    					var item;

    					if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === "object") {

    						if (value.options) {
    							item = {
    								label: value.label,
    								group: true,
    								itemParams: value.itemParams,
    								elementAttributes: value.elementAttributes,
    								element: false
    							};

    							displayList.push(item);

    							value.options.forEach(function (item) {
    								processComplexListItem(item);
    							});
    						} else {
    							processComplexListItem(value);
    						}
    					} else {

    						item = {
    							label: value,
    							value: value,
    							element: false
    						};

    						// if(item.value === curentValue || (!isNaN(parseFloat(item.value)) && !isNaN(parseFloat(item.value)) && parseFloat(item.value) === parseFloat(curentValue))){
    						// 	setCurrentItem(item);
    						// }

    						if (curentValues.indexOf(item.value) > -1) {
    							setItem(item);
    						}

    						dataList.push(item);
    						displayList.push(item);
    					}
    				});
    			} else {
    				for (var key in inputValues) {
    					var item = {
    						label: inputValues[key],
    						value: key,
    						element: false
    					};

    					// if(item.value === curentValue || (!isNaN(parseFloat(item.value)) && !isNaN(parseFloat(item.value)) && parseFloat(item.value) === parseFloat(curentValue))){
    					// 	setCurrentItem(item);
    					// }

    					if (curentValues.indexOf(item.value) > -1) {
    						setItem(item);
    					}

    					dataList.push(item);
    					displayList.push(item);
    				}
    			}

    			if (editorParams.sortValuesList) {
    				dataList.sort(function (a, b) {
    					return a.label < b.label ? -1 : a.label > b.label ? 1 : 0;
    				});

    				displayList.sort(function (a, b) {
    					return a.label < b.label ? -1 : a.label > b.label ? 1 : 0;
    				});

    				if (editorParams.sortValuesList !== "asc") {
    					dataList.reverse();
    					displayList.reverse();
    				}
    			}

    			dataItems = dataList;
    			displayItems = displayList;

    			fillList();
    		}

    		function fillList() {
    			while (listEl.firstChild) {
    				listEl.removeChild(listEl.firstChild);
    			}displayItems.forEach(function (item) {

    				var el = item.element;

    				if (!el) {
    					el = document.createElement("div");
    					item.label = editorParams.listItemFormatter ? editorParams.listItemFormatter(item.value, item.label, cell, el, item.itemParams) : item.label;
    					if (item.group) {
    						el.classList.add("tabulator-edit-select-list-group");
    						el.tabIndex = 0;
    						el.innerHTML = item.label === "" ? "&nbsp;" : item.label;
    					} else {
    						el.classList.add("tabulator-edit-select-list-item");
    						el.tabIndex = 0;
    						el.innerHTML = item.label === "" ? "&nbsp;" : item.label;

    						el.addEventListener("click", function () {
    							blockListShow = true;

    							setTimeout(function () {
    								blockListShow = false;
    							}, 10);

    							// setCurrentItem(item);
    							// chooseItem();
    							if (multiselect) {
    								toggleItem(item);
    								input.focus();
    							} else {
    								chooseItem(item);
    							}
    						});

    						// if(item === currentItem){
    						// 	el.classList.add("active");
    						// }

    						if (currentItems.indexOf(item) > -1) {
    							el.classList.add("active");
    						}
    					}

    					if (item.elementAttributes && _typeof(item.elementAttributes) == "object") {
    						for (var key in item.elementAttributes) {
    							if (key.charAt(0) == "+") {
    								key = key.slice(1);
    								el.setAttribute(key, input.getAttribute(key) + item.elementAttributes["+" + key]);
    							} else {
    								el.setAttribute(key, item.elementAttributes[key]);
    							}
    						}
    					}
    					el.addEventListener("mousedown", function () {
    						blurable = false;

    						setTimeout(function () {
    							blurable = true;
    						}, 10);
    					});

    					item.element = el;
    				}

    				listEl.appendChild(el);
    			});
    		}

    		function setCurrentItem(item, active) {

    			if (!multiselect && currentItem && currentItem.element) {
    				currentItem.element.classList.remove("active");
    			}

    			if (currentItem && currentItem.element) {
    				currentItem.element.classList.remove("focused");
    			}

    			currentItem = item;

    			if (item.element) {
    				item.element.classList.add("focused");
    				if (active) {
    					item.element.classList.add("active");
    				}
    			}

    			if (item && item.element && item.element.scrollIntoView) {
    				item.element.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
    			}
    		}

    		// function chooseItem(){
    		// 	hideList();

    		// 	if(initialValue !== currentItem.value){
    		// 		initialValue = currentItem.value;
    		// 		success(currentItem.value);
    		// 	}else{
    		// 		cancel();
    		// 	}
    		// }

    		function setItem(item) {
    			var index = currentItems.indexOf(item);

    			if (index == -1) {
    				currentItems.push(item);
    				setCurrentItem(item, true);
    			}

    			fillInput();
    		}

    		function unsetItem(index) {
    			var item = currentItems[index];

    			if (index > -1) {
    				currentItems.splice(index, 1);
    				if (item.element) {
    					item.element.classList.remove("active");
    				}
    			}
    		}

    		function toggleItem(item) {
    			if (!item) {
    				item = currentItem;
    			}

    			var index = currentItems.indexOf(item);

    			if (index > -1) {
    				unsetItem(index);
    			} else {
    				if (multiselect !== true && currentItems.length >= multiselect) {
    					unsetItem(0);
    				}

    				setItem(item);
    			}

    			fillInput();
    		}

    		function chooseItem(item) {
    			hideList();

    			if (!item) {
    				item = currentItem;
    			}

    			if (item) {
    				input.value = item.label;
    				success(item.value);
    			}

    			initialDisplayValue = [item.value];
    		}

    		function chooseItems(silent) {
    			if (!silent) {
    				hideList();
    			}

    			var output = [];

    			currentItems.forEach(function (item) {
    				output.push(item.value);
    			});

    			initialDisplayValue = output;

    			success(output);
    		}

    		function fillInput() {
    			var output = [];

    			currentItems.forEach(function (item) {
    				output.push(item.label);
    			});

    			input.value = output.join(", ");

    			if (self.currentCell === false) {
    				chooseItems(true);
    			}
    		}

    		function unsetItems() {

    			var len = currentItems.length;

    			for (var _i9 = 0; _i9 < len; _i9++) {
    				unsetItem(0);
    			}
    		}

    		function cancelItem() {
    			hideList();
    			cancel();
    		}

    		function showList() {
    			currentItems = [];

    			if (!listEl.parentNode) {
    				if (editorParams.values === true) {
    					parseItems(getUniqueColumnValues(), initialDisplayValue);
    				} else if (typeof editorParams.values === "string") {
    					parseItems(getUniqueColumnValues(editorParams.values), initialDisplayValue);
    				} else {
    					parseItems(editorParams.values || [], initialDisplayValue);
    				}

    				var offset = Tabulator.prototype.helpers.elOffset(cellEl);

    				listEl.style.minWidth = cellEl.offsetWidth + "px";

    				listEl.style.top = offset.top + cellEl.offsetHeight + "px";
    				listEl.style.left = offset.left + "px";

    				listEl.addEventListener("mousedown", function (e) {
    					blurable = false;

    					setTimeout(function () {
    						blurable = true;
    					}, 10);
    				});

    				document.body.appendChild(listEl);
    			}
    		}

    		function hideList() {
    			if (listEl.parentNode) {
    				listEl.parentNode.removeChild(listEl);
    			}

    			removeScrollListener();
    		}

    		function removeScrollListener() {
    			self.table.rowManager.element.removeEventListener("scroll", cancelItem);
    		}

    		function scrollTovalue(char) {

    			clearTimeout(searchWordTimeout);

    			var character = String.fromCharCode(event.keyCode).toLowerCase();
    			searchWord += character.toLowerCase();

    			var match = dataItems.find(function (item) {
    				return typeof item.label !== "undefined" && item.label.toLowerCase().startsWith(searchWord);
    			});

    			if (match) {
    				setCurrentItem(match, !multiselect);
    			}

    			searchWordTimeout = setTimeout(function () {
    				searchWord = "";
    			}, 800);
    		}

    		//style input
    		input.setAttribute("type", "text");

    		input.style.padding = "4px";
    		input.style.width = "100%";
    		input.style.boxSizing = "border-box";
    		input.style.cursor = "default";
    		input.readOnly = this.currentCell != false;

    		if (editorParams.elementAttributes && _typeof(editorParams.elementAttributes) == "object") {
    			for (var key in editorParams.elementAttributes) {
    				if (key.charAt(0) == "+") {
    					key = key.slice(1);
    					input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
    				} else {
    					input.setAttribute(key, editorParams.elementAttributes[key]);
    				}
    			}
    		}

    		input.value = typeof initialValue !== "undefined" || initialValue === null ? initialValue : "";

    		// if(editorParams.values === true){
    		// 	parseItems(getUniqueColumnValues(), initialValue);
    		// }else if(typeof editorParams.values === "string"){
    		// 	parseItems(getUniqueColumnValues(editorParams.values), initialValue);
    		// }else{
    		// 	parseItems(editorParams.values || [], initialValue);
    		// }

    		input.addEventListener("search", function (e) {
    			if (!input.value) {
    				unsetItems();
    				chooseItems();
    			}
    		});

    		//allow key based navigation
    		input.addEventListener("keydown", function (e) {
    			var index;

    			switch (e.keyCode) {
    				case 38:
    					//up arrow
    					index = dataItems.indexOf(currentItem);

    					if (vertNav == "editor" || vertNav == "hybrid" && index) {
    						e.stopImmediatePropagation();
    						e.stopPropagation();
    						e.preventDefault();

    						if (index > 0) {
    							setCurrentItem(dataItems[index - 1], !multiselect);
    						}
    					}
    					break;

    				case 40:
    					//down arrow
    					index = dataItems.indexOf(currentItem);

    					if (vertNav == "editor" || vertNav == "hybrid" && index < dataItems.length - 1) {
    						e.stopImmediatePropagation();
    						e.stopPropagation();
    						e.preventDefault();

    						if (index < dataItems.length - 1) {
    							if (index == -1) {
    								setCurrentItem(dataItems[0], !multiselect);
    							} else {
    								setCurrentItem(dataItems[index + 1], !multiselect);
    							}
    						}
    					}
    					break;

    				case 37: //left arrow
    				case 39:
    					//right arrow
    					e.stopImmediatePropagation();
    					e.stopPropagation();
    					e.preventDefault();
    					break;

    				case 13:
    					//enter
    					// chooseItem();

    					if (multiselect) {
    						toggleItem();
    					} else {
    						chooseItem();
    					}

    					break;

    				case 27:
    					//escape
    					cancelItem();
    					break;

    				case 9:
    					//tab
    					break;

    				default:
    					if (self.currentCell === false) {
    						e.preventDefault();
    					}

    					if (e.keyCode >= 38 && e.keyCode <= 90) {
    						scrollTovalue(e.keyCode);
    					}
    			}
    		});

    		input.addEventListener("blur", function (e) {
    			if (blurable) {
    				if (multiselect) {
    					chooseItems();
    				} else {
    					cancelItem();
    				}
    			}
    		});

    		input.addEventListener("focus", function (e) {
    			if (!blockListShow) {
    				showList();
    			}
    		});

    		//style list element
    		listEl = document.createElement("div");
    		listEl.classList.add("tabulator-edit-select-list");

    		onRendered(function () {
    			input.style.height = "100%";
    			input.focus({ preventScroll: true });
    		});

    		setTimeout(function () {
    			_this53.table.rowManager.element.addEventListener("scroll", cancelItem);
    		}, 10);

    		return input;
    	},

    	//autocomplete
    	autocomplete: function autocomplete(cell, onRendered, success, cancel, editorParams) {
    		var _this54 = this;

    		var self = this,
    		    cellEl = cell.getElement(),
    		    initialValue = cell.getValue(),
    		    vertNav = editorParams.verticalNavigation || "editor",
    		    initialDisplayValue = typeof initialValue !== "undefined" || initialValue === null ? initialValue : typeof editorParams.defaultValue !== "undefined" ? editorParams.defaultValue : "",
    		    input = document.createElement("input"),
    		    listEl = document.createElement("div"),
    		    displayItems = [],
    		    currentItem = false,
    		    blurable = true,
    		    uniqueColumnValues = false;

    		//style input
    		input.setAttribute("type", "search");

    		input.style.padding = "4px";
    		input.style.width = "100%";
    		input.style.boxSizing = "border-box";

    		if (editorParams.elementAttributes && _typeof(editorParams.elementAttributes) == "object") {
    			for (var key in editorParams.elementAttributes) {
    				if (key.charAt(0) == "+") {
    					key = key.slice(1);
    					input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
    				} else {
    					input.setAttribute(key, editorParams.elementAttributes[key]);
    				}
    			}
    		}

    		//style list element
    		listEl.classList.add("tabulator-edit-select-list");

    		listEl.addEventListener("mousedown", function (e) {
    			blurable = false;

    			setTimeout(function () {
    				blurable = true;
    			}, 10);
    		});

    		function genUniqueColumnValues() {
    			if (editorParams.values === true) {
    				uniqueColumnValues = getUniqueColumnValues();
    			} else if (typeof editorParams.values === "string") {
    				uniqueColumnValues = getUniqueColumnValues(editorParams.values);
    			}
    		}

    		function getUniqueColumnValues(field) {
    			var output = {},
    			    data = self.table.getData(),
    			    column;

    			if (field) {
    				column = self.table.columnManager.getColumnByField(field);
    			} else {
    				column = cell.getColumn()._getSelf();
    			}

    			if (column) {
    				data.forEach(function (row) {
    					var val = column.getFieldValue(row);

    					if (val !== null && typeof val !== "undefined" && val !== "") {
    						output[val] = true;
    					}
    				});

    				if (editorParams.sortValuesList) {
    					if (editorParams.sortValuesList == "asc") {
    						output = Object.keys(output).sort();
    					} else {
    						output = Object.keys(output).sort().reverse();
    					}
    				} else {
    					output = Object.keys(output);
    				}
    			} else {
    				console.warn("unable to find matching column to create autocomplete lookup list:", field);
    			}

    			return output;
    		}

    		function filterList(term, intialLoad) {
    			var matches = [],
    			    values,
    			    items;

    			//lookup base values list
    			if (uniqueColumnValues) {
    				values = uniqueColumnValues;
    			} else {
    				values = editorParams.values || [];
    			}

    			if (editorParams.searchFunc) {
    				matches = editorParams.searchFunc(term, values);

    				if (matches instanceof Promise) {

    					addNotice(typeof editorParams.searchingPlaceholder !== "undefined" ? editorParams.searchingPlaceholder : "Searching...");

    					matches.then(function (result) {
    						fillListIfNotEmpty(parseItems(result), intialLoad);
    					}).catch(function (err) {
    						console.err("error in autocomplete search promise:", err);
    					});
    				} else {
    					fillListIfNotEmpty(parseItems(matches), intialLoad);
    				}
    			} else {
    				items = parseItems(values);

    				if (term === "") {
    					if (editorParams.showListOnEmpty) {
    						matches = items;
    					}
    				} else {
    					items.forEach(function (item) {
    						if (item.value !== null || typeof item.value !== "undefined") {
    							if (String(item.value).toLowerCase().indexOf(String(term).toLowerCase()) > -1 || String(item.title).toLowerCase().indexOf(String(term).toLowerCase()) > -1) {
    								matches.push(item);
    							}
    						}
    					});
    				}

    				fillListIfNotEmpty(matches, intialLoad);
    			}
    		}

    		function addNotice(notice) {
    			var searchEl = document.createElement("div");

    			clearList();

    			if (notice !== false) {
    				searchEl.classList.add("tabulator-edit-select-list-notice");
    				searchEl.tabIndex = 0;

    				if (notice instanceof Node) {
    					searchEl.appendChild(notice);
    				} else {
    					searchEl.innerHTML = notice;
    				}

    				listEl.appendChild(searchEl);
    			}
    		}

    		function parseItems(inputValues) {
    			var itemList = [];

    			if (Array.isArray(inputValues)) {
    				inputValues.forEach(function (value) {

    					var item = {};

    					if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === "object") {
    						item.title = editorParams.listItemFormatter ? editorParams.listItemFormatter(value.value, value.label) : value.label;
    						item.value = value.value;
    					} else {
    						item.title = editorParams.listItemFormatter ? editorParams.listItemFormatter(value, value) : value;
    						item.value = value;
    					}

    					itemList.push(item);
    				});
    			} else {
    				for (var key in inputValues) {
    					var item = {
    						title: editorParams.listItemFormatter ? editorParams.listItemFormatter(key, inputValues[key]) : inputValues[key],
    						value: key
    					};

    					itemList.push(item);
    				}
    			}

    			return itemList;
    		}

    		function clearList() {
    			while (listEl.firstChild) {
    				listEl.removeChild(listEl.firstChild);
    			}
    		}

    		function fillListIfNotEmpty(items, intialLoad) {
    			if (items.length) {
    				fillList(items, intialLoad);
    			} else {
    				if (editorParams.emptyPlaceholder) {
    					addNotice(editorParams.emptyPlaceholder);
    				}
    			}
    		}

    		function fillList(items, intialLoad) {
    			var current = false;

    			clearList();

    			displayItems = items;

    			displayItems.forEach(function (item) {
    				var el = item.element;

    				if (!el) {
    					el = document.createElement("div");
    					el.classList.add("tabulator-edit-select-list-item");
    					el.tabIndex = 0;
    					el.innerHTML = item.title;

    					el.addEventListener("click", function (e) {
    						setCurrentItem(item);
    						chooseItem();
    					});

    					el.addEventListener("mousedown", function (e) {
    						blurable = false;

    						setTimeout(function () {
    							blurable = true;
    						}, 10);
    					});

    					item.element = el;

    					if (intialLoad && item.value == initialValue) {
    						input.value = item.title;
    						item.element.classList.add("active");
    						current = true;
    					}

    					if (item === currentItem) {
    						item.element.classList.add("active");
    						current = true;
    					}
    				}

    				listEl.appendChild(el);
    			});

    			if (!current) {
    				setCurrentItem(false);
    			}
    		}

    		function chooseItem() {
    			hideList();

    			if (currentItem) {
    				if (initialValue !== currentItem.value) {
    					initialValue = currentItem.value;
    					input.value = currentItem.title;
    					success(currentItem.value);
    				} else {
    					cancel();
    				}
    			} else {
    				if (editorParams.freetext) {
    					initialValue = input.value;
    					success(input.value);
    				} else {
    					if (editorParams.allowEmpty && input.value === "") {
    						initialValue = input.value;
    						success(input.value);
    					} else {
    						cancel();
    					}
    				}
    			}
    		}

    		function showList() {
    			if (!listEl.parentNode) {

    				console.log("show", initialDisplayValue);
    				while (listEl.firstChild) {
    					listEl.removeChild(listEl.firstChild);
    				}var offset = Tabulator.prototype.helpers.elOffset(cellEl);

    				listEl.style.minWidth = cellEl.offsetWidth + "px";

    				listEl.style.top = offset.top + cellEl.offsetHeight + "px";
    				listEl.style.left = offset.left + "px";
    				document.body.appendChild(listEl);
    			}
    		}

    		function setCurrentItem(item, showInputValue) {
    			if (currentItem && currentItem.element) {
    				currentItem.element.classList.remove("active");
    			}

    			currentItem = item;

    			if (item && item.element) {
    				item.element.classList.add("active");
    			}

    			if (item && item.element && item.element.scrollIntoView) {
    				item.element.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
    			}
    		}

    		function hideList() {
    			if (listEl.parentNode) {
    				listEl.parentNode.removeChild(listEl);
    			}

    			removeScrollListener();
    		}

    		function cancelItem() {
    			hideList();
    			cancel();
    		}

    		function removeScrollListener() {
    			self.table.rowManager.element.removeEventListener("scroll", cancelItem);
    		}

    		//allow key based navigation
    		input.addEventListener("keydown", function (e) {
    			var index;

    			switch (e.keyCode) {
    				case 38:
    					//up arrow
    					index = displayItems.indexOf(currentItem);

    					if (vertNav == "editor" || vertNav == "hybrid" && index) {
    						e.stopImmediatePropagation();
    						e.stopPropagation();
    						e.preventDefault();

    						if (index > 0) {
    							setCurrentItem(displayItems[index - 1]);
    						} else {
    							setCurrentItem(false);
    						}
    					}
    					break;

    				case 40:
    					//down arrow

    					index = displayItems.indexOf(currentItem);

    					if (vertNav == "editor" || vertNav == "hybrid" && index < displayItems.length - 1) {

    						e.stopImmediatePropagation();
    						e.stopPropagation();
    						e.preventDefault();

    						if (index < displayItems.length - 1) {
    							if (index == -1) {
    								setCurrentItem(displayItems[0]);
    							} else {
    								setCurrentItem(displayItems[index + 1]);
    							}
    						}
    					}
    					break;

    				case 37: //left arrow
    				case 39:
    					//right arrow
    					e.stopImmediatePropagation();
    					e.stopPropagation();
    					// e.preventDefault();
    					break;

    				case 13:
    					//enter
    					chooseItem();
    					break;

    				case 27:
    					//escape
    					cancelItem();
    					break;

    				case 36: //home
    				case 35:
    					//end
    					//prevent table navigation while using input element
    					e.stopImmediatePropagation();
    					break;
    			}
    		});

    		input.addEventListener("keyup", function (e) {

    			switch (e.keyCode) {
    				case 38: //up arrow
    				case 37: //left arrow
    				case 39: //up arrow
    				case 40: //right arrow
    				case 13: //enter
    				case 27:
    					//escape
    					break;

    				default:
    					filterList(input.value);
    			}
    		});

    		input.addEventListener("search", function (e) {
    			filterList(input.value);
    		});

    		input.addEventListener("blur", function (e) {
    			if (blurable) {
    				chooseItem();
    			}
    		});

    		input.addEventListener("focus", function (e) {
    			var value = initialDisplayValue;
    			genUniqueColumnValues();
    			showList();
    			input.value = value;
    			filterList(value, true);
    		});

    		onRendered(function () {
    			input.style.height = "100%";
    			input.focus({ preventScroll: true });
    		});

    		if (editorParams.mask) {
    			this.table.modules.edit.maskInput(input, editorParams);
    		}

    		setTimeout(function () {
    			_this54.table.rowManager.element.addEventListener("scroll", cancelItem);
    		}, 10);

    		genUniqueColumnValues();
    		input.value = initialDisplayValue;
    		filterList(initialDisplayValue, true);

    		return input;
    	},

    	//star rating
    	star: function star(cell, onRendered, success, cancel, editorParams) {
    		var self = this,
    		    element = cell.getElement(),
    		    value = cell.getValue(),
    		    maxStars = element.getElementsByTagName("svg").length || 5,
    		    size = element.getElementsByTagName("svg")[0] ? element.getElementsByTagName("svg")[0].getAttribute("width") : 14,
    		    stars = [],
    		    starsHolder = document.createElement("div"),
    		    star = document.createElementNS('http://www.w3.org/2000/svg', "svg");

    		//change star type
    		function starChange(val) {
    			stars.forEach(function (star, i) {
    				if (i < val) {
    					if (self.table.browser == "ie") {
    						star.setAttribute("class", "tabulator-star-active");
    					} else {
    						star.classList.replace("tabulator-star-inactive", "tabulator-star-active");
    					}

    					star.innerHTML = '<polygon fill="#488CE9" stroke="#014AAE" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';
    				} else {
    					if (self.table.browser == "ie") {
    						star.setAttribute("class", "tabulator-star-inactive");
    					} else {
    						star.classList.replace("tabulator-star-active", "tabulator-star-inactive");
    					}

    					star.innerHTML = '<polygon fill="#010155" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';
    				}
    			});
    		}

    		//build stars
    		function buildStar(i) {

    			var starHolder = document.createElement("span");
    			var nextStar = star.cloneNode(true);

    			stars.push(nextStar);

    			starHolder.addEventListener("mouseenter", function (e) {
    				e.stopPropagation();
    				e.stopImmediatePropagation();
    				starChange(i);
    			});

    			starHolder.addEventListener("mousemove", function (e) {
    				e.stopPropagation();
    				e.stopImmediatePropagation();
    			});

    			starHolder.addEventListener("click", function (e) {
    				e.stopPropagation();
    				e.stopImmediatePropagation();
    				success(i);
    				element.blur();
    			});

    			starHolder.appendChild(nextStar);
    			starsHolder.appendChild(starHolder);
    		}

    		//handle keyboard navigation value change
    		function changeValue(val) {
    			value = val;
    			starChange(val);
    		}

    		//style cell
    		element.style.whiteSpace = "nowrap";
    		element.style.overflow = "hidden";
    		element.style.textOverflow = "ellipsis";

    		//style holding element
    		starsHolder.style.verticalAlign = "middle";
    		starsHolder.style.display = "inline-block";
    		starsHolder.style.padding = "4px";

    		//style star
    		star.setAttribute("width", size);
    		star.setAttribute("height", size);
    		star.setAttribute("viewBox", "0 0 512 512");
    		star.setAttribute("xml:space", "preserve");
    		star.style.padding = "0 1px";

    		if (editorParams.elementAttributes && _typeof(editorParams.elementAttributes) == "object") {
    			for (var key in editorParams.elementAttributes) {
    				if (key.charAt(0) == "+") {
    					key = key.slice(1);
    					starsHolder.setAttribute(key, starsHolder.getAttribute(key) + editorParams.elementAttributes["+" + key]);
    				} else {
    					starsHolder.setAttribute(key, editorParams.elementAttributes[key]);
    				}
    			}
    		}

    		//create correct number of stars
    		for (var i = 1; i <= maxStars; i++) {
    			buildStar(i);
    		}

    		//ensure value does not exceed number of stars
    		value = Math.min(parseInt(value), maxStars);

    		// set initial styling of stars
    		starChange(value);

    		starsHolder.addEventListener("mousemove", function (e) {
    			starChange(0);
    		});

    		starsHolder.addEventListener("click", function (e) {
    			success(0);
    		});

    		element.addEventListener("blur", function (e) {
    			cancel();
    		});

    		//allow key based navigation
    		element.addEventListener("keydown", function (e) {
    			switch (e.keyCode) {
    				case 39:
    					//right arrow
    					changeValue(value + 1);
    					break;

    				case 37:
    					//left arrow
    					changeValue(value - 1);
    					break;

    				case 13:
    					//enter
    					success(value);
    					break;

    				case 27:
    					//escape
    					cancel();
    					break;
    			}
    		});

    		return starsHolder;
    	},

    	//draggable progress bar
    	progress: function progress(cell, onRendered, success, cancel, editorParams) {
    		var element = cell.getElement(),
    		    max = typeof editorParams.max === "undefined" ? element.getElementsByTagName("div")[0].getAttribute("max") || 100 : editorParams.max,
    		    min = typeof editorParams.min === "undefined" ? element.getElementsByTagName("div")[0].getAttribute("min") || 0 : editorParams.min,
    		    percent = (max - min) / 100,
    		    value = cell.getValue() || 0,
    		    handle = document.createElement("div"),
    		    bar = document.createElement("div"),
    		    mouseDrag,
    		    mouseDragWidth;

    		//set new value
    		function updateValue() {
    			var style = window.getComputedStyle(element, null);

    			var calcVal = percent * Math.round(bar.offsetWidth / ((element.clientWidth - parseInt(style.getPropertyValue("padding-left")) - parseInt(style.getPropertyValue("padding-right"))) / 100)) + min;
    			success(calcVal);
    			element.setAttribute("aria-valuenow", calcVal);
    			element.setAttribute("aria-label", value);
    		}

    		//style handle
    		handle.style.position = "absolute";
    		handle.style.right = "0";
    		handle.style.top = "0";
    		handle.style.bottom = "0";
    		handle.style.width = "5px";
    		handle.classList.add("tabulator-progress-handle");

    		//style bar
    		bar.style.display = "inline-block";
    		bar.style.position = "relative";
    		// bar.style.top = "8px";
    		// bar.style.bottom = "8px";
    		// bar.style.left = "4px";
    		// bar.style.marginRight = "4px";
    		bar.style.height = "100%";
    		bar.style.backgroundColor = "#488CE9";
    		bar.style.maxWidth = "100%";
    		bar.style.minWidth = "0%";

    		if (editorParams.elementAttributes && _typeof(editorParams.elementAttributes) == "object") {
    			for (var key in editorParams.elementAttributes) {
    				if (key.charAt(0) == "+") {
    					key = key.slice(1);
    					bar.setAttribute(key, bar.getAttribute(key) + editorParams.elementAttributes["+" + key]);
    				} else {
    					bar.setAttribute(key, editorParams.elementAttributes[key]);
    				}
    			}
    		}

    		//style cell
    		element.style.padding = "4px 4px";

    		//make sure value is in range
    		value = Math.min(parseFloat(value), max);
    		value = Math.max(parseFloat(value), min);

    		//workout percentage
    		value = Math.round((value - min) / percent);
    		// bar.style.right = value + "%";
    		bar.style.width = value + "%";

    		element.setAttribute("aria-valuemin", min);
    		element.setAttribute("aria-valuemax", max);

    		bar.appendChild(handle);

    		handle.addEventListener("mousedown", function (e) {
    			mouseDrag = e.screenX;
    			mouseDragWidth = bar.offsetWidth;
    		});

    		handle.addEventListener("mouseover", function () {
    			handle.style.cursor = "ew-resize";
    		});

    		element.addEventListener("mousemove", function (e) {
    			if (mouseDrag) {
    				bar.style.width = mouseDragWidth + e.screenX - mouseDrag + "px";
    			}
    		});

    		element.addEventListener("mouseup", function (e) {
    			if (mouseDrag) {
    				e.stopPropagation();
    				e.stopImmediatePropagation();

    				mouseDrag = false;
    				mouseDragWidth = false;

    				updateValue();
    			}
    		});

    		//allow key based navigation
    		element.addEventListener("keydown", function (e) {
    			switch (e.keyCode) {
    				case 39:
    					//right arrow
    					e.preventDefault();
    					bar.style.width = bar.clientWidth + element.clientWidth / 100 + "px";
    					break;

    				case 37:
    					//left arrow
    					e.preventDefault();
    					bar.style.width = bar.clientWidth - element.clientWidth / 100 + "px";
    					break;

    				case 9: //tab
    				case 13:
    					//enter
    					updateValue();
    					break;

    				case 27:
    					//escape
    					cancel();
    					break;

    			}
    		});

    		element.addEventListener("blur", function () {
    			cancel();
    		});

    		return bar;
    	},

    	//checkbox
    	tickCross: function tickCross(cell, onRendered, success, cancel, editorParams) {
    		var value = cell.getValue(),
    		    input = document.createElement("input"),
    		    tristate = editorParams.tristate,
    		    indetermValue = typeof editorParams.indeterminateValue === "undefined" ? null : editorParams.indeterminateValue,
    		    indetermState = false;

    		input.setAttribute("type", "checkbox");
    		input.style.marginTop = "5px";
    		input.style.boxSizing = "border-box";

    		if (editorParams.elementAttributes && _typeof(editorParams.elementAttributes) == "object") {
    			for (var key in editorParams.elementAttributes) {
    				if (key.charAt(0) == "+") {
    					key = key.slice(1);
    					input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
    				} else {
    					input.setAttribute(key, editorParams.elementAttributes[key]);
    				}
    			}
    		}

    		input.value = value;

    		if (tristate && (typeof value === "undefined" || value === indetermValue || value === "")) {
    			indetermState = true;
    			input.indeterminate = true;
    		}

    		if (this.table.browser != "firefox") {
    			//prevent blur issue on mac firefox
    			onRendered(function () {
    				input.focus({ preventScroll: true });
    			});
    		}

    		input.checked = value === true || value === "true" || value === "True" || value === 1;

    		onRendered(function () {
    			input.focus();
    		});

    		function setValue(blur) {
    			if (tristate) {
    				if (!blur) {
    					if (input.checked && !indetermState) {
    						input.checked = false;
    						input.indeterminate = true;
    						indetermState = true;
    						return indetermValue;
    					} else {
    						indetermState = false;
    						return input.checked;
    					}
    				} else {
    					if (indetermState) {
    						return indetermValue;
    					} else {
    						return input.checked;
    					}
    				}
    			} else {
    				return input.checked;
    			}
    		}

    		//submit new value on blur
    		input.addEventListener("change", function (e) {
    			success(setValue());
    		});

    		input.addEventListener("blur", function (e) {
    			success(setValue(true));
    		});

    		//submit new value on enter
    		input.addEventListener("keydown", function (e) {
    			if (e.keyCode == 13) {
    				success(setValue());
    			}
    			if (e.keyCode == 27) {
    				cancel();
    			}
    		});

    		return input;
    	}
    };

    Tabulator.prototype.registerModule("edit", Edit);

    var ExportRow = function ExportRow(type, columns, component, indent) {
    	this.type = type;
    	this.columns = columns;
    	this.component = component || false;
    	this.indent = indent || 0;
    };

    var ExportColumn = function ExportColumn(value, component, width, height, depth) {
    	this.value = value;
    	this.component = component || false;
    	this.width = width;
    	this.height = height;
    	this.depth = depth;
    };

    var Export = function Export(table) {
    	this.table = table; //hold Tabulator object
    	this.config = {};
    	this.cloneTableStyle = true;
    	this.colVisProp = "";
    };

    Export.prototype.generateExportList = function (config, style, range, colVisProp) {
    	this.cloneTableStyle = style;
    	this.config = config || {};
    	this.colVisProp = colVisProp;

    	var headers = this.config.columnHeaders !== false ? this.headersToExportRows(this.generateColumnGroupHeaders()) : [];
    	var body = this.bodyToExportRows(this.rowLookup(range));

    	return headers.concat(body);
    };

    Export.prototype.genereateTable = function (config, style, range, colVisProp) {
    	var list = this.generateExportList(config, style, range, colVisProp);

    	return this.genereateTableElement(list);
    };

    Export.prototype.rowLookup = function (range) {
    	var _this55 = this;

    	var rows = [];

    	if (typeof range == "function") {
    		range.call(this.table).forEach(function (row) {
    			row = _this55.table.rowManager.findRow(row);

    			if (row) {
    				rows.push(row);
    			}
    		});
    	} else {
    		switch (range) {
    			case true:
    			case "visible":
    				rows = this.table.rowManager.getVisibleRows(true);
    				break;

    			case "all":
    				rows = this.table.rowManager.rows;
    				break;

    			case "selected":
    				rows = this.table.modules.selectRow.selectedRows;
    				break;

    			case "active":
    			default:
    				if (this.table.options.pagination) {
    					rows = this.table.rowManager.getDisplayRows(this.table.rowManager.displayRows.length - 2);
    				} else {
    					rows = this.table.rowManager.getDisplayRows();
    				}
    		}
    	}

    	return Object.assign([], rows);
    };

    Export.prototype.generateColumnGroupHeaders = function () {
    	var _this56 = this;

    	var output = [];

    	var columns = this.config.columnGroups !== false ? this.table.columnManager.columns : this.table.columnManager.columnsByIndex;

    	columns.forEach(function (column) {
    		var colData = _this56.processColumnGroup(column);

    		if (colData) {
    			output.push(colData);
    		}
    	});

    	return output;
    };

    Export.prototype.processColumnGroup = function (column) {
    	var _this57 = this;

    	var subGroups = column.columns,
    	    maxDepth = 0,
    	    title = column.definition["title" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))] || column.definition.title;

    	var groupData = {
    		title: title,
    		column: column,
    		depth: 1
    	};

    	if (subGroups.length) {
    		groupData.subGroups = [];
    		groupData.width = 0;

    		subGroups.forEach(function (subGroup) {
    			var subGroupData = _this57.processColumnGroup(subGroup);

    			if (subGroupData) {
    				groupData.width += subGroupData.width;
    				groupData.subGroups.push(subGroupData);

    				if (subGroupData.depth > maxDepth) {
    					maxDepth = subGroupData.depth;
    				}
    			}
    		});

    		groupData.depth += maxDepth;

    		if (!groupData.width) {
    			return false;
    		}
    	} else {
    		if (this.columnVisCheck(column)) {
    			groupData.width = 1;
    		} else {
    			return false;
    		}
    	}

    	return groupData;
    };

    Export.prototype.columnVisCheck = function (column) {
    	return column.definition[this.colVisProp] !== false && (column.visible || !column.visible && column.definition[this.colVisProp]);
    };

    Export.prototype.headersToExportRows = function (columns) {
    	var headers = [],
    	    headerDepth = 0,
    	    exportRows = [];

    	function parseColumnGroup(column, level) {

    		var depth = headerDepth - level;

    		if (typeof headers[level] === "undefined") {
    			headers[level] = [];
    		}

    		column.height = column.subGroups ? 1 : depth - column.depth + 1;

    		headers[level].push(column);

    		if (column.height > 1) {
    			for (var _i10 = 1; _i10 < column.height; _i10++) {

    				if (typeof headers[level + _i10] === "undefined") {
    					headers[level + _i10] = [];
    				}

    				headers[level + _i10].push(false);
    			}
    		}

    		if (column.width > 1) {
    			for (var _i11 = 1; _i11 < column.width; _i11++) {
    				headers[level].push(false);
    			}
    		}

    		if (column.subGroups) {
    			column.subGroups.forEach(function (subGroup) {
    				parseColumnGroup(subGroup, level + 1);
    			});
    		}
    	}

    	//calculate maximum header debth
    	columns.forEach(function (column) {
    		if (column.depth > headerDepth) {
    			headerDepth = column.depth;
    		}
    	});

    	columns.forEach(function (column) {
    		parseColumnGroup(column, 0);
    	});

    	headers.forEach(function (header) {
    		var columns = [];

    		header.forEach(function (col) {
    			if (col) {
    				columns.push(new ExportColumn(col.title, col.column.getComponent(), col.width, col.height, col.depth));
    			} else {
    				columns.push(null);
    			}
    		});

    		exportRows.push(new ExportRow("header", columns));
    	});

    	return exportRows;
    };

    Export.prototype.bodyToExportRows = function (rows) {
    	var _this58 = this;

    	var columns = [];
    	var exportRows = [];

    	this.table.columnManager.columnsByIndex.forEach(function (column) {
    		if (_this58.columnVisCheck(column)) {
    			columns.push(column.getComponent());
    		}
    	});

    	if (this.config.columnCalcs !== false && this.table.modExists("columnCalcs")) {
    		if (this.table.modules.columnCalcs.topInitialized) {
    			rows.unshift(this.table.modules.columnCalcs.topRow);
    		}

    		if (this.table.modules.columnCalcs.botInitialized) {
    			rows.push(this.table.modules.columnCalcs.botRow);
    		}
    	}

    	rows = rows.filter(function (row) {
    		switch (row.type) {
    			case "group":
    				return _this58.config.rowGroups !== false;

    			case "calc":
    				return _this58.config.columnCalcs !== false;

    			case "row":
    				return !(_this58.table.options.dataTree && _this58.config.dataTree === false && row.modules.dataTree.parent);
    		}

    		return true;
    	});

    	rows.forEach(function (row, i) {
    		var rowData = row.getData(_this58.colVisProp);
    		var exportCols = [];
    		var indent = 0;

    		switch (row.type) {
    			case "group":
    				indent = row.level;
    				exportCols.push(new ExportColumn(row.key, row.getComponent(), columns.length, 1));
    				break;

    			case "calc":
    			case "row":
    				columns.forEach(function (col) {
    					exportCols.push(new ExportColumn(col._column.getFieldValue(rowData), col, 1, 1));
    				});

    				if (_this58.table.options.dataTree && _this58.config.dataTree !== false) {
    					indent = row.modules.dataTree.index;
    				}
    				break;
    		}

    		exportRows.push(new ExportRow(row.type, exportCols, row.getComponent(), indent));
    	});

    	return exportRows;
    };

    Export.prototype.genereateTableElement = function (list) {
    	var _this59 = this;

    	var table = document.createElement("table"),
    	    headerEl = document.createElement("thead"),
    	    bodyEl = document.createElement("tbody"),
    	    styles = this.lookupTableStyles(),
    	    rowFormatter = this.table.options["rowFormatter" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))],
    	    setup = {};

    	setup.rowFormatter = rowFormatter !== null ? rowFormatter : this.table.options.rowFormatter;

    	if (this.table.options.dataTree && this.config.dataTree !== false && this.table.modExists("columnCalcs")) {
    		setup.treeElementField = this.table.modules.dataTree.elementField;
    	}

    	//assign group header formatter
    	setup.groupHeader = this.table.options["groupHeader" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))];

    	if (setup.groupHeader && !Array.isArray(setup.groupHeader)) {
    		setup.groupHeader = [setup.groupHeader];
    	}

    	table.classList.add("tabulator-print-table");

    	this.mapElementStyles(this.table.columnManager.getHeadersElement(), headerEl, ["border-top", "border-left", "border-right", "border-bottom", "background-color", "color", "font-weight", "font-family", "font-size"]);

    	if (list.length > 1000) {
    		console.warn("It may take a long time to render an HTML table with more than 1000 rows");
    	}

    	list.forEach(function (row, i) {
    		switch (row.type) {
    			case "header":
    				headerEl.appendChild(_this59.genereateHeaderElement(row, setup, styles));
    				break;

    			case "group":
    				bodyEl.appendChild(_this59.genereateGroupElement(row, setup, styles));
    				break;

    			case "calc":
    				bodyEl.appendChild(_this59.genereateCalcElement(row, setup, styles));
    				break;

    			case "row":
    				var rowEl = _this59.genereateRowElement(row, setup, styles);
    				_this59.mapElementStyles(i % 2 && styles.evenRow ? styles.evenRow : styles.oddRow, rowEl, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]);
    				bodyEl.appendChild(rowEl);
    				break;
    		}
    	});

    	if (headerEl.innerHTML) {
    		table.appendChild(headerEl);
    	}

    	table.appendChild(bodyEl);

    	this.mapElementStyles(this.table.element, table, ["border-top", "border-left", "border-right", "border-bottom"]);
    	return table;
    };

    Export.prototype.lookupTableStyles = function () {
    	var styles = {};

    	//lookup row styles
    	if (this.cloneTableStyle && window.getComputedStyle) {
    		styles.oddRow = this.table.element.querySelector(".tabulator-row-odd:not(.tabulator-group):not(.tabulator-calcs)");
    		styles.evenRow = this.table.element.querySelector(".tabulator-row-even:not(.tabulator-group):not(.tabulator-calcs)");
    		styles.calcRow = this.table.element.querySelector(".tabulator-row.tabulator-calcs");
    		styles.firstRow = this.table.element.querySelector(".tabulator-row:not(.tabulator-group):not(.tabulator-calcs)");
    		styles.firstGroup = this.table.element.getElementsByClassName("tabulator-group")[0];

    		if (styles.firstRow) {
    			styles.styleCells = styles.firstRow.getElementsByClassName("tabulator-cell");
    			styles.firstCell = styles.styleCells[0];
    			styles.lastCell = styles.styleCells[styles.styleCells.length - 1];
    		}
    	}

    	return styles;
    };

    Export.prototype.genereateHeaderElement = function (row, setup, styles) {
    	var _this60 = this;

    	var rowEl = document.createElement("tr");

    	row.columns.forEach(function (column) {
    		if (column) {
    			var cellEl = document.createElement("th");
    			var classNames = column.component._column.definition.cssClass ? column.component._column.definition.cssClass.split(" ") : [];

    			cellEl.colSpan = column.width;
    			cellEl.rowSpan = column.height;

    			cellEl.innerHTML = column.value;

    			if (_this60.cloneTableStyle) {
    				cellEl.style.boxSizing = "border-box";
    			}

    			classNames.forEach(function (className) {
    				cellEl.classList.add(className);
    			});

    			_this60.mapElementStyles(column.component.getElement(), cellEl, ["text-align", "border-top", "border-left", "border-right", "border-bottom", "background-color", "color", "font-weight", "font-family", "font-size"]);
    			_this60.mapElementStyles(column.component._column.contentElement, cellEl, ["padding-top", "padding-left", "padding-right", "padding-bottom"]);

    			if (column.component._column.visible) {
    				_this60.mapElementStyles(column.component.getElement(), cellEl, ["width"]);
    			} else {
    				if (column.component._column.definition.width) {
    					cellEl.style.width = column.component._column.definition.width + "px";
    				}
    			}

    			if (column.component._column.parent) {
    				_this60.mapElementStyles(column.component._column.parent.groupElement, cellEl, ["border-top"]);
    			}

    			rowEl.appendChild(cellEl);
    		}
    	});

    	return rowEl;
    };

    Export.prototype.genereateGroupElement = function (row, setup, styles) {

    	var rowEl = document.createElement("tr"),
    	    cellEl = document.createElement("td"),
    	    group = row.columns[0];

    	rowEl.classList.add("tabulator-print-table-row");

    	if (setup.groupHeader && setup.groupHeader[row.indent]) {
    		group.value = setup.groupHeader[row.indent](group.value, row.component._group.getRowCount(), row.component._group.getData(), row.component);
    	} else {
    		if (setup.groupHeader === false) {
    			group.value = group.value;
    		} else {
    			group.value = row.component._group.generator(group.value, row.component._group.getRowCount(), row.component._group.getData(), row.component);
    		}
    	}

    	cellEl.colSpan = group.width;
    	cellEl.innerHTML = group.value;

    	rowEl.classList.add("tabulator-print-table-group");
    	rowEl.classList.add("tabulator-group-level-" + row.indent);

    	if (group.component.isVisible()) {
    		rowEl.classList.add("tabulator-group-visible");
    	}

    	this.mapElementStyles(styles.firstGroup, rowEl, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]);
    	this.mapElementStyles(styles.firstGroup, cellEl, ["padding-top", "padding-left", "padding-right", "padding-bottom"]);

    	rowEl.appendChild(cellEl);

    	return rowEl;
    };

    Export.prototype.genereateCalcElement = function (row, setup, styles) {
    	var rowEl = this.genereateRowElement(row, setup, styles);

    	rowEl.classList.add("tabulator-print-table-calcs");
    	this.mapElementStyles(styles.calcRow, rowEl, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]);

    	return rowEl;
    };

    Export.prototype.genereateRowElement = function (row, setup, styles) {
    	var _this61 = this;

    	var rowEl = document.createElement("tr");

    	rowEl.classList.add("tabulator-print-table-row");

    	row.columns.forEach(function (col) {

    		if (col) {
    			var cellEl = document.createElement("td"),
    			    column = col.component._column,
    			    value = col.value;

    			var cellWrapper = {
    				modules: {},
    				getValue: function getValue() {
    					return value;
    				},
    				getField: function getField() {
    					return column.definition.field;
    				},
    				getElement: function getElement() {
    					return cellEl;
    				},
    				getColumn: function getColumn() {
    					return column.getComponent();
    				},
    				getData: function getData() {
    					return row.component.getData();
    				},
    				getRow: function getRow() {
    					return row.component;
    				},
    				getComponent: function getComponent() {
    					return cellWrapper;
    				},
    				column: column
    			};

    			var classNames = column.definition.cssClass ? column.definition.cssClass.split(" ") : [];

    			classNames.forEach(function (className) {
    				cellEl.classList.add(className);
    			});

    			if (_this61.table.modExists("format") && _this61.config.formatCells !== false) {
    				value = _this61.table.modules.format.formatExportValue(cellWrapper, _this61.colVisProp);
    			} else {
    				switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
    					case "object":
    						value = JSON.stringify(value);
    						break;

    					case "undefined":
    					case "null":
    						value = "";
    						break;

    					default:
    						value = value;
    				}
    			}

    			if (value instanceof Node) {
    				cellEl.appendChild(value);
    			} else {
    				cellEl.innerHTML = value;
    			}

    			if (styles.firstCell) {
    				_this61.mapElementStyles(styles.firstCell, cellEl, ["padding-top", "padding-left", "padding-right", "padding-bottom", "border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size"]);

    				if (column.definition.align) {
    					cellEl.style.textAlign = column.definition.align;
    				}
    			}

    			if (_this61.table.options.dataTree && _this61.config.dataTree !== false) {
    				if (setup.treeElementField && setup.treeElementField == column.field || !setup.treeElementField && i == 0) {
    					if (row.component._row.modules.dataTree.controlEl) {
    						cellEl.insertBefore(row.component._row.modules.dataTree.controlEl.cloneNode(true), cellEl.firstChild);
    					}
    					if (row.component._row.modules.dataTree.branchEl) {
    						cellEl.insertBefore(row.component._row.modules.dataTree.branchEl.cloneNode(true), cellEl.firstChild);
    					}
    				}
    			}

    			rowEl.appendChild(cellEl);

    			if (cellWrapper.modules.format && cellWrapper.modules.format.renderedCallback) {
    				cellWrapper.modules.format.renderedCallback();
    			}

    			if (setup.rowFormatter && _this61.config.formatCells !== false) {
    				setup.rowFormatter(row.component);
    			}
    		}
    	});

    	return rowEl;
    };

    Export.prototype.genereateHTMLTable = function (list) {
    	var holder = document.createElement("div");

    	holder.appendChild(this.genereateTableElement(list));

    	return holder.innerHTML;
    };

    Export.prototype.getHtml = function (visible, style, config, colVisProp) {
    	var list = this.generateExportList(config || this.table.options.htmlOutputConfig, style, visible, colVisProp || "htmlOutput");

    	return this.genereateHTMLTable(list);
    };

    Export.prototype.mapElementStyles = function (from, to, props) {
    	if (this.cloneTableStyle && from && to) {

    		var lookup = {
    			"background-color": "backgroundColor",
    			"color": "fontColor",
    			"width": "width",
    			"font-weight": "fontWeight",
    			"font-family": "fontFamily",
    			"font-size": "fontSize",
    			"text-align": "textAlign",
    			"border-top": "borderTop",
    			"border-left": "borderLeft",
    			"border-right": "borderRight",
    			"border-bottom": "borderBottom",
    			"padding-top": "paddingTop",
    			"padding-left": "paddingLeft",
    			"padding-right": "paddingRight",
    			"padding-bottom": "paddingBottom"
    		};

    		if (window.getComputedStyle) {
    			var fromStyle = window.getComputedStyle(from);

    			props.forEach(function (prop) {
    				to.style[lookup[prop]] = fromStyle.getPropertyValue(prop);
    			});
    		}
    	}
    };

    Tabulator.prototype.registerModule("export", Export);

    var Filter = function Filter(table) {

    	this.table = table; //hold Tabulator object

    	this.filterList = []; //hold filter list
    	this.headerFilters = {}; //hold column filters
    	this.headerFilterColumns = []; //hold columns that use header filters

    	this.prevHeaderFilterChangeCheck = "";
    	this.prevHeaderFilterChangeCheck = "{}";

    	this.changed = false; //has filtering changed since last render
    };

    //initialize column header filter
    Filter.prototype.initializeColumn = function (column, value) {
    	var self = this,
    	    field = column.getField();

    	//handle successfull value change
    	function success(value) {
    		var filterType = column.modules.filter.tagType == "input" && column.modules.filter.attrType == "text" || column.modules.filter.tagType == "textarea" ? "partial" : "match",
    		    type = "",
    		    filterChangeCheck = "",
    		    filterFunc;

    		if (typeof column.modules.filter.prevSuccess === "undefined" || column.modules.filter.prevSuccess !== value) {

    			column.modules.filter.prevSuccess = value;

    			if (!column.modules.filter.emptyFunc(value)) {
    				column.modules.filter.value = value;

    				switch (_typeof(column.definition.headerFilterFunc)) {
    					case "string":
    						if (self.filters[column.definition.headerFilterFunc]) {
    							type = column.definition.headerFilterFunc;
    							filterFunc = function filterFunc(data) {
    								var params = column.definition.headerFilterFuncParams || {};
    								var fieldVal = column.getFieldValue(data);

    								params = typeof params === "function" ? params(value, fieldVal, data) : params;

    								return self.filters[column.definition.headerFilterFunc](value, fieldVal, data, params);
    							};
    						} else {
    							console.warn("Header Filter Error - Matching filter function not found: ", column.definition.headerFilterFunc);
    						}
    						break;

    					case "function":
    						filterFunc = function filterFunc(data) {
    							var params = column.definition.headerFilterFuncParams || {};
    							var fieldVal = column.getFieldValue(data);

    							params = typeof params === "function" ? params(value, fieldVal, data) : params;

    							return column.definition.headerFilterFunc(value, fieldVal, data, params);
    						};

    						type = filterFunc;
    						break;
    				}

    				if (!filterFunc) {
    					switch (filterType) {
    						case "partial":
    							filterFunc = function filterFunc(data) {
    								var colVal = column.getFieldValue(data);

    								if (typeof colVal !== 'undefined' && colVal !== null) {
    									return String(colVal).toLowerCase().indexOf(String(value).toLowerCase()) > -1;
    								} else {
    									return false;
    								}
    							};
    							type = "like";
    							break;

    						default:
    							filterFunc = function filterFunc(data) {
    								return column.getFieldValue(data) == value;
    							};
    							type = "=";
    					}
    				}

    				self.headerFilters[field] = { value: value, func: filterFunc, type: type, params: {} };
    			} else {
    				delete self.headerFilters[field];
    			}

    			filterChangeCheck = JSON.stringify(self.headerFilters);

    			if (self.prevHeaderFilterChangeCheck !== filterChangeCheck) {
    				self.prevHeaderFilterChangeCheck = filterChangeCheck;

    				self.changed = true;
    				self.table.rowManager.filterRefresh();
    			}
    		}

    		return true;
    	}

    	column.modules.filter = {
    		success: success,
    		attrType: false,
    		tagType: false,
    		emptyFunc: false
    	};

    	this.generateHeaderFilterElement(column);
    };

    Filter.prototype.generateHeaderFilterElement = function (column, initialValue, reinitialize) {
    	var _this62 = this;

    	var self = this,
    	    success = column.modules.filter.success,
    	    field = column.getField(),
    	    filterElement,
    	    editor,
    	    editorElement,
    	    cellWrapper,
    	    typingTimer,
    	    searchTrigger,
    	    params;

    	//handle aborted edit
    	function cancel() {}

    	if (column.modules.filter.headerElement && column.modules.filter.headerElement.parentNode) {
    		column.contentElement.removeChild(column.modules.filter.headerElement.parentNode);
    	}

    	if (field) {

    		//set empty value function
    		column.modules.filter.emptyFunc = column.definition.headerFilterEmptyCheck || function (value) {
    			return !value && value !== "0" && value !== 0;
    		};

    		filterElement = document.createElement("div");
    		filterElement.classList.add("tabulator-header-filter");

    		//set column editor
    		switch (_typeof(column.definition.headerFilter)) {
    			case "string":
    				if (self.table.modules.edit.editors[column.definition.headerFilter]) {
    					editor = self.table.modules.edit.editors[column.definition.headerFilter];

    					if ((column.definition.headerFilter === "tick" || column.definition.headerFilter === "tickCross") && !column.definition.headerFilterEmptyCheck) {
    						column.modules.filter.emptyFunc = function (value) {
    							return value !== true && value !== false;
    						};
    					}
    				} else {
    					console.warn("Filter Error - Cannot build header filter, No such editor found: ", column.definition.editor);
    				}
    				break;

    			case "function":
    				editor = column.definition.headerFilter;
    				break;

    			case "boolean":
    				if (column.modules.edit && column.modules.edit.editor) {
    					editor = column.modules.edit.editor;
    				} else {
    					if (column.definition.formatter && self.table.modules.edit.editors[column.definition.formatter]) {
    						editor = self.table.modules.edit.editors[column.definition.formatter];

    						if ((column.definition.formatter === "tick" || column.definition.formatter === "tickCross") && !column.definition.headerFilterEmptyCheck) {
    							column.modules.filter.emptyFunc = function (value) {
    								return value !== true && value !== false;
    							};
    						}
    					} else {
    						editor = self.table.modules.edit.editors["input"];
    					}
    				}
    				break;
    		}

    		if (editor) {

    			cellWrapper = {
    				getValue: function getValue() {
    					return typeof initialValue !== "undefined" ? initialValue : "";
    				},
    				getField: function getField() {
    					return column.definition.field;
    				},
    				getElement: function getElement() {
    					return filterElement;
    				},
    				getColumn: function getColumn() {
    					return column.getComponent();
    				},
    				getRow: function getRow() {
    					return {
    						normalizeHeight: function normalizeHeight() {}
    					};
    				}
    			};

    			params = column.definition.headerFilterParams || {};

    			params = typeof params === "function" ? params.call(self.table) : params;

    			editorElement = editor.call(this.table.modules.edit, cellWrapper, function () {}, success, cancel, params);

    			if (!editorElement) {
    				console.warn("Filter Error - Cannot add filter to " + field + " column, editor returned a value of false");
    				return;
    			}

    			if (!(editorElement instanceof Node)) {
    				console.warn("Filter Error - Cannot add filter to " + field + " column, editor should return an instance of Node, the editor returned:", editorElement);
    				return;
    			}

    			//set Placeholder Text
    			if (field) {
    				self.table.modules.localize.bind("headerFilters|columns|" + column.definition.field, function (value) {
    					editorElement.setAttribute("placeholder", typeof value !== "undefined" && value ? value : self.table.modules.localize.getText("headerFilters|default"));
    				});
    			} else {
    				self.table.modules.localize.bind("headerFilters|default", function (value) {
    					editorElement.setAttribute("placeholder", typeof self.column.definition.headerFilterPlaceholder !== "undefined" && self.column.definition.headerFilterPlaceholder ? self.column.definition.headerFilterPlaceholder : value);
    				});
    			}

    			//focus on element on click
    			editorElement.addEventListener("click", function (e) {
    				e.stopPropagation();
    				editorElement.focus();
    			});

    			editorElement.addEventListener("focus", function (e) {
    				var left = _this62.table.columnManager.element.scrollLeft;

    				if (left !== _this62.table.rowManager.element.scrollLeft) {
    					_this62.table.rowManager.scrollHorizontal(left);
    					_this62.table.columnManager.scrollHorizontal(left);
    				}
    			});

    			//live update filters as user types
    			typingTimer = false;

    			searchTrigger = function searchTrigger(e) {
    				if (typingTimer) {
    					clearTimeout(typingTimer);
    				}

    				typingTimer = setTimeout(function () {
    					success(editorElement.value);
    				}, self.table.options.headerFilterLiveFilterDelay);
    			};

    			column.modules.filter.headerElement = editorElement;
    			column.modules.filter.attrType = editorElement.hasAttribute("type") ? editorElement.getAttribute("type").toLowerCase() : "";
    			column.modules.filter.tagType = editorElement.tagName.toLowerCase();

    			if (column.definition.headerFilterLiveFilter !== false) {

    				if (!(column.definition.headerFilter === 'autocomplete' || column.definition.headerFilter === 'tickCross' || (column.definition.editor === 'autocomplete' || column.definition.editor === 'tickCross') && column.definition.headerFilter === true)) {
    					editorElement.addEventListener("keyup", searchTrigger);
    					editorElement.addEventListener("search", searchTrigger);

    					//update number filtered columns on change
    					if (column.modules.filter.attrType == "number") {
    						editorElement.addEventListener("change", function (e) {
    							success(editorElement.value);
    						});
    					}

    					//change text inputs to search inputs to allow for clearing of field
    					if (column.modules.filter.attrType == "text" && this.table.browser !== "ie") {
    						editorElement.setAttribute("type", "search");
    						// editorElement.off("change blur"); //prevent blur from triggering filter and preventing selection click
    					}
    				}

    				//prevent input and select elements from propegating click to column sorters etc
    				if (column.modules.filter.tagType == "input" || column.modules.filter.tagType == "select" || column.modules.filter.tagType == "textarea") {
    					editorElement.addEventListener("mousedown", function (e) {
    						e.stopPropagation();
    					});
    				}
    			}

    			filterElement.appendChild(editorElement);

    			column.contentElement.appendChild(filterElement);

    			if (!reinitialize) {
    				self.headerFilterColumns.push(column);
    			}
    		}
    	} else {
    		console.warn("Filter Error - Cannot add header filter, column has no field set:", column.definition.title);
    	}
    };

    //hide all header filter elements (used to ensure correct column widths in "fitData" layout mode)
    Filter.prototype.hideHeaderFilterElements = function () {
    	this.headerFilterColumns.forEach(function (column) {
    		if (column.modules.filter && column.modules.filter.headerElement) {
    			column.modules.filter.headerElement.style.display = 'none';
    		}
    	});
    };

    //show all header filter elements (used to ensure correct column widths in "fitData" layout mode)
    Filter.prototype.showHeaderFilterElements = function () {
    	this.headerFilterColumns.forEach(function (column) {
    		if (column.modules.filter && column.modules.filter.headerElement) {
    			column.modules.filter.headerElement.style.display = '';
    		}
    	});
    };

    //programatically set focus of header filter
    Filter.prototype.setHeaderFilterFocus = function (column) {
    	if (column.modules.filter && column.modules.filter.headerElement) {
    		column.modules.filter.headerElement.focus();
    	} else {
    		console.warn("Column Filter Focus Error - No header filter set on column:", column.getField());
    	}
    };

    //programmatically get value of header filter
    Filter.prototype.getHeaderFilterValue = function (column) {
    	if (column.modules.filter && column.modules.filter.headerElement) {
    		return column.modules.filter.headerElement.value;
    	} else {
    		console.warn("Column Filter Error - No header filter set on column:", column.getField());
    	}
    };

    //programatically set value of header filter
    Filter.prototype.setHeaderFilterValue = function (column, value) {
    	if (column) {
    		if (column.modules.filter && column.modules.filter.headerElement) {
    			this.generateHeaderFilterElement(column, value, true);
    			column.modules.filter.success(value);
    		} else {
    			console.warn("Column Filter Error - No header filter set on column:", column.getField());
    		}
    	}
    };

    Filter.prototype.reloadHeaderFilter = function (column) {
    	if (column) {
    		if (column.modules.filter && column.modules.filter.headerElement) {
    			this.generateHeaderFilterElement(column, column.modules.filter.value, true);
    		} else {
    			console.warn("Column Filter Error - No header filter set on column:", column.getField());
    		}
    	}
    };

    //check if the filters has changed since last use
    Filter.prototype.hasChanged = function () {
    	var changed = this.changed;
    	this.changed = false;
    	return changed;
    };

    //set standard filters
    Filter.prototype.setFilter = function (field, type, value, params) {
    	var self = this;

    	self.filterList = [];

    	if (!Array.isArray(field)) {
    		field = [{ field: field, type: type, value: value, params: params }];
    	}

    	self.addFilter(field);
    };

    //add filter to array
    Filter.prototype.addFilter = function (field, type, value, params) {
    	var self = this;

    	if (!Array.isArray(field)) {
    		field = [{ field: field, type: type, value: value, params: params }];
    	}

    	field.forEach(function (filter) {

    		filter = self.findFilter(filter);

    		if (filter) {
    			self.filterList.push(filter);

    			self.changed = true;
    		}
    	});

    	if (this.table.options.persistence && this.table.modExists("persistence", true) && this.table.modules.persistence.config.filter) {
    		this.table.modules.persistence.save("filter");
    	}
    };

    Filter.prototype.findFilter = function (filter) {
    	var self = this,
    	    column;

    	if (Array.isArray(filter)) {
    		return this.findSubFilters(filter);
    	}

    	var filterFunc = false;

    	if (typeof filter.field == "function") {
    		filterFunc = function filterFunc(data) {
    			return filter.field(data, filter.type || {}); // pass params to custom filter function
    		};
    	} else {

    		if (self.filters[filter.type]) {

    			column = self.table.columnManager.getColumnByField(filter.field);

    			if (column) {
    				filterFunc = function filterFunc(data) {
    					return self.filters[filter.type](filter.value, column.getFieldValue(data), data, filter.params || {});
    				};
    			} else {
    				filterFunc = function filterFunc(data) {
    					return self.filters[filter.type](filter.value, data[filter.field], data, filter.params || {});
    				};
    			}
    		} else {
    			console.warn("Filter Error - No such filter type found, ignoring: ", filter.type);
    		}
    	}

    	filter.func = filterFunc;

    	return filter.func ? filter : false;
    };

    Filter.prototype.findSubFilters = function (filters) {
    	var self = this,
    	    output = [];

    	filters.forEach(function (filter) {
    		filter = self.findFilter(filter);

    		if (filter) {
    			output.push(filter);
    		}
    	});

    	return output.length ? output : false;
    };

    //get all filters
    Filter.prototype.getFilters = function (all, ajax) {
    	var output = [];

    	if (all) {
    		output = this.getHeaderFilters();
    	}

    	if (ajax) {
    		output.forEach(function (item) {
    			if (typeof item.type == "function") {
    				item.type = "function";
    			}
    		});
    	}

    	output = output.concat(this.filtersToArray(this.filterList, ajax));

    	return output;
    };

    //filter to Object
    Filter.prototype.filtersToArray = function (filterList, ajax) {
    	var _this63 = this;

    	var output = [];

    	filterList.forEach(function (filter) {
    		var item;

    		if (Array.isArray(filter)) {
    			output.push(_this63.filtersToArray(filter, ajax));
    		} else {
    			item = { field: filter.field, type: filter.type, value: filter.value };

    			if (ajax) {
    				if (typeof item.type == "function") {
    					item.type = "function";
    				}
    			}

    			output.push(item);
    		}
    	});

    	return output;
    };

    //get all filters
    Filter.prototype.getHeaderFilters = function () {
    	var output = [];

    	for (var key in this.headerFilters) {
    		output.push({ field: key, type: this.headerFilters[key].type, value: this.headerFilters[key].value });
    	}

    	return output;
    };

    //remove filter from array
    Filter.prototype.removeFilter = function (field, type, value) {
    	var self = this;

    	if (!Array.isArray(field)) {
    		field = [{ field: field, type: type, value: value }];
    	}

    	field.forEach(function (filter) {
    		var index = -1;

    		if (_typeof(filter.field) == "object") {
    			index = self.filterList.findIndex(function (element) {
    				return filter === element;
    			});
    		} else {
    			index = self.filterList.findIndex(function (element) {
    				return filter.field === element.field && filter.type === element.type && filter.value === element.value;
    			});
    		}

    		if (index > -1) {
    			self.filterList.splice(index, 1);
    			self.changed = true;
    		} else {
    			console.warn("Filter Error - No matching filter type found, ignoring: ", filter.type);
    		}
    	});

    	if (this.table.options.persistence && this.table.modExists("persistence", true) && this.table.modules.persistence.config.filter) {
    		this.table.modules.persistence.save("filter");
    	}
    };

    //clear filters
    Filter.prototype.clearFilter = function (all) {
    	this.filterList = [];

    	if (all) {
    		this.clearHeaderFilter();
    	}

    	this.changed = true;

    	if (this.table.options.persistence && this.table.modExists("persistence", true) && this.table.modules.persistence.config.filter) {
    		this.table.modules.persistence.save("filter");
    	}
    };

    //clear header filters
    Filter.prototype.clearHeaderFilter = function () {
    	var self = this;

    	this.headerFilters = {};
    	self.prevHeaderFilterChangeCheck = "{}";

    	this.headerFilterColumns.forEach(function (column) {
    		if (typeof column.modules.filter.value !== "undefined") {
    			delete column.modules.filter.value;
    		}
    		column.modules.filter.prevSuccess = undefined;
    		self.reloadHeaderFilter(column);
    	});

    	this.changed = true;
    };

    //search data and return matching rows
    Filter.prototype.search = function (searchType, field, type, value) {
    	var self = this,
    	    activeRows = [],
    	    filterList = [];

    	if (!Array.isArray(field)) {
    		field = [{ field: field, type: type, value: value }];
    	}

    	field.forEach(function (filter) {
    		filter = self.findFilter(filter);

    		if (filter) {
    			filterList.push(filter);
    		}
    	});

    	this.table.rowManager.rows.forEach(function (row) {
    		var match = true;

    		filterList.forEach(function (filter) {
    			if (!self.filterRecurse(filter, row.getData())) {
    				match = false;
    			}
    		});

    		if (match) {
    			activeRows.push(searchType === "data" ? row.getData("data") : row.getComponent());
    		}
    	});

    	return activeRows;
    };

    //filter row array
    Filter.prototype.filter = function (rowList, filters) {
    	var self = this,
    	    activeRows = [],
    	    activeRowComponents = [];

    	if (self.table.options.dataFiltering) {
    		self.table.options.dataFiltering.call(self.table, self.getFilters());
    	}

    	if (!self.table.options.ajaxFiltering && (self.filterList.length || Object.keys(self.headerFilters).length)) {

    		rowList.forEach(function (row) {
    			if (self.filterRow(row)) {
    				activeRows.push(row);
    			}
    		});
    	} else {
    		activeRows = rowList.slice(0);
    	}

    	if (self.table.options.dataFiltered) {

    		activeRows.forEach(function (row) {
    			activeRowComponents.push(row.getComponent());
    		});

    		self.table.options.dataFiltered.call(self.table, self.getFilters(), activeRowComponents);
    	}

    	return activeRows;
    };

    //filter individual row
    Filter.prototype.filterRow = function (row, filters) {
    	var self = this,
    	    match = true,
    	    data = row.getData();

    	self.filterList.forEach(function (filter) {
    		if (!self.filterRecurse(filter, data)) {
    			match = false;
    		}
    	});

    	for (var field in self.headerFilters) {
    		if (!self.headerFilters[field].func(data)) {
    			match = false;
    		}
    	}

    	return match;
    };

    Filter.prototype.filterRecurse = function (filter, data) {
    	var self = this,
    	    match = false;

    	if (Array.isArray(filter)) {
    		filter.forEach(function (subFilter) {
    			if (self.filterRecurse(subFilter, data)) {
    				match = true;
    			}
    		});
    	} else {
    		match = filter.func(data);
    	}

    	return match;
    };

    //list of available filters
    Filter.prototype.filters = {

    	//equal to
    	"=": function _(filterVal, rowVal, rowData, filterParams) {
    		return rowVal == filterVal ? true : false;
    	},

    	//less than
    	"<": function _(filterVal, rowVal, rowData, filterParams) {
    		return rowVal < filterVal ? true : false;
    	},

    	//less than or equal to
    	"<=": function _(filterVal, rowVal, rowData, filterParams) {
    		return rowVal <= filterVal ? true : false;
    	},

    	//greater than
    	">": function _(filterVal, rowVal, rowData, filterParams) {
    		return rowVal > filterVal ? true : false;
    	},

    	//greater than or equal to
    	">=": function _(filterVal, rowVal, rowData, filterParams) {
    		return rowVal >= filterVal ? true : false;
    	},

    	//not equal to
    	"!=": function _(filterVal, rowVal, rowData, filterParams) {
    		return rowVal != filterVal ? true : false;
    	},

    	"regex": function regex(filterVal, rowVal, rowData, filterParams) {

    		if (typeof filterVal == "string") {
    			filterVal = new RegExp(filterVal);
    		}

    		return filterVal.test(rowVal);
    	},

    	//contains the string
    	"like": function like(filterVal, rowVal, rowData, filterParams) {
    		if (filterVal === null || typeof filterVal === "undefined") {
    			return rowVal === filterVal ? true : false;
    		} else {
    			if (typeof rowVal !== 'undefined' && rowVal !== null) {
    				return String(rowVal).toLowerCase().indexOf(filterVal.toLowerCase()) > -1;
    			} else {
    				return false;
    			}
    		}
    	},

    	//contains the keywords
    	"keywords": function keywords(filterVal, rowVal, rowData, filterParams) {
    		var keywords = filterVal.toLowerCase().split(typeof filterParams.separator === "undefined" ? " " : filterParams.separator),
    		    value = String(rowVal === null || typeof rowVal === "undefined" ? "" : rowVal).toLowerCase(),
    		    matches = [];

    		keywords.forEach(function (keyword) {
    			if (value.includes(keyword)) {
    				matches.push(true);
    			}
    		});

    		return filterParams.matchAll ? matches.length === keywords.length : !!matches.length;
    	},

    	//starts with the string
    	"starts": function starts(filterVal, rowVal, rowData, filterParams) {
    		if (filterVal === null || typeof filterVal === "undefined") {
    			return rowVal === filterVal ? true : false;
    		} else {
    			if (typeof rowVal !== 'undefined' && rowVal !== null) {
    				return String(rowVal).toLowerCase().startsWith(filterVal.toLowerCase());
    			} else {
    				return false;
    			}
    		}
    	},

    	//ends with the string
    	"ends": function ends(filterVal, rowVal, rowData, filterParams) {
    		if (filterVal === null || typeof filterVal === "undefined") {
    			return rowVal === filterVal ? true : false;
    		} else {
    			if (typeof rowVal !== 'undefined' && rowVal !== null) {
    				return String(rowVal).toLowerCase().endsWith(filterVal.toLowerCase());
    			} else {
    				return false;
    			}
    		}
    	},

    	//in array
    	"in": function _in(filterVal, rowVal, rowData, filterParams) {
    		if (Array.isArray(filterVal)) {
    			return filterVal.length ? filterVal.indexOf(rowVal) > -1 : true;
    		} else {
    			console.warn("Filter Error - filter value is not an array:", filterVal);
    			return false;
    		}
    	}
    };

    Tabulator.prototype.registerModule("filter", Filter);

    var Format = function Format(table) {
    	this.table = table; //hold Tabulator object
    };

    //initialize column formatter
    Format.prototype.initializeColumn = function (column) {
    	column.modules.format = this.lookupFormatter(column, "");

    	if (typeof column.definition.formatterPrint !== "undefined") {
    		column.modules.format.print = this.lookupFormatter(column, "Print");
    	}

    	if (typeof column.definition.formatterClipboard !== "undefined") {
    		column.modules.format.clipboard = this.lookupFormatter(column, "Clipboard");
    	}

    	if (typeof column.definition.formatterHtmlOutput !== "undefined") {
    		column.modules.format.htmlOutput = this.lookupFormatter(column, "HtmlOutput");
    	}
    };

    Format.prototype.lookupFormatter = function (column, type) {
    	var config = { params: column.definition["formatter" + type + "Params"] || {} },
    	    formatter = column.definition["formatter" + type];

    	//set column formatter
    	switch (typeof formatter === 'undefined' ? 'undefined' : _typeof(formatter)) {
    		case "string":

    			if (formatter === "tick") {
    				formatter = "tickCross";

    				if (typeof config.params.crossElement == "undefined") {
    					config.params.crossElement = false;
    				}

    				console.warn("DEPRECATION WARNING - the tick formatter has been deprecated, please use the tickCross formatter with the crossElement param set to false");
    			}

    			if (this.formatters[formatter]) {
    				config.formatter = this.formatters[formatter];
    			} else {
    				console.warn("Formatter Error - No such formatter found: ", formatter);
    				config.formatter = this.formatters.plaintext;
    			}
    			break;

    		case "function":
    			config.formatter = formatter;
    			break;

    		default:
    			config.formatter = this.formatters.plaintext;
    			break;
    	}

    	return config;
    };

    Format.prototype.cellRendered = function (cell) {
    	if (cell.modules.format && cell.modules.format.renderedCallback && !cell.modules.format.rendered) {
    		cell.modules.format.renderedCallback();
    		cell.modules.format.rendered = true;
    	}
    };

    //return a formatted value for a cell
    Format.prototype.formatValue = function (cell) {
    	var component = cell.getComponent(),
    	    params = typeof cell.column.modules.format.params === "function" ? cell.column.modules.format.params(component) : cell.column.modules.format.params;

    	function onRendered(callback) {
    		if (!cell.modules.format) {
    			cell.modules.format = {};
    		}

    		cell.modules.format.renderedCallback = callback;
    		cell.modules.format.rendered = false;
    	}

    	return cell.column.modules.format.formatter.call(this, component, params, onRendered);
    };

    Format.prototype.formatExportValue = function (cell, type) {
    	var formatter = cell.column.modules.format[type],
    	    params;

    	if (formatter) {
    		var onRendered = function onRendered(callback) {
    			if (!cell.modules.format) {
    				cell.modules.format = {};
    			}

    			cell.modules.format.renderedCallback = callback;
    			cell.modules.format.rendered = false;
    		};

    		params = typeof formatter.params === "function" ? formatter.params(component) : formatter.params;

    		return formatter.formatter.call(this, cell.getComponent(), params, onRendered);
    	} else {
    		return this.formatValue(cell);
    	}
    };

    Format.prototype.sanitizeHTML = function (value) {
    	if (value) {
    		var entityMap = {
    			'&': '&amp;',
    			'<': '&lt;',
    			'>': '&gt;',
    			'"': '&quot;',
    			"'": '&#39;',
    			'/': '&#x2F;',
    			'`': '&#x60;',
    			'=': '&#x3D;'
    		};

    		return String(value).replace(/[&<>"'`=\/]/g, function (s) {
    			return entityMap[s];
    		});
    	} else {
    		return value;
    	}
    };

    Format.prototype.emptyToSpace = function (value) {
    	return value === null || typeof value === "undefined" || value === "" ? "&nbsp;" : value;
    };

    //get formatter for cell
    Format.prototype.getFormatter = function (formatter) {
    	var formatter;

    	switch (typeof formatter === 'undefined' ? 'undefined' : _typeof(formatter)) {
    		case "string":
    			if (this.formatters[formatter]) {
    				formatter = this.formatters[formatter];
    			} else {
    				console.warn("Formatter Error - No such formatter found: ", formatter);
    				formatter = this.formatters.plaintext;
    			}
    			break;

    		case "function":
    			formatter = formatter;
    			break;

    		default:
    			formatter = this.formatters.plaintext;
    			break;
    	}

    	return formatter;
    };

    //default data formatters
    Format.prototype.formatters = {
    	//plain text value
    	plaintext: function plaintext(cell, formatterParams, onRendered) {
    		return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));
    	},

    	//html text value
    	html: function html(cell, formatterParams, onRendered) {
    		return cell.getValue();
    	},

    	//multiline text area
    	textarea: function textarea(cell, formatterParams, onRendered) {
    		cell.getElement().style.whiteSpace = "pre-wrap";
    		return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));
    	},

    	//currency formatting
    	money: function money(cell, formatterParams, onRendered) {
    		var floatVal = parseFloat(cell.getValue()),
    		    number,
    		    integer,
    		    decimal,
    		    rgx;

    		var decimalSym = formatterParams.decimal || ".";
    		var thousandSym = formatterParams.thousand || ",";
    		var symbol = formatterParams.symbol || "";
    		var after = !!formatterParams.symbolAfter;
    		var precision = typeof formatterParams.precision !== "undefined" ? formatterParams.precision : 2;

    		if (isNaN(floatVal)) {
    			return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));
    		}

    		number = precision !== false ? floatVal.toFixed(precision) : floatVal;
    		number = String(number).split(".");

    		integer = number[0];
    		decimal = number.length > 1 ? decimalSym + number[1] : "";

    		rgx = /(\d+)(\d{3})/;

    		while (rgx.test(integer)) {
    			integer = integer.replace(rgx, "$1" + thousandSym + "$2");
    		}

    		return after ? integer + decimal + symbol : symbol + integer + decimal;
    	},

    	//clickable anchor tag
    	link: function link(cell, formatterParams, onRendered) {
    		var value = cell.getValue(),
    		    urlPrefix = formatterParams.urlPrefix || "",
    		    download = formatterParams.download,
    		    label = value,
    		    el = document.createElement("a"),
    		    data;

    		if (formatterParams.labelField) {
    			data = cell.getData();
    			label = data[formatterParams.labelField];
    		}

    		if (formatterParams.label) {
    			switch (_typeof(formatterParams.label)) {
    				case "string":
    					label = formatterParams.label;
    					break;

    				case "function":
    					label = formatterParams.label(cell);
    					break;
    			}
    		}

    		if (label) {
    			if (formatterParams.urlField) {
    				data = cell.getData();
    				value = data[formatterParams.urlField];
    			}

    			if (formatterParams.url) {
    				switch (_typeof(formatterParams.url)) {
    					case "string":
    						value = formatterParams.url;
    						break;

    					case "function":
    						value = formatterParams.url(cell);
    						break;
    				}
    			}

    			el.setAttribute("href", urlPrefix + value);

    			if (formatterParams.target) {
    				el.setAttribute("target", formatterParams.target);
    			}

    			if (formatterParams.download) {

    				if (typeof download == "function") {
    					download = download(cell);
    				} else {
    					download = download === true ? "" : download;
    				}

    				el.setAttribute("download", download);
    			}

    			el.innerHTML = this.emptyToSpace(this.sanitizeHTML(label));

    			return el;
    		} else {
    			return "&nbsp;";
    		}
    	},

    	//image element
    	image: function image(cell, formatterParams, onRendered) {
    		var el = document.createElement("img"),
    		    src = cell.getValue();

    		if (formatterParams.urlPrefix) {
    			src = formatterParams.urlPrefix + cell.getValue();
    		}

    		if (formatterParams.urlSuffix) {
    			src = src + formatterParams.urlSuffix;
    		}

    		el.setAttribute("src", src);

    		switch (_typeof(formatterParams.height)) {
    			case "number":
    				el.style.height = formatterParams.height + "px";
    				break;

    			case "string":
    				el.style.height = formatterParams.height;
    				break;
    		}

    		switch (_typeof(formatterParams.width)) {
    			case "number":
    				el.style.width = formatterParams.width + "px";
    				break;

    			case "string":
    				el.style.width = formatterParams.width;
    				break;
    		}

    		el.addEventListener("load", function () {
    			cell.getRow().normalizeHeight();
    		});

    		return el;
    	},

    	//tick or cross
    	tickCross: function tickCross(cell, formatterParams, onRendered) {
    		var value = cell.getValue(),
    		    element = cell.getElement(),
    		    empty = formatterParams.allowEmpty,
    		    truthy = formatterParams.allowTruthy,
    		    tick = typeof formatterParams.tickElement !== "undefined" ? formatterParams.tickElement : '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>',
    		    cross = typeof formatterParams.crossElement !== "undefined" ? formatterParams.crossElement : '<svg enable-background="new 0 0 24 24" height="14" width="14"  viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';

    		if (truthy && value || value === true || value === "true" || value === "True" || value === 1 || value === "1") {
    			element.setAttribute("aria-checked", true);
    			return tick || "";
    		} else {
    			if (empty && (value === "null" || value === "" || value === null || typeof value === "undefined")) {
    				element.setAttribute("aria-checked", "mixed");
    				return "";
    			} else {
    				element.setAttribute("aria-checked", false);
    				return cross || "";
    			}
    		}
    	},

    	datetime: function datetime(cell, formatterParams, onRendered) {
    		var inputFormat = formatterParams.inputFormat || "YYYY-MM-DD hh:mm:ss";
    		var outputFormat = formatterParams.outputFormat || "DD/MM/YYYY hh:mm:ss";
    		var invalid = typeof formatterParams.invalidPlaceholder !== "undefined" ? formatterParams.invalidPlaceholder : "";
    		var value = cell.getValue();

    		var newDatetime = moment(value, inputFormat);

    		if (newDatetime.isValid()) {
    			return formatterParams.timezone ? newDatetime.tz(formatterParams.timezone).format(outputFormat) : newDatetime.format(outputFormat);
    		} else {

    			if (invalid === true) {
    				return value;
    			} else if (typeof invalid === "function") {
    				return invalid(value);
    			} else {
    				return invalid;
    			}
    		}
    	},

    	datetimediff: function datetime(cell, formatterParams, onRendered) {
    		var inputFormat = formatterParams.inputFormat || "YYYY-MM-DD hh:mm:ss";
    		var invalid = typeof formatterParams.invalidPlaceholder !== "undefined" ? formatterParams.invalidPlaceholder : "";
    		var suffix = typeof formatterParams.suffix !== "undefined" ? formatterParams.suffix : false;
    		var unit = typeof formatterParams.unit !== "undefined" ? formatterParams.unit : undefined;
    		var humanize = typeof formatterParams.humanize !== "undefined" ? formatterParams.humanize : false;
    		var date = typeof formatterParams.date !== "undefined" ? formatterParams.date : moment();
    		var value = cell.getValue();

    		var newDatetime = moment(value, inputFormat);

    		if (newDatetime.isValid()) {
    			if (humanize) {
    				return moment.duration(newDatetime.diff(date)).humanize(suffix);
    			} else {
    				return newDatetime.diff(date, unit) + (suffix ? " " + suffix : "");
    			}
    		} else {

    			if (invalid === true) {
    				return value;
    			} else if (typeof invalid === "function") {
    				return invalid(value);
    			} else {
    				return invalid;
    			}
    		}
    	},

    	//select
    	lookup: function lookup(cell, formatterParams, onRendered) {
    		var value = cell.getValue();

    		if (typeof formatterParams[value] === "undefined") {
    			console.warn('Missing display value for ' + value);
    			return value;
    		}

    		return formatterParams[value];
    	},

    	//star rating
    	star: function star(cell, formatterParams, onRendered) {
    		var value = cell.getValue(),
    		    element = cell.getElement(),
    		    maxStars = formatterParams && formatterParams.stars ? formatterParams.stars : 5,
    		    stars = document.createElement("span"),
    		    star = document.createElementNS('http://www.w3.org/2000/svg', "svg"),
    		    starActive = '<polygon fill="#FFEA00" stroke="#C1AB60" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>',
    		    starInactive = '<polygon fill="#D2D2D2" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';

    		//style stars holder
    		stars.style.verticalAlign = "middle";

    		//style star
    		star.setAttribute("width", "14");
    		star.setAttribute("height", "14");
    		star.setAttribute("viewBox", "0 0 512 512");
    		star.setAttribute("xml:space", "preserve");
    		star.style.padding = "0 1px";

    		value = value && !isNaN(value) ? parseInt(value) : 0;

    		value = Math.max(0, Math.min(value, maxStars));

    		for (var i = 1; i <= maxStars; i++) {
    			var nextStar = star.cloneNode(true);
    			nextStar.innerHTML = i <= value ? starActive : starInactive;

    			stars.appendChild(nextStar);
    		}

    		element.style.whiteSpace = "nowrap";
    		element.style.overflow = "hidden";
    		element.style.textOverflow = "ellipsis";

    		element.setAttribute("aria-label", value);

    		return stars;
    	},

    	traffic: function traffic(cell, formatterParams, onRendered) {
    		var value = this.sanitizeHTML(cell.getValue()) || 0,
    		    el = document.createElement("span"),
    		    max = formatterParams && formatterParams.max ? formatterParams.max : 100,
    		    min = formatterParams && formatterParams.min ? formatterParams.min : 0,
    		    colors = formatterParams && typeof formatterParams.color !== "undefined" ? formatterParams.color : ["red", "orange", "green"],
    		    color = "#666666",
    		    percent,
    		    percentValue;

    		if (isNaN(value) || typeof cell.getValue() === "undefined") {
    			return;
    		}

    		el.classList.add("tabulator-traffic-light");

    		//make sure value is in range
    		percentValue = parseFloat(value) <= max ? parseFloat(value) : max;
    		percentValue = parseFloat(percentValue) >= min ? parseFloat(percentValue) : min;

    		//workout percentage
    		percent = (max - min) / 100;
    		percentValue = Math.round((percentValue - min) / percent);

    		//set color
    		switch (typeof colors === 'undefined' ? 'undefined' : _typeof(colors)) {
    			case "string":
    				color = colors;
    				break;
    			case "function":
    				color = colors(value);
    				break;
    			case "object":
    				if (Array.isArray(colors)) {
    					var unit = 100 / colors.length;
    					var index = Math.floor(percentValue / unit);

    					index = Math.min(index, colors.length - 1);
    					index = Math.max(index, 0);
    					color = colors[index];
    					break;
    				}
    		}

    		el.style.backgroundColor = color;

    		return el;
    	},

    	//progress bar
    	progress: function progress(cell, formatterParams, onRendered) {
    		//progress bar
    		var value = this.sanitizeHTML(cell.getValue()) || 0,
    		    element = cell.getElement(),
    		    max = formatterParams && formatterParams.max ? formatterParams.max : 100,
    		    min = formatterParams && formatterParams.min ? formatterParams.min : 0,
    		    legendAlign = formatterParams && formatterParams.legendAlign ? formatterParams.legendAlign : "center",
    		    percent,
    		    percentValue,
    		    color,
    		    legend,
    		    legendColor;

    		//make sure value is in range
    		percentValue = parseFloat(value) <= max ? parseFloat(value) : max;
    		percentValue = parseFloat(percentValue) >= min ? parseFloat(percentValue) : min;

    		//workout percentage
    		percent = (max - min) / 100;
    		percentValue = Math.round((percentValue - min) / percent);

    		//set bar color
    		switch (_typeof(formatterParams.color)) {
    			case "string":
    				color = formatterParams.color;
    				break;
    			case "function":
    				color = formatterParams.color(value);
    				break;
    			case "object":
    				if (Array.isArray(formatterParams.color)) {
    					var unit = 100 / formatterParams.color.length;
    					var index = Math.floor(percentValue / unit);

    					index = Math.min(index, formatterParams.color.length - 1);
    					index = Math.max(index, 0);
    					color = formatterParams.color[index];
    					break;
    				}
    			default:
    				color = "#2DC214";
    		}

    		//generate legend
    		switch (_typeof(formatterParams.legend)) {
    			case "string":
    				legend = formatterParams.legend;
    				break;
    			case "function":
    				legend = formatterParams.legend(value);
    				break;
    			case "boolean":
    				legend = value;
    				break;
    			default:
    				legend = false;
    		}

    		//set legend color
    		switch (_typeof(formatterParams.legendColor)) {
    			case "string":
    				legendColor = formatterParams.legendColor;
    				break;
    			case "function":
    				legendColor = formatterParams.legendColor(value);
    				break;
    			case "object":
    				if (Array.isArray(formatterParams.legendColor)) {
    					var unit = 100 / formatterParams.legendColor.length;
    					var index = Math.floor(percentValue / unit);

    					index = Math.min(index, formatterParams.legendColor.length - 1);
    					index = Math.max(index, 0);
    					legendColor = formatterParams.legendColor[index];
    				}
    				break;
    			default:
    				legendColor = "#000";
    		}

    		element.style.minWidth = "30px";
    		element.style.position = "relative";

    		element.setAttribute("aria-label", percentValue);

    		var barEl = document.createElement("div");
    		barEl.style.display = "inline-block";
    		barEl.style.position = "relative";
    		barEl.style.width = percentValue + "%";
    		barEl.style.backgroundColor = color;
    		barEl.style.height = "100%";

    		barEl.setAttribute('data-max', max);
    		barEl.setAttribute('data-min', min);

    		if (legend) {
    			var legendEl = document.createElement("div");
    			legendEl.style.position = "absolute";
    			legendEl.style.top = "4px";
    			legendEl.style.left = 0;
    			legendEl.style.textAlign = legendAlign;
    			legendEl.style.width = "100%";
    			legendEl.style.color = legendColor;
    			legendEl.innerHTML = legend;
    		}

    		onRendered(function () {

    			//handle custom element needed if formatter is to be included in printed/downloaded output
    			if (!(cell instanceof CellComponent)) {
    				var holderEl = document.createElement("div");
    				holderEl.style.position = "absolute";
    				holderEl.style.top = "4px";
    				holderEl.style.bottom = "4px";
    				holderEl.style.left = "4px";
    				holderEl.style.right = "4px";

    				element.appendChild(holderEl);

    				element = holderEl;
    			}

    			element.appendChild(barEl);

    			if (legend) {
    				element.appendChild(legendEl);
    			}
    		});

    		return "";
    	},

    	//background color
    	color: function color(cell, formatterParams, onRendered) {
    		cell.getElement().style.backgroundColor = this.sanitizeHTML(cell.getValue());
    		return "";
    	},

    	//tick icon
    	buttonTick: function buttonTick(cell, formatterParams, onRendered) {
    		return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>';
    	},

    	//cross icon
    	buttonCross: function buttonCross(cell, formatterParams, onRendered) {
    		return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';
    	},

    	//current row number
    	rownum: function rownum(cell, formatterParams, onRendered) {
    		return this.table.rowManager.activeRows.indexOf(cell.getRow()._getSelf()) + 1;
    	},

    	//row handle
    	handle: function handle(cell, formatterParams, onRendered) {
    		cell.getElement().classList.add("tabulator-row-handle");
    		return "<div class='tabulator-row-handle-box'><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div></div>";
    	},

    	responsiveCollapse: function responsiveCollapse(cell, formatterParams, onRendered) {
    		var el = document.createElement("div"),
    		    config = cell.getRow()._row.modules.responsiveLayout;

    		el.classList.add("tabulator-responsive-collapse-toggle");
    		el.innerHTML = "<span class='tabulator-responsive-collapse-toggle-open'>+</span><span class='tabulator-responsive-collapse-toggle-close'>-</span>";

    		cell.getElement().classList.add("tabulator-row-handle");

    		function toggleList(isOpen) {
    			var collapseEl = config.element;

    			config.open = isOpen;

    			if (collapseEl) {

    				if (config.open) {
    					el.classList.add("open");
    					collapseEl.style.display = '';
    				} else {
    					el.classList.remove("open");
    					collapseEl.style.display = 'none';
    				}
    			}
    		}

    		el.addEventListener("click", function (e) {
    			e.stopImmediatePropagation();
    			toggleList(!config.open);
    		});

    		toggleList(config.open);

    		return el;
    	},

    	rowSelection: function rowSelection(cell, formatterParams, onRendered) {
    		var _this64 = this;

    		var checkbox = document.createElement("input");

    		checkbox.type = 'checkbox';

    		if (this.table.modExists("selectRow", true)) {

    			checkbox.addEventListener("click", function (e) {
    				e.stopPropagation();
    			});

    			if (typeof cell.getRow == 'function') {
    				var row = cell.getRow();

    				if (row instanceof RowComponent) {

    					checkbox.addEventListener("change", function (e) {
    						row.toggleSelect();
    					});

    					checkbox.checked = row.isSelected && row.isSelected();
    					this.table.modules.selectRow.registerRowSelectCheckbox(row, checkbox);
    				} else {
    					checkbox = "";
    				}
    			} else {
    				checkbox.addEventListener("change", function (e) {
    					if (_this64.table.modules.selectRow.selectedRows.length) {
    						_this64.table.deselectRow();
    					} else {
    						_this64.table.selectRow(formatterParams.rowRange);
    					}
    				});

    				this.table.modules.selectRow.registerHeaderSelectCheckbox(checkbox);
    			}
    		}
    		return checkbox;
    	}
    };

    Tabulator.prototype.registerModule("format", Format);

    var FrozenColumns = function FrozenColumns(table) {
    	this.table = table; //hold Tabulator object
    	this.leftColumns = [];
    	this.rightColumns = [];
    	this.leftMargin = 0;
    	this.rightMargin = 0;
    	this.rightPadding = 0;
    	this.initializationMode = "left";
    	this.active = false;
    	this.scrollEndTimer = false;
    };

    //reset initial state
    FrozenColumns.prototype.reset = function () {
    	this.initializationMode = "left";
    	this.leftColumns = [];
    	this.rightColumns = [];
    	this.leftMargin = 0;
    	this.rightMargin = 0;
    	this.rightMargin = 0;
    	this.active = false;

    	this.table.columnManager.headersElement.style.marginLeft = 0;
    	this.table.columnManager.element.style.paddingRight = 0;
    };

    //initialize specific column
    FrozenColumns.prototype.initializeColumn = function (column) {
    	var config = { margin: 0, edge: false };

    	if (!column.isGroup) {

    		if (this.frozenCheck(column)) {

    			config.position = this.initializationMode;

    			if (this.initializationMode == "left") {
    				this.leftColumns.push(column);
    			} else {
    				this.rightColumns.unshift(column);
    			}

    			this.active = true;

    			column.modules.frozen = config;
    		} else {
    			this.initializationMode = "right";
    		}
    	}
    };

    FrozenColumns.prototype.frozenCheck = function (column) {

    	if (column.parent.isGroup && column.definition.frozen) {
    		console.warn("Frozen Column Error - Parent column group must be frozen, not individual columns or sub column groups");
    	}

    	if (column.parent.isGroup) {
    		return this.frozenCheck(column.parent);
    	} else {
    		return column.definition.frozen;
    	}
    };

    //quick layout to smooth horizontal scrolling
    FrozenColumns.prototype.scrollHorizontal = function () {
    	var _this65 = this;

    	var rows;

    	if (this.active) {
    		clearTimeout(this.scrollEndTimer);

    		//layout all rows after scroll is complete
    		this.scrollEndTimer = setTimeout(function () {
    			_this65.layout();
    		}, 100);

    		rows = this.table.rowManager.getVisibleRows();

    		this.calcMargins();

    		this.layoutColumnPosition();

    		this.layoutCalcRows();

    		rows.forEach(function (row) {
    			if (row.type === "row") {
    				_this65.layoutRow(row);
    			}
    		});

    		this.table.rowManager.tableElement.style.marginRight = this.rightMargin;
    	}
    };

    //calculate margins for rows
    FrozenColumns.prototype.calcMargins = function () {
    	this.leftMargin = this._calcSpace(this.leftColumns, this.leftColumns.length) + "px";
    	this.table.columnManager.headersElement.style.marginLeft = this.leftMargin;

    	this.rightMargin = this._calcSpace(this.rightColumns, this.rightColumns.length) + "px";
    	this.table.columnManager.element.style.paddingRight = this.rightMargin;

    	//calculate right frozen columns
    	this.rightPadding = this.table.rowManager.element.clientWidth + this.table.columnManager.scrollLeft;
    };

    //layout calculation rows
    FrozenColumns.prototype.layoutCalcRows = function () {
    	if (this.table.modExists("columnCalcs")) {
    		if (this.table.modules.columnCalcs.topInitialized && this.table.modules.columnCalcs.topRow) {
    			this.layoutRow(this.table.modules.columnCalcs.topRow);
    		}
    		if (this.table.modules.columnCalcs.botInitialized && this.table.modules.columnCalcs.botRow) {
    			this.layoutRow(this.table.modules.columnCalcs.botRow);
    		}
    	}
    };

    //calculate column positions and layout headers
    FrozenColumns.prototype.layoutColumnPosition = function (allCells) {
    	var _this66 = this;

    	var leftParents = [];

    	this.leftColumns.forEach(function (column, i) {
    		column.modules.frozen.margin = _this66._calcSpace(_this66.leftColumns, i) + _this66.table.columnManager.scrollLeft + "px";

    		if (i == _this66.leftColumns.length - 1) {
    			column.modules.frozen.edge = true;
    		} else {
    			column.modules.frozen.edge = false;
    		}

    		if (column.parent.isGroup) {
    			var parentEl = _this66.getColGroupParentElement(column);
    			if (!leftParents.includes(parentEl)) {
    				_this66.layoutElement(parentEl, column);
    				leftParents.push(parentEl);
    			}

    			if (column.modules.frozen.edge) {
    				parentEl.classList.add("tabulator-frozen-" + column.modules.frozen.position);
    			}
    		} else {
    			_this66.layoutElement(column.getElement(), column);
    		}

    		if (allCells) {
    			column.cells.forEach(function (cell) {
    				_this66.layoutElement(cell.getElement(true), column);
    			});
    		}
    	});

    	this.rightColumns.forEach(function (column, i) {
    		column.modules.frozen.margin = _this66.rightPadding - _this66._calcSpace(_this66.rightColumns, i + 1) + "px";

    		if (i == _this66.rightColumns.length - 1) {
    			column.modules.frozen.edge = true;
    		} else {
    			column.modules.frozen.edge = false;
    		}

    		if (column.parent.isGroup) {
    			_this66.layoutElement(_this66.getColGroupParentElement(column), column);
    		} else {
    			_this66.layoutElement(column.getElement(), column);
    		}

    		if (allCells) {
    			column.cells.forEach(function (cell) {
    				_this66.layoutElement(cell.getElement(true), column);
    			});
    		}
    	});
    };

    FrozenColumns.prototype.getColGroupParentElement = function (column) {
    	return column.parent.isGroup ? this.getColGroupParentElement(column.parent) : column.getElement();
    };

    //layout columns appropropriatly
    FrozenColumns.prototype.layout = function () {
    	var self = this;

    	if (self.active) {

    		//calculate row padding
    		this.calcMargins();

    		// self.table.rowManager.activeRows.forEach(function(row){
    		// 	self.layoutRow(row);
    		// });

    		// if(self.table.options.dataTree){
    		self.table.rowManager.getDisplayRows().forEach(function (row) {
    			if (row.type === "row") {
    				self.layoutRow(row);
    			}
    		});
    		// }

    		this.layoutCalcRows();

    		//calculate left columns
    		this.layoutColumnPosition(true);

    		// if(tableHolder.scrollHeight > tableHolder.clientHeight){
    		// 	rightMargin -= tableHolder.offsetWidth - tableHolder.clientWidth;
    		// }

    		this.table.rowManager.tableElement.style.marginRight = this.rightMargin;
    	}
    };

    FrozenColumns.prototype.layoutRow = function (row) {
    	var _this67 = this;

    	var rowEl = row.getElement();

    	rowEl.style.paddingLeft = this.leftMargin;
    	// rowEl.style.paddingRight = this.rightMargin + "px";

    	this.leftColumns.forEach(function (column) {
    		var cell = row.getCell(column);

    		if (cell) {
    			_this67.layoutElement(cell.getElement(true), column);
    		}
    	});

    	this.rightColumns.forEach(function (column) {
    		var cell = row.getCell(column);

    		if (cell) {
    			_this67.layoutElement(cell.getElement(true), column);
    		}
    	});
    };

    FrozenColumns.prototype.layoutElement = function (element, column) {

    	if (column.modules.frozen) {
    		element.style.position = "absolute";
    		element.style.left = column.modules.frozen.margin;

    		element.classList.add("tabulator-frozen");

    		if (column.modules.frozen.edge) {
    			element.classList.add("tabulator-frozen-" + column.modules.frozen.position);
    		}
    	}
    };

    FrozenColumns.prototype._calcSpace = function (columns, index) {
    	var width = 0;

    	for (var _i12 = 0; _i12 < index; _i12++) {
    		if (columns[_i12].visible) {
    			width += columns[_i12].getWidth();
    		}
    	}

    	return width;
    };

    Tabulator.prototype.registerModule("frozenColumns", FrozenColumns);
    var FrozenRows = function FrozenRows(table) {
    	this.table = table; //hold Tabulator object
    	this.topElement = document.createElement("div");
    	this.rows = [];
    	this.displayIndex = 0; //index in display pipeline
    };

    FrozenRows.prototype.initialize = function () {
    	this.rows = [];

    	this.topElement.classList.add("tabulator-frozen-rows-holder");

    	// this.table.columnManager.element.append(this.topElement);
    	this.table.columnManager.getElement().insertBefore(this.topElement, this.table.columnManager.headersElement.nextSibling);
    };

    FrozenRows.prototype.setDisplayIndex = function (index) {
    	this.displayIndex = index;
    };

    FrozenRows.prototype.getDisplayIndex = function () {
    	return this.displayIndex;
    };

    FrozenRows.prototype.isFrozen = function () {
    	return !!this.rows.length;
    };

    //filter frozen rows out of display data
    FrozenRows.prototype.getRows = function (rows) {
    	var output = rows.slice(0);

    	this.rows.forEach(function (row) {
    		var index = output.indexOf(row);

    		if (index > -1) {
    			output.splice(index, 1);
    		}
    	});

    	return output;
    };

    FrozenRows.prototype.freezeRow = function (row) {
    	if (!row.modules.frozen) {
    		row.modules.frozen = true;
    		this.topElement.appendChild(row.getElement());
    		row.initialize();
    		row.normalizeHeight();
    		this.table.rowManager.adjustTableSize();

    		this.rows.push(row);

    		this.table.rowManager.refreshActiveData("display");

    		this.styleRows();
    	} else {
    		console.warn("Freeze Error - Row is already frozen");
    	}
    };

    FrozenRows.prototype.unfreezeRow = function (row) {
    	this.rows.indexOf(row);

    	if (row.modules.frozen) {

    		row.modules.frozen = false;

    		this.detachRow(row);

    		this.table.rowManager.adjustTableSize();

    		this.table.rowManager.refreshActiveData("display");

    		if (this.rows.length) {
    			this.styleRows();
    		}
    	} else {
    		console.warn("Freeze Error - Row is already unfrozen");
    	}
    };

    FrozenRows.prototype.detachRow = function (row) {
    	var index = this.rows.indexOf(row);

    	if (index > -1) {
    		var rowEl = row.getElement();
    		rowEl.parentNode.removeChild(rowEl);

    		this.rows.splice(index, 1);
    	}
    };

    FrozenRows.prototype.styleRows = function (row) {
    	var self = this;

    	this.rows.forEach(function (row, i) {
    		self.table.rowManager.styleRow(row, i);
    	});
    };

    Tabulator.prototype.registerModule("frozenRows", FrozenRows);

    //public group object
    var GroupComponent = function GroupComponent(group) {
    	this._group = group;
    	this.type = "GroupComponent";
    };

    GroupComponent.prototype.getKey = function () {
    	return this._group.key;
    };

    GroupComponent.prototype.getField = function () {
    	return this._group.field;
    };

    GroupComponent.prototype.getElement = function () {
    	return this._group.element;
    };

    GroupComponent.prototype.getRows = function () {
    	return this._group.getRows(true);
    };

    GroupComponent.prototype.getSubGroups = function () {
    	return this._group.getSubGroups(true);
    };

    GroupComponent.prototype.getParentGroup = function () {
    	return this._group.parent ? this._group.parent.getComponent() : false;
    };

    GroupComponent.prototype.getVisibility = function () {
    	console.warn("getVisibility function is deprecated, you should now use the isVisible function");
    	return this._group.visible;
    };

    GroupComponent.prototype.isVisible = function () {
    	return this._group.visible;
    };

    GroupComponent.prototype.show = function () {
    	this._group.show();
    };

    GroupComponent.prototype.hide = function () {
    	this._group.hide();
    };

    GroupComponent.prototype.toggle = function () {
    	this._group.toggleVisibility();
    };

    GroupComponent.prototype._getSelf = function () {
    	return this._group;
    };

    GroupComponent.prototype.getTable = function () {
    	return this._group.groupManager.table;
    };

    //////////////////////////////////////////////////
    //////////////// Group Functions /////////////////
    //////////////////////////////////////////////////

    var Group = function Group(groupManager, parent, level, key, field, generator, oldGroup) {

    	this.groupManager = groupManager;
    	this.parent = parent;
    	this.key = key;
    	this.level = level;
    	this.field = field;
    	this.hasSubGroups = level < groupManager.groupIDLookups.length - 1;
    	this.addRow = this.hasSubGroups ? this._addRowToGroup : this._addRow;
    	this.type = "group"; //type of element
    	this.old = oldGroup;
    	this.rows = [];
    	this.groups = [];
    	this.groupList = [];
    	this.generator = generator;
    	this.elementContents = false;
    	this.height = 0;
    	this.outerHeight = 0;
    	this.initialized = false;
    	this.calcs = {};
    	this.initialized = false;
    	this.modules = {};
    	this.arrowElement = false;

    	this.visible = oldGroup ? oldGroup.visible : typeof groupManager.startOpen[level] !== "undefined" ? groupManager.startOpen[level] : groupManager.startOpen[0];

    	this.component = null;

    	this.createElements();
    	this.addBindings();

    	this.createValueGroups();
    };

    Group.prototype.wipe = function () {
    	if (this.groupList.length) {
    		this.groupList.forEach(function (group) {
    			group.wipe();
    		});
    	} else {
    		this.element = false;
    		this.arrowElement = false;
    		this.elementContents = false;
    	}
    };

    Group.prototype.createElements = function () {
    	var arrow = document.createElement("div");
    	arrow.classList.add("tabulator-arrow");

    	this.element = document.createElement("div");
    	this.element.classList.add("tabulator-row");
    	this.element.classList.add("tabulator-group");
    	this.element.classList.add("tabulator-group-level-" + this.level);
    	this.element.setAttribute("role", "rowgroup");

    	this.arrowElement = document.createElement("div");
    	this.arrowElement.classList.add("tabulator-group-toggle");
    	this.arrowElement.appendChild(arrow);

    	//setup movable rows
    	if (this.groupManager.table.options.movableRows !== false && this.groupManager.table.modExists("moveRow")) {
    		this.groupManager.table.modules.moveRow.initializeGroupHeader(this);
    	}
    };

    Group.prototype.createValueGroups = function () {
    	var _this68 = this;

    	var level = this.level + 1;
    	if (this.groupManager.allowedValues && this.groupManager.allowedValues[level]) {
    		this.groupManager.allowedValues[level].forEach(function (value) {
    			_this68._createGroup(value, level);
    		});
    	}
    };

    Group.prototype.addBindings = function () {
    	var self = this,
    	    dblTap,
    	    tapHold,
    	    tap,
    	    toggleElement;

    	//handle group click events
    	if (self.groupManager.table.options.groupClick) {
    		self.element.addEventListener("click", function (e) {
    			self.groupManager.table.options.groupClick.call(self.groupManager.table, e, self.getComponent());
    		});
    	}

    	if (self.groupManager.table.options.groupDblClick) {
    		self.element.addEventListener("dblclick", function (e) {
    			self.groupManager.table.options.groupDblClick.call(self.groupManager.table, e, self.getComponent());
    		});
    	}

    	if (self.groupManager.table.options.groupContext) {
    		self.element.addEventListener("contextmenu", function (e) {
    			self.groupManager.table.options.groupContext.call(self.groupManager.table, e, self.getComponent());
    		});
    	}

    	if ((self.groupManager.table.options.groupContextMenu || self.groupManager.table.options.groupClickMenu) && self.groupManager.table.modExists("menu")) {
    		self.groupManager.table.modules.menu.initializeGroup.call(self.groupManager.table.modules.menu, self);
    	}

    	if (self.groupManager.table.options.groupTap) {

    		tap = false;

    		self.element.addEventListener("touchstart", function (e) {
    			tap = true;
    		}, { passive: true });

    		self.element.addEventListener("touchend", function (e) {
    			if (tap) {
    				self.groupManager.table.options.groupTap(e, self.getComponent());
    			}

    			tap = false;
    		});
    	}

    	if (self.groupManager.table.options.groupDblTap) {

    		dblTap = null;

    		self.element.addEventListener("touchend", function (e) {

    			if (dblTap) {
    				clearTimeout(dblTap);
    				dblTap = null;

    				self.groupManager.table.options.groupDblTap(e, self.getComponent());
    			} else {

    				dblTap = setTimeout(function () {
    					clearTimeout(dblTap);
    					dblTap = null;
    				}, 300);
    			}
    		});
    	}

    	if (self.groupManager.table.options.groupTapHold) {

    		tapHold = null;

    		self.element.addEventListener("touchstart", function (e) {
    			clearTimeout(tapHold);

    			tapHold = setTimeout(function () {
    				clearTimeout(tapHold);
    				tapHold = null;
    				tap = false;
    				self.groupManager.table.options.groupTapHold(e, self.getComponent());
    			}, 1000);
    		}, { passive: true });

    		self.element.addEventListener("touchend", function (e) {
    			clearTimeout(tapHold);
    			tapHold = null;
    		});
    	}

    	if (self.groupManager.table.options.groupToggleElement) {
    		toggleElement = self.groupManager.table.options.groupToggleElement == "arrow" ? self.arrowElement : self.element;

    		toggleElement.addEventListener("click", function (e) {
    			e.stopPropagation();
    			e.stopImmediatePropagation();
    			self.toggleVisibility();
    		});
    	}
    };

    Group.prototype._createGroup = function (groupID, level) {
    	var groupKey = level + "_" + groupID;
    	var group = new Group(this.groupManager, this, level, groupID, this.groupManager.groupIDLookups[level].field, this.groupManager.headerGenerator[level] || this.groupManager.headerGenerator[0], this.old ? this.old.groups[groupKey] : false);

    	this.groups[groupKey] = group;
    	this.groupList.push(group);
    };

    Group.prototype._addRowToGroup = function (row) {

    	var level = this.level + 1;

    	if (this.hasSubGroups) {
    		var groupID = this.groupManager.groupIDLookups[level].func(row.getData()),
    		    groupKey = level + "_" + groupID;

    		if (this.groupManager.allowedValues && this.groupManager.allowedValues[level]) {
    			if (this.groups[groupKey]) {
    				this.groups[groupKey].addRow(row);
    			}
    		} else {
    			if (!this.groups[groupKey]) {
    				this._createGroup(groupID, level);
    			}

    			this.groups[groupKey].addRow(row);
    		}
    	}
    };

    Group.prototype._addRow = function (row) {
    	this.rows.push(row);
    	row.modules.group = this;
    };

    Group.prototype.insertRow = function (row, to, after) {
    	var data = this.conformRowData({});

    	row.updateData(data);

    	var toIndex = this.rows.indexOf(to);

    	if (toIndex > -1) {
    		if (after) {
    			this.rows.splice(toIndex + 1, 0, row);
    		} else {
    			this.rows.splice(toIndex, 0, row);
    		}
    	} else {
    		if (after) {
    			this.rows.push(row);
    		} else {
    			this.rows.unshift(row);
    		}
    	}

    	row.modules.group = this;

    	this.generateGroupHeaderContents();

    	if (this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.options.columnCalcs != "table") {
    		this.groupManager.table.modules.columnCalcs.recalcGroup(this);
    	}

    	this.groupManager.updateGroupRows(true);
    };

    Group.prototype.scrollHeader = function (left) {
    	this.arrowElement.style.marginLeft = left;

    	this.groupList.forEach(function (child) {
    		child.scrollHeader(left);
    	});
    };

    Group.prototype.getRowIndex = function (row) {};

    //update row data to match grouping contraints
    Group.prototype.conformRowData = function (data) {
    	if (this.field) {
    		data[this.field] = this.key;
    	} else {
    		console.warn("Data Conforming Error - Cannot conform row data to match new group as groupBy is a function");
    	}

    	if (this.parent) {
    		data = this.parent.conformRowData(data);
    	}

    	return data;
    };

    Group.prototype.removeRow = function (row) {
    	var index = this.rows.indexOf(row);
    	var el = row.getElement();

    	if (index > -1) {
    		this.rows.splice(index, 1);
    	}

    	if (!this.groupManager.table.options.groupValues && !this.rows.length) {
    		if (this.parent) {
    			this.parent.removeGroup(this);
    		} else {
    			this.groupManager.removeGroup(this);
    		}

    		this.groupManager.updateGroupRows(true);
    	} else {

    		if (el.parentNode) {
    			el.parentNode.removeChild(el);
    		}

    		this.generateGroupHeaderContents();

    		if (this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.options.columnCalcs != "table") {
    			this.groupManager.table.modules.columnCalcs.recalcGroup(this);
    		}
    	}
    };

    Group.prototype.removeGroup = function (group) {
    	var groupKey = group.level + "_" + group.key,
    	    index;

    	if (this.groups[groupKey]) {
    		delete this.groups[groupKey];

    		index = this.groupList.indexOf(group);

    		if (index > -1) {
    			this.groupList.splice(index, 1);
    		}

    		if (!this.groupList.length) {
    			if (this.parent) {
    				this.parent.removeGroup(this);
    			} else {
    				this.groupManager.removeGroup(this);
    			}
    		}
    	}
    };

    Group.prototype.getHeadersAndRows = function (noCalc) {
    	var output = [];

    	output.push(this);

    	this._visSet();

    	if (this.visible) {
    		if (this.groupList.length) {
    			this.groupList.forEach(function (group) {
    				output = output.concat(group.getHeadersAndRows(noCalc));
    			});
    		} else {
    			if (!noCalc && this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.modules.columnCalcs.hasTopCalcs()) {
    				if (this.calcs.top) {
    					this.calcs.top.detachElement();
    					this.calcs.top.deleteCells();
    				}

    				this.calcs.top = this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows);
    				output.push(this.calcs.top);
    			}

    			output = output.concat(this.rows);

    			if (!noCalc && this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.modules.columnCalcs.hasBottomCalcs()) {
    				if (this.calcs.bottom) {
    					this.calcs.bottom.detachElement();
    					this.calcs.bottom.deleteCells();
    				}

    				this.calcs.bottom = this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows);
    				output.push(this.calcs.bottom);
    			}
    		}
    	} else {
    		if (!this.groupList.length && this.groupManager.table.options.columnCalcs != "table") {

    			if (this.groupManager.table.modExists("columnCalcs")) {

    				if (!noCalc && this.groupManager.table.modules.columnCalcs.hasTopCalcs()) {
    					if (this.calcs.top) {
    						this.calcs.top.detachElement();
    						this.calcs.top.deleteCells();
    					}

    					if (this.groupManager.table.options.groupClosedShowCalcs) {
    						this.calcs.top = this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows);
    						output.push(this.calcs.top);
    					}
    				}

    				if (!noCalc && this.groupManager.table.modules.columnCalcs.hasBottomCalcs()) {
    					if (this.calcs.bottom) {
    						this.calcs.bottom.detachElement();
    						this.calcs.bottom.deleteCells();
    					}

    					if (this.groupManager.table.options.groupClosedShowCalcs) {
    						this.calcs.bottom = this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows);
    						output.push(this.calcs.bottom);
    					}
    				}
    			}
    		}
    	}

    	return output;
    };

    Group.prototype.getData = function (visible, transform) {
    	var output = [];

    	this._visSet();

    	if (!visible || visible && this.visible) {
    		this.rows.forEach(function (row) {
    			output.push(row.getData(transform || "data"));
    		});
    	}

    	return output;
    };

    // Group.prototype.getRows = function(){
    // 	this._visSet();

    // 	return this.visible ? this.rows : [];
    // };

    Group.prototype.getRowCount = function () {
    	var count = 0;

    	if (this.groupList.length) {
    		this.groupList.forEach(function (group) {
    			count += group.getRowCount();
    		});
    	} else {
    		count = this.rows.length;
    	}
    	return count;
    };

    Group.prototype.toggleVisibility = function () {
    	if (this.visible) {
    		this.hide();
    	} else {
    		this.show();
    	}
    };

    Group.prototype.hide = function () {
    	this.visible = false;

    	if (this.groupManager.table.rowManager.getRenderMode() == "classic" && !this.groupManager.table.options.pagination) {

    		this.element.classList.remove("tabulator-group-visible");

    		if (this.groupList.length) {
    			this.groupList.forEach(function (group) {

    				var rows = group.getHeadersAndRows();

    				rows.forEach(function (row) {
    					row.detachElement();
    				});
    			});
    		} else {
    			this.rows.forEach(function (row) {
    				var rowEl = row.getElement();
    				rowEl.parentNode.removeChild(rowEl);
    			});
    		}

    		this.groupManager.table.rowManager.setDisplayRows(this.groupManager.updateGroupRows(), this.groupManager.getDisplayIndex());

    		this.groupManager.table.rowManager.checkClassicModeGroupHeaderWidth();
    	} else {
    		this.groupManager.updateGroupRows(true);
    	}

    	this.groupManager.table.options.groupVisibilityChanged.call(this.table, this.getComponent(), false);
    };

    Group.prototype.show = function () {
    	var self = this;

    	self.visible = true;

    	if (this.groupManager.table.rowManager.getRenderMode() == "classic" && !this.groupManager.table.options.pagination) {

    		this.element.classList.add("tabulator-group-visible");

    		var prev = self.getElement();

    		if (this.groupList.length) {
    			this.groupList.forEach(function (group) {
    				var rows = group.getHeadersAndRows();

    				rows.forEach(function (row) {
    					var rowEl = row.getElement();
    					prev.parentNode.insertBefore(rowEl, prev.nextSibling);
    					row.initialize();
    					prev = rowEl;
    				});
    			});
    		} else {
    			self.rows.forEach(function (row) {
    				var rowEl = row.getElement();
    				prev.parentNode.insertBefore(rowEl, prev.nextSibling);
    				row.initialize();
    				prev = rowEl;
    			});
    		}

    		this.groupManager.table.rowManager.setDisplayRows(this.groupManager.updateGroupRows(), this.groupManager.getDisplayIndex());

    		this.groupManager.table.rowManager.checkClassicModeGroupHeaderWidth();
    	} else {
    		this.groupManager.updateGroupRows(true);
    	}

    	this.groupManager.table.options.groupVisibilityChanged.call(this.table, this.getComponent(), true);
    };

    Group.prototype._visSet = function () {
    	var data = [];

    	if (typeof this.visible == "function") {

    		this.rows.forEach(function (row) {
    			data.push(row.getData());
    		});

    		this.visible = this.visible(this.key, this.getRowCount(), data, this.getComponent());
    	}
    };

    Group.prototype.getRowGroup = function (row) {
    	var match = false;
    	if (this.groupList.length) {
    		this.groupList.forEach(function (group) {
    			var result = group.getRowGroup(row);

    			if (result) {
    				match = result;
    			}
    		});
    	} else {
    		if (this.rows.find(function (item) {
    			return item === row;
    		})) {
    			match = this;
    		}
    	}

    	return match;
    };

    Group.prototype.getSubGroups = function (component) {
    	var output = [];

    	this.groupList.forEach(function (child) {
    		output.push(component ? child.getComponent() : child);
    	});

    	return output;
    };

    Group.prototype.getRows = function (compoment) {
    	var output = [];

    	this.rows.forEach(function (row) {
    		output.push(compoment ? row.getComponent() : row);
    	});

    	return output;
    };

    Group.prototype.generateGroupHeaderContents = function () {
    	var data = [];

    	this.rows.forEach(function (row) {
    		data.push(row.getData());
    	});

    	this.elementContents = this.generator(this.key, this.getRowCount(), data, this.getComponent());

    	while (this.element.firstChild) {
    		this.element.removeChild(this.element.firstChild);
    	}if (typeof this.elementContents === "string") {
    		this.element.innerHTML = this.elementContents;
    	} else {
    		this.element.appendChild(this.elementContents);
    	}

    	this.element.insertBefore(this.arrowElement, this.element.firstChild);
    };

    Group.prototype.getPath = function () {
    	var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    	path.unshift(this.key);
    	if (this.parent) {
    		this.parent.getPath(path);
    	}
    	return path;
    };
    ////////////// Standard Row Functions //////////////

    Group.prototype.getElement = function () {
    	this.addBindingsd = false;

    	this._visSet();

    	if (this.visible) {
    		this.element.classList.add("tabulator-group-visible");
    	} else {
    		this.element.classList.remove("tabulator-group-visible");
    	}

    	for (var i = 0; i < this.element.childNodes.length; ++i) {
    		this.element.childNodes[i].parentNode.removeChild(this.element.childNodes[i]);
    	}

    	this.generateGroupHeaderContents();

    	// this.addBindings();

    	return this.element;
    };

    Group.prototype.detachElement = function () {
    	if (this.element && this.element.parentNode) {
    		this.element.parentNode.removeChild(this.element);
    	}
    };

    //normalize the height of elements in the row
    Group.prototype.normalizeHeight = function () {
    	this.setHeight(this.element.clientHeight);
    };

    Group.prototype.initialize = function (force) {
    	if (!this.initialized || force) {
    		this.normalizeHeight();
    		this.initialized = true;
    	}
    };

    Group.prototype.reinitialize = function () {
    	this.initialized = false;
    	this.height = 0;

    	if (Tabulator.prototype.helpers.elVisible(this.element)) {
    		this.initialize(true);
    	}
    };

    Group.prototype.setHeight = function (height) {
    	if (this.height != height) {
    		this.height = height;
    		this.outerHeight = this.element.offsetHeight;
    	}
    };

    //return rows outer height
    Group.prototype.getHeight = function () {
    	return this.outerHeight;
    };

    Group.prototype.getGroup = function () {
    	return this;
    };

    Group.prototype.reinitializeHeight = function () {};
    Group.prototype.calcHeight = function () {};
    Group.prototype.setCellHeight = function () {};
    Group.prototype.clearCellHeight = function () {};

    //////////////// Object Generation /////////////////
    Group.prototype.getComponent = function () {
    	if (!this.component) {
    		this.component = new GroupComponent(this);
    	}

    	return this.component;
    };

    //////////////////////////////////////////////////
    ////////////// Group Row Extension ///////////////
    //////////////////////////////////////////////////

    var GroupRows = function GroupRows(table) {

    	this.table = table; //hold Tabulator object

    	this.groupIDLookups = false; //enable table grouping and set field to group by
    	this.startOpen = [function () {
    		return false;
    	}]; //starting state of group
    	this.headerGenerator = [function () {
    		return "";
    	}];
    	this.groupList = []; //ordered list of groups
    	this.allowedValues = false;
    	this.groups = {}; //hold row groups
    	this.displayIndex = 0; //index in display pipeline
    };

    //initialize group configuration
    GroupRows.prototype.initialize = function () {
    	var self = this,
    	    groupBy = self.table.options.groupBy,
    	    startOpen = self.table.options.groupStartOpen,
    	    groupHeader = self.table.options.groupHeader;

    	this.allowedValues = self.table.options.groupValues;

    	if (Array.isArray(groupBy) && Array.isArray(groupHeader) && groupBy.length > groupHeader.length) {
    		console.warn("Error creating group headers, groupHeader array is shorter than groupBy array");
    	}

    	self.headerGenerator = [function () {
    		return "";
    	}];
    	this.startOpen = [function () {
    		return false;
    	}]; //starting state of group

    	self.table.modules.localize.bind("groups|item", function (langValue, lang) {
    		self.headerGenerator[0] = function (value, count, data) {
    			//header layout function
    			return (typeof value === "undefined" ? "" : value) + "<span>(" + count + " " + (count === 1 ? langValue : lang.groups.items) + ")</span>";
    		};
    	});

    	this.groupIDLookups = [];

    	if (Array.isArray(groupBy) || groupBy) {
    		if (this.table.modExists("columnCalcs") && this.table.options.columnCalcs != "table" && this.table.options.columnCalcs != "both") {
    			this.table.modules.columnCalcs.removeCalcs();
    		}
    	} else {
    		if (this.table.modExists("columnCalcs") && this.table.options.columnCalcs != "group") {

    			var cols = this.table.columnManager.getRealColumns();

    			cols.forEach(function (col) {
    				if (col.definition.topCalc) {
    					self.table.modules.columnCalcs.initializeTopRow();
    				}

    				if (col.definition.bottomCalc) {
    					self.table.modules.columnCalcs.initializeBottomRow();
    				}
    			});
    		}
    	}

    	if (!Array.isArray(groupBy)) {
    		groupBy = [groupBy];
    	}

    	groupBy.forEach(function (group, i) {
    		var lookupFunc, column;

    		if (typeof group == "function") {
    			lookupFunc = group;
    		} else {
    			column = self.table.columnManager.getColumnByField(group);

    			if (column) {
    				lookupFunc = function lookupFunc(data) {
    					return column.getFieldValue(data);
    				};
    			} else {
    				lookupFunc = function lookupFunc(data) {
    					return data[group];
    				};
    			}
    		}

    		self.groupIDLookups.push({
    			field: typeof group === "function" ? false : group,
    			func: lookupFunc,
    			values: self.allowedValues ? self.allowedValues[i] : false
    		});
    	});

    	if (startOpen) {

    		if (!Array.isArray(startOpen)) {
    			startOpen = [startOpen];
    		}

    		startOpen.forEach(function (level) {
    		});

    		self.startOpen = startOpen;
    	}

    	if (groupHeader) {
    		self.headerGenerator = Array.isArray(groupHeader) ? groupHeader : [groupHeader];
    	}

    	this.initialized = true;
    };

    GroupRows.prototype.setDisplayIndex = function (index) {
    	this.displayIndex = index;
    };

    GroupRows.prototype.getDisplayIndex = function () {
    	return this.displayIndex;
    };

    //return appropriate rows with group headers
    GroupRows.prototype.getRows = function (rows) {
    	if (this.groupIDLookups.length) {

    		this.table.options.dataGrouping.call(this.table);

    		this.generateGroups(rows);

    		if (this.table.options.dataGrouped) {
    			this.table.options.dataGrouped.call(this.table, this.getGroups(true));
    		}

    		return this.updateGroupRows();
    	} else {
    		return rows.slice(0);
    	}
    };

    GroupRows.prototype.getGroups = function (compoment) {
    	var groupComponents = [];

    	this.groupList.forEach(function (group) {
    		groupComponents.push(compoment ? group.getComponent() : group);
    	});

    	return groupComponents;
    };

    GroupRows.prototype.getChildGroups = function (group) {
    	var _this69 = this;

    	var groupComponents = [];

    	if (!group) {
    		group = this;
    	}

    	group.groupList.forEach(function (child) {
    		if (child.groupList.length) {
    			groupComponents = groupComponents.concat(_this69.getChildGroups(child));
    		} else {
    			groupComponents.push(child);
    		}
    	});

    	return groupComponents;
    };

    GroupRows.prototype.wipe = function () {
    	this.groupList.forEach(function (group) {
    		group.wipe();
    	});
    };

    GroupRows.prototype.pullGroupListData = function (groupList) {
    	var self = this;
    	var groupListData = [];

    	groupList.forEach(function (group) {
    		var groupHeader = {};
    		groupHeader.level = 0;
    		groupHeader.rowCount = 0;
    		groupHeader.headerContent = "";
    		var childData = [];

    		if (group.hasSubGroups) {
    			childData = self.pullGroupListData(group.groupList);

    			groupHeader.level = group.level;
    			groupHeader.rowCount = childData.length - group.groupList.length; // data length minus number of sub-headers
    			groupHeader.headerContent = group.generator(group.key, groupHeader.rowCount, group.rows, group);

    			groupListData.push(groupHeader);
    			groupListData = groupListData.concat(childData);
    		} else {
    			groupHeader.level = group.level;
    			groupHeader.headerContent = group.generator(group.key, group.rows.length, group.rows, group);
    			groupHeader.rowCount = group.getRows().length;

    			groupListData.push(groupHeader);

    			group.getRows().forEach(function (row) {
    				groupListData.push(row.getData("data"));
    			});
    		}
    	});

    	return groupListData;
    };

    GroupRows.prototype.getGroupedData = function () {

    	return this.pullGroupListData(this.groupList);
    };

    GroupRows.prototype.getRowGroup = function (row) {
    	var match = false;

    	this.groupList.forEach(function (group) {
    		var result = group.getRowGroup(row);

    		if (result) {
    			match = result;
    		}
    	});

    	return match;
    };

    GroupRows.prototype.countGroups = function () {
    	return this.groupList.length;
    };

    GroupRows.prototype.generateGroups = function (rows) {
    	var self = this,
    	    oldGroups = self.groups;

    	self.groups = {};
    	self.groupList = [];

    	if (this.allowedValues && this.allowedValues[0]) {
    		this.allowedValues[0].forEach(function (value) {
    			self.createGroup(value, 0, oldGroups);
    		});

    		rows.forEach(function (row) {
    			self.assignRowToExistingGroup(row, oldGroups);
    		});
    	} else {
    		rows.forEach(function (row) {
    			self.assignRowToGroup(row, oldGroups);
    		});
    	}
    };

    GroupRows.prototype.createGroup = function (groupID, level, oldGroups) {
    	var groupKey = level + "_" + groupID,
    	    group;

    	oldGroups = oldGroups || [];

    	group = new Group(this, false, level, groupID, this.groupIDLookups[0].field, this.headerGenerator[0], oldGroups[groupKey]);

    	this.groups[groupKey] = group;
    	this.groupList.push(group);
    };

    // GroupRows.prototype.assignRowToGroup = function(row, oldGroups){
    // 	var groupID = this.groupIDLookups[0].func(row.getData()),
    // 	groupKey = "0_" + groupID;

    // 	if(!this.groups[groupKey]){
    // 		this.createGroup(groupID, 0, oldGroups);
    // 	}

    // 	this.groups[groupKey].addRow(row);
    // };

    GroupRows.prototype.assignRowToExistingGroup = function (row, oldGroups) {
    	var groupID = this.groupIDLookups[0].func(row.getData()),
    	    groupKey = "0_" + groupID;

    	if (this.groups[groupKey]) {
    		this.groups[groupKey].addRow(row);
    	}
    };

    GroupRows.prototype.assignRowToGroup = function (row, oldGroups) {
    	var groupID = this.groupIDLookups[0].func(row.getData()),
    	    newGroupNeeded = !this.groups["0_" + groupID];

    	if (newGroupNeeded) {
    		this.createGroup(groupID, 0, oldGroups);
    	}

    	this.groups["0_" + groupID].addRow(row);

    	return !newGroupNeeded;
    };

    GroupRows.prototype.reassignRowToGroup = function (row) {
    	var oldRowGroup = row.getGroup(),
    	    oldGroupPath = oldRowGroup.getPath(),
    	    newGroupPath = this.getExpectedPath(row),
    	    samePath = true;
    	// figure out if new group path is the same as old group path
    	var samePath = oldGroupPath.length == newGroupPath.length && oldGroupPath.every(function (element, index) {
    		return element === newGroupPath[index];
    	});
    	// refresh if they new path and old path aren't the same (aka the row's groupings have changed)
    	if (!samePath) {
    		oldRowGroup.removeRow(row);
    		this.assignRowToGroup(row, self.groups);
    		this.table.rowManager.refreshActiveData("group", false, true);
    	}
    };

    GroupRows.prototype.getExpectedPath = function (row) {
    	var groupPath = [],
    	    rowData = row.getData();
    	this.groupIDLookups.forEach(function (groupId) {
    		groupPath.push(groupId.func(rowData));
    	});
    	return groupPath;
    };

    GroupRows.prototype.updateGroupRows = function (force) {
    	var self = this,
    	    output = [];

    	self.groupList.forEach(function (group) {
    		output = output.concat(group.getHeadersAndRows());
    	});

    	//force update of table display
    	if (force) {

    		var displayIndex = self.table.rowManager.setDisplayRows(output, this.getDisplayIndex());

    		if (displayIndex !== true) {
    			this.setDisplayIndex(displayIndex);
    		}

    		self.table.rowManager.refreshActiveData("group", true, true);
    	}

    	return output;
    };

    GroupRows.prototype.scrollHeaders = function (left) {
    	if (this.table.options.virtualDomHoz) {
    		left -= this.table.vdomHoz.vDomPadLeft;
    	}

    	left = left + "px";

    	this.groupList.forEach(function (group) {
    		group.scrollHeader(left);
    	});
    };

    GroupRows.prototype.removeGroup = function (group) {
    	var groupKey = group.level + "_" + group.key,
    	    index;

    	if (this.groups[groupKey]) {
    		delete this.groups[groupKey];

    		index = this.groupList.indexOf(group);

    		if (index > -1) {
    			this.groupList.splice(index, 1);
    		}
    	}
    };

    Tabulator.prototype.registerModule("groupRows", GroupRows);
    var History = function History(table) {
    	this.table = table; //hold Tabulator object

    	this.history = [];
    	this.index = -1;
    };

    History.prototype.clear = function () {
    	this.history = [];
    	this.index = -1;
    };

    History.prototype.action = function (type, component, data) {

    	this.history = this.history.slice(0, this.index + 1);

    	this.history.push({
    		type: type,
    		component: component,
    		data: data
    	});

    	this.index++;
    };

    History.prototype.getHistoryUndoSize = function () {
    	return this.index + 1;
    };

    History.prototype.getHistoryRedoSize = function () {
    	return this.history.length - (this.index + 1);
    };

    History.prototype.clearComponentHistory = function (component) {
    	var index = this.history.findIndex(function (item) {
    		return item.component === component;
    	});

    	if (index > -1) {
    		this.history.splice(index, 1);
    		if (index <= this.index) {
    			this.index--;
    		}

    		this.clearComponentHistory(component);
    	}
    };

    History.prototype.undo = function () {

    	if (this.index > -1) {
    		var action = this.history[this.index];

    		this.undoers[action.type].call(this, action);

    		this.index--;

    		this.table.options.historyUndo.call(this.table, action.type, action.component.getComponent(), action.data);

    		return true;
    	} else {
    		console.warn("History Undo Error - No more history to undo");
    		return false;
    	}
    };

    History.prototype.redo = function () {
    	if (this.history.length - 1 > this.index) {

    		this.index++;

    		var action = this.history[this.index];

    		this.redoers[action.type].call(this, action);

    		this.table.options.historyRedo.call(this.table, action.type, action.component.getComponent(), action.data);

    		return true;
    	} else {
    		console.warn("History Redo Error - No more history to redo");
    		return false;
    	}
    };

    History.prototype.undoers = {
    	cellEdit: function cellEdit(action) {
    		action.component.setValueProcessData(action.data.oldValue);
    	},

    	rowAdd: function rowAdd(action) {
    		action.component.deleteActual();
    	},

    	rowDelete: function rowDelete(action) {
    		var newRow = this.table.rowManager.addRowActual(action.data.data, action.data.pos, action.data.index);

    		if (this.table.options.groupBy && this.table.modExists("groupRows")) {
    			this.table.modules.groupRows.updateGroupRows(true);
    		}

    		this._rebindRow(action.component, newRow);
    	},

    	rowMove: function rowMove(action) {
    		this.table.rowManager.moveRowActual(action.component, this.table.rowManager.rows[action.data.posFrom], !action.data.after);
    		this.table.rowManager.redraw();
    	}
    };

    History.prototype.redoers = {
    	cellEdit: function cellEdit(action) {
    		action.component.setValueProcessData(action.data.newValue);
    	},

    	rowAdd: function rowAdd(action) {
    		var newRow = this.table.rowManager.addRowActual(action.data.data, action.data.pos, action.data.index);

    		if (this.table.options.groupBy && this.table.modExists("groupRows")) {
    			this.table.modules.groupRows.updateGroupRows(true);
    		}

    		this._rebindRow(action.component, newRow);
    	},

    	rowDelete: function rowDelete(action) {
    		action.component.deleteActual();
    	},

    	rowMove: function rowMove(action) {
    		this.table.rowManager.moveRowActual(action.component, this.table.rowManager.rows[action.data.posTo], action.data.after);
    		this.table.rowManager.redraw();
    	}
    };

    //rebind rows to new element after deletion
    History.prototype._rebindRow = function (oldRow, newRow) {
    	this.history.forEach(function (action) {
    		if (action.component instanceof Row) {
    			if (action.component === oldRow) {
    				action.component = newRow;
    			}
    		} else if (action.component instanceof Cell) {
    			if (action.component.row === oldRow) {
    				var field = action.component.column.getField();

    				if (field) {
    					action.component = newRow.getCell(field);
    				}
    			}
    		}
    	});
    };

    Tabulator.prototype.registerModule("history", History);
    var HtmlTableImport = function HtmlTableImport(table) {
    	this.table = table; //hold Tabulator object
    	this.fieldIndex = [];
    	this.hasIndex = false;
    };

    HtmlTableImport.prototype.parseTable = function () {
    	var self = this,
    	    element = self.table.element,
    	    options = self.table.options;
    	    options.columns;
    	    var headers = element.getElementsByTagName("th"),
    	    rows = element.getElementsByTagName("tbody")[0],
    	    data = [];

    	self.hasIndex = false;

    	self.table.options.htmlImporting.call(this.table);

    	rows = rows ? rows.getElementsByTagName("tr") : [];

    	//check for tablator inline options
    	self._extractOptions(element, options);

    	if (headers.length) {
    		self._extractHeaders(headers, rows);
    	} else {
    		self._generateBlankHeaders(headers, rows);
    	}

    	//iterate through table rows and build data set
    	for (var index = 0; index < rows.length; index++) {
    		var row = rows[index],
    		    cells = row.getElementsByTagName("td"),
    		    item = {};

    		//create index if the dont exist in table
    		if (!self.hasIndex) {
    			item[options.index] = index;
    		}

    		for (var i = 0; i < cells.length; i++) {
    			var cell = cells[i];
    			if (typeof this.fieldIndex[i] !== "undefined") {
    				item[this.fieldIndex[i]] = cell.innerHTML;
    			}
    		}

    		//add row data to item
    		data.push(item);
    	}

    	//create new element
    	var newElement = document.createElement("div");

    	//transfer attributes to new element
    	var attributes = element.attributes;

    	// loop through attributes and apply them on div

    	for (var i in attributes) {
    		if (_typeof(attributes[i]) == "object") {
    			newElement.setAttribute(attributes[i].name, attributes[i].value);
    		}
    	}

    	// replace table with div element
    	element.parentNode.replaceChild(newElement, element);

    	options.data = data;

    	self.table.options.htmlImported.call(this.table);

    	// // newElement.tabulator(options);

    	this.table.element = newElement;
    };

    //extract tabulator attribute options
    HtmlTableImport.prototype._extractOptions = function (element, options, defaultOptions) {
    	var attributes = element.attributes;
    	var optionsArr = defaultOptions ? Object.assign([], defaultOptions) : Object.keys(options);
    	var optionsList = {};

    	optionsArr.forEach(function (item) {
    		optionsList[item.toLowerCase()] = item;
    	});

    	for (var index in attributes) {
    		var attrib = attributes[index];
    		var name;

    		if (attrib && (typeof attrib === 'undefined' ? 'undefined' : _typeof(attrib)) == "object" && attrib.name && attrib.name.indexOf("tabulator-") === 0) {
    			name = attrib.name.replace("tabulator-", "");

    			if (typeof optionsList[name] !== "undefined") {
    				options[optionsList[name]] = this._attribValue(attrib.value);
    			}
    		}
    	}
    };

    //get value of attribute
    HtmlTableImport.prototype._attribValue = function (value) {
    	if (value === "true") {
    		return true;
    	}

    	if (value === "false") {
    		return false;
    	}

    	return value;
    };

    //find column if it has already been defined
    HtmlTableImport.prototype._findCol = function (title) {
    	var match = this.table.options.columns.find(function (column) {
    		return column.title === title;
    	});

    	return match || false;
    };

    //extract column from headers
    HtmlTableImport.prototype._extractHeaders = function (headers, rows) {
    	for (var index = 0; index < headers.length; index++) {
    		var header = headers[index],
    		    exists = false,
    		    col = this._findCol(header.textContent),
    		    width;

    		if (col) {
    			exists = true;
    		} else {
    			col = { title: header.textContent.trim() };
    		}

    		if (!col.field) {
    			col.field = header.textContent.trim().toLowerCase().replace(" ", "_");
    		}

    		width = header.getAttribute("width");

    		if (width && !col.width) {
    			col.width = width;
    		}

    		// //check for tablator inline options
    		this._extractOptions(header, col, Column.prototype.defaultOptionList);

    		this.fieldIndex[index] = col.field;

    		if (col.field == this.table.options.index) {
    			this.hasIndex = true;
    		}

    		if (!exists) {
    			this.table.options.columns.push(col);
    		}
    	}
    };

    //generate blank headers
    HtmlTableImport.prototype._generateBlankHeaders = function (headers, rows) {
    	for (var index = 0; index < headers.length; index++) {
    		var header = headers[index],
    		    col = { title: "", field: "col" + index };

    		this.fieldIndex[index] = col.field;

    		var width = header.getAttribute("width");

    		if (width) {
    			col.width = width;
    		}

    		this.table.options.columns.push(col);
    	}
    };

    Tabulator.prototype.registerModule("htmlTableImport", HtmlTableImport);
    var Keybindings = function Keybindings(table) {
    	this.table = table; //hold Tabulator object
    	this.watchKeys = null;
    	this.pressedKeys = null;
    	this.keyupBinding = false;
    	this.keydownBinding = false;
    };

    Keybindings.prototype.initialize = function () {
    	var bindings = this.table.options.keybindings,
    	    mergedBindings = {};

    	this.watchKeys = {};
    	this.pressedKeys = [];

    	if (bindings !== false) {

    		for (var key in this.bindings) {
    			mergedBindings[key] = this.bindings[key];
    		}

    		if (Object.keys(bindings).length) {

    			for (var _key in bindings) {
    				mergedBindings[_key] = bindings[_key];
    			}
    		}

    		this.mapBindings(mergedBindings);
    		this.bindEvents();
    	}
    };

    Keybindings.prototype.mapBindings = function (bindings) {
    	var _this70 = this;

    	var self = this;

    	var _loop2 = function _loop2(key) {

    		if (_this70.actions[key]) {

    			if (bindings[key]) {

    				if (_typeof(bindings[key]) !== "object") {
    					bindings[key] = [bindings[key]];
    				}

    				bindings[key].forEach(function (binding) {
    					self.mapBinding(key, binding);
    				});
    			}
    		} else {
    			console.warn("Key Binding Error - no such action:", key);
    		}
    	};

    	for (var key in bindings) {
    		_loop2(key);
    	}
    };

    Keybindings.prototype.mapBinding = function (action, symbolsList) {
    	var self = this;

    	var binding = {
    		action: this.actions[action],
    		keys: [],
    		ctrl: false,
    		shift: false,
    		meta: false
    	};

    	var symbols = symbolsList.toString().toLowerCase().split(" ").join("").split("+");

    	symbols.forEach(function (symbol) {
    		switch (symbol) {
    			case "ctrl":
    				binding.ctrl = true;
    				break;

    			case "shift":
    				binding.shift = true;
    				break;

    			case "meta":
    				binding.meta = true;
    				break;

    			default:
    				symbol = parseInt(symbol);
    				binding.keys.push(symbol);

    				if (!self.watchKeys[symbol]) {
    					self.watchKeys[symbol] = [];
    				}

    				self.watchKeys[symbol].push(binding);
    		}
    	});
    };

    Keybindings.prototype.bindEvents = function () {
    	var self = this;

    	this.keyupBinding = function (e) {
    		var code = e.keyCode;
    		var bindings = self.watchKeys[code];

    		if (bindings) {

    			self.pressedKeys.push(code);

    			bindings.forEach(function (binding) {
    				self.checkBinding(e, binding);
    			});
    		}
    	};

    	this.keydownBinding = function (e) {
    		var code = e.keyCode;
    		var bindings = self.watchKeys[code];

    		if (bindings) {

    			var index = self.pressedKeys.indexOf(code);

    			if (index > -1) {
    				self.pressedKeys.splice(index, 1);
    			}
    		}
    	};

    	this.table.element.addEventListener("keydown", this.keyupBinding);

    	this.table.element.addEventListener("keyup", this.keydownBinding);
    };

    Keybindings.prototype.clearBindings = function () {
    	if (this.keyupBinding) {
    		this.table.element.removeEventListener("keydown", this.keyupBinding);
    	}

    	if (this.keydownBinding) {
    		this.table.element.removeEventListener("keyup", this.keydownBinding);
    	}
    };

    Keybindings.prototype.checkBinding = function (e, binding) {
    	var self = this,
    	    match = true;

    	if (e.ctrlKey == binding.ctrl && e.shiftKey == binding.shift && e.metaKey == binding.meta) {
    		binding.keys.forEach(function (key) {
    			var index = self.pressedKeys.indexOf(key);

    			if (index == -1) {
    				match = false;
    			}
    		});

    		if (match) {
    			binding.action.call(self, e);
    		}

    		return true;
    	}

    	return false;
    };

    //default bindings
    Keybindings.prototype.bindings = {
    	navPrev: "shift + 9",
    	navNext: 9,
    	navUp: 38,
    	navDown: 40,
    	scrollPageUp: 33,
    	scrollPageDown: 34,
    	scrollToStart: 36,
    	scrollToEnd: 35,
    	undo: "ctrl + 90",
    	redo: "ctrl + 89",
    	copyToClipboard: "ctrl + 67"
    };

    //default actions
    Keybindings.prototype.actions = {
    	keyBlock: function keyBlock(e) {
    		e.stopPropagation();
    		e.preventDefault();
    	},
    	scrollPageUp: function scrollPageUp(e) {
    		var rowManager = this.table.rowManager,
    		    newPos = rowManager.scrollTop - rowManager.height;
    		    rowManager.element.scrollHeight;

    		e.preventDefault();

    		if (rowManager.displayRowsCount) {
    			if (newPos >= 0) {
    				rowManager.element.scrollTop = newPos;
    			} else {
    				rowManager.scrollToRow(rowManager.getDisplayRows()[0]);
    			}
    		}

    		this.table.element.focus();
    	},
    	scrollPageDown: function scrollPageDown(e) {
    		var rowManager = this.table.rowManager,
    		    newPos = rowManager.scrollTop + rowManager.height,
    		    scrollMax = rowManager.element.scrollHeight;

    		e.preventDefault();

    		if (rowManager.displayRowsCount) {
    			if (newPos <= scrollMax) {
    				rowManager.element.scrollTop = newPos;
    			} else {
    				rowManager.scrollToRow(rowManager.getDisplayRows()[rowManager.displayRowsCount - 1]);
    			}
    		}

    		this.table.element.focus();
    	},
    	scrollToStart: function scrollToStart(e) {
    		var rowManager = this.table.rowManager;

    		e.preventDefault();

    		if (rowManager.displayRowsCount) {
    			rowManager.scrollToRow(rowManager.getDisplayRows()[0]);
    		}

    		this.table.element.focus();
    	},
    	scrollToEnd: function scrollToEnd(e) {
    		var rowManager = this.table.rowManager;

    		e.preventDefault();

    		if (rowManager.displayRowsCount) {
    			rowManager.scrollToRow(rowManager.getDisplayRows()[rowManager.displayRowsCount - 1]);
    		}

    		this.table.element.focus();
    	},
    	navPrev: function navPrev(e) {
    		var cell = false;

    		if (this.table.modExists("edit")) {
    			cell = this.table.modules.edit.currentCell;

    			if (cell) {
    				e.preventDefault();
    				cell.nav().prev();
    			}
    		}
    	},

    	navNext: function navNext(e) {
    		var cell = false;
    		var newRow = this.table.options.tabEndNewRow;
    		var nav;

    		if (this.table.modExists("edit")) {
    			cell = this.table.modules.edit.currentCell;

    			if (cell) {
    				e.preventDefault();

    				nav = cell.nav();

    				if (!nav.next()) {
    					if (newRow) {

    						cell.getElement().firstChild.blur();

    						if (newRow === true) {
    							newRow = this.table.addRow({});
    						} else {
    							if (typeof newRow == "function") {
    								newRow = this.table.addRow(newRow(cell.row.getComponent()));
    							} else {
    								newRow = this.table.addRow(Object.assign({}, newRow));
    							}
    						}

    						newRow.then(function () {
    							setTimeout(function () {
    								nav.next();
    							});
    						});
    					}
    				}
    			}
    		}
    	},

    	navLeft: function navLeft(e) {
    		var cell = false;

    		if (this.table.modExists("edit")) {
    			cell = this.table.modules.edit.currentCell;

    			if (cell) {
    				e.preventDefault();
    				cell.nav().left();
    			}
    		}
    	},

    	navRight: function navRight(e) {
    		var cell = false;

    		if (this.table.modExists("edit")) {
    			cell = this.table.modules.edit.currentCell;

    			if (cell) {
    				e.preventDefault();
    				cell.nav().right();
    			}
    		}
    	},

    	navUp: function navUp(e) {
    		var cell = false;

    		if (this.table.modExists("edit")) {
    			cell = this.table.modules.edit.currentCell;

    			if (cell) {
    				e.preventDefault();
    				cell.nav().up();
    			}
    		}
    	},

    	navDown: function navDown(e) {
    		var cell = false;

    		if (this.table.modExists("edit")) {
    			cell = this.table.modules.edit.currentCell;

    			if (cell) {
    				e.preventDefault();
    				cell.nav().down();
    			}
    		}
    	},

    	undo: function undo(e) {
    		var cell = false;
    		if (this.table.options.history && this.table.modExists("history") && this.table.modExists("edit")) {

    			cell = this.table.modules.edit.currentCell;

    			if (!cell) {
    				e.preventDefault();
    				this.table.modules.history.undo();
    			}
    		}
    	},

    	redo: function redo(e) {
    		var cell = false;
    		if (this.table.options.history && this.table.modExists("history") && this.table.modExists("edit")) {

    			cell = this.table.modules.edit.currentCell;

    			if (!cell) {
    				e.preventDefault();
    				this.table.modules.history.redo();
    			}
    		}
    	},

    	copyToClipboard: function copyToClipboard(e) {
    		if (!this.table.modules.edit.currentCell) {
    			if (this.table.modExists("clipboard", true)) {
    				this.table.modules.clipboard.copy(false, true);
    			}
    		}
    	}
    };

    Tabulator.prototype.registerModule("keybindings", Keybindings);
    var Menu = function Menu(table) {
    	this.table = table; //hold Tabulator object
    	this.menuElements = [];
    	this.blurEvent = this.hideMenu.bind(this);
    	this.escEvent = this.escMenu.bind(this);
    	this.nestedMenuBlock = false;
    	this.positionReversedX = false;
    };

    Menu.prototype.initializeColumnHeader = function (column) {
    	var _this71 = this;

    	var headerMenuEl;

    	if (column.definition.headerContextMenu) {
    		column.getElement().addEventListener("contextmenu", this.LoadMenuEvent.bind(this, column, column.definition.headerContextMenu));
    		this.tapHold(column, column.definition.headerContextMenu);
    	}

    	// if(column.definition.headerClickMenu){
    	// 	column.getElement().addEventListener("click", this.LoadMenuEvent.bind(this, column, column.definition.headerClickMenu));
    	// }

    	if (column.definition.headerMenu) {

    		headerMenuEl = document.createElement("span");
    		headerMenuEl.classList.add("tabulator-header-menu-button");
    		headerMenuEl.innerHTML = "&vellip;";

    		headerMenuEl.addEventListener("click", function (e) {
    			e.stopPropagation();
    			e.preventDefault();

    			_this71.LoadMenuEvent(column, column.definition.headerMenu, e);
    		});

    		column.titleElement.insertBefore(headerMenuEl, column.titleElement.firstChild);
    	}
    };

    Menu.prototype.LoadMenuEvent = function (component, menu, e) {
    	menu = typeof menu == "function" ? menu.call(this.table, component.getComponent(), e) : menu;

    	// if(component instanceof Cell){
    	// 	e.stopImmediatePropagation();
    	// }

    	this.loadMenu(e, component, menu);
    };

    Menu.prototype.tapHold = function (component, menu) {
    	var _this72 = this;

    	var element = component.getElement(),
    	    tapHold = null,
    	    loaded = false;

    	element.addEventListener("touchstart", function (e) {
    		clearTimeout(tapHold);
    		loaded = false;

    		tapHold = setTimeout(function () {
    			clearTimeout(tapHold);
    			tapHold = null;
    			loaded = true;

    			_this72.LoadMenuEvent(component, menu, e);
    		}, 1000);
    	}, { passive: true });

    	element.addEventListener("touchend", function (e) {
    		clearTimeout(tapHold);
    		tapHold = null;

    		if (loaded) {
    			e.preventDefault();
    		}
    	});
    };

    Menu.prototype.initializeCell = function (cell) {
    	if (cell.column.definition.contextMenu) {
    		cell.getElement(true).addEventListener("contextmenu", this.LoadMenuEvent.bind(this, cell, cell.column.definition.contextMenu));
    		this.tapHold(cell, cell.column.definition.contextMenu);
    	}

    	if (cell.column.definition.clickMenu) {
    		cell.getElement(true).addEventListener("click", this.LoadMenuEvent.bind(this, cell, cell.column.definition.clickMenu));
    	}
    };

    Menu.prototype.initializeRow = function (row) {
    	if (this.table.options.rowContextMenu) {
    		row.getElement().addEventListener("contextmenu", this.LoadMenuEvent.bind(this, row, this.table.options.rowContextMenu));
    		this.tapHold(row, this.table.options.rowContextMenu);
    	}

    	if (this.table.options.rowClickMenu) {
    		row.getElement().addEventListener("click", this.LoadMenuEvent.bind(this, row, this.table.options.rowClickMenu));
    	}
    };

    Menu.prototype.initializeGroup = function (group) {
    	if (this.table.options.groupContextMenu) {
    		group.getElement().addEventListener("contextmenu", this.LoadMenuEvent.bind(this, group, this.table.options.groupContextMenu));
    		this.tapHold(group, this.table.options.groupContextMenu);
    	}

    	if (this.table.options.groupClickMenu) {
    		group.getElement().addEventListener("click", this.LoadMenuEvent.bind(this, group, this.table.options.groupClickMenu));
    	}
    };

    Menu.prototype.loadMenu = function (e, component, menu, parentEl) {
    	var _this73 = this;

    	var touch = !(e instanceof MouseEvent);

    	var menuEl = document.createElement("div");
    	menuEl.classList.add("tabulator-menu");

    	if (!touch) {
    		e.preventDefault();
    	}

    	//abort if no menu set
    	if (!menu || !menu.length) {
    		return;
    	}

    	if (!parentEl) {
    		if (this.nestedMenuBlock) {
    			//abort if child menu already open
    			if (this.isOpen()) {
    				return;
    			}
    		} else {
    			this.nestedMenuBlock = setTimeout(function () {
    				_this73.nestedMenuBlock = false;
    			}, 100);
    		}

    		this.hideMenu();
    		this.menuElements = [];
    	}

    	menu.forEach(function (item) {
    		var itemEl = document.createElement("div"),
    		    label = item.label,
    		    disabled = item.disabled;

    		if (item.separator) {
    			itemEl.classList.add("tabulator-menu-separator");
    		} else {
    			itemEl.classList.add("tabulator-menu-item");

    			if (typeof label == "function") {
    				label = label.call(_this73.table, component.getComponent());
    			}

    			if (label instanceof Node) {
    				itemEl.appendChild(label);
    			} else {
    				itemEl.innerHTML = label;
    			}

    			if (typeof disabled == "function") {
    				disabled = disabled.call(_this73.table, component.getComponent());
    			}

    			if (disabled) {
    				itemEl.classList.add("tabulator-menu-item-disabled");
    				itemEl.addEventListener("click", function (e) {
    					e.stopPropagation();
    				});
    			} else {
    				if (item.menu && item.menu.length) {
    					itemEl.addEventListener("click", function (e) {
    						e.stopPropagation();
    						_this73.hideOldSubMenus(menuEl);
    						_this73.loadMenu(e, component, item.menu, itemEl);
    					});
    				} else {
    					if (item.action) {
    						itemEl.addEventListener("click", function (e) {
    							item.action(e, component.getComponent());
    						});
    					}
    				}
    			}

    			if (item.menu && item.menu.length) {
    				itemEl.classList.add("tabulator-menu-item-submenu");
    			}
    		}

    		menuEl.appendChild(itemEl);
    	});

    	menuEl.addEventListener("click", function (e) {
    		_this73.hideMenu();
    	});

    	this.menuElements.push(menuEl);
    	this.positionMenu(menuEl, parentEl, touch, e);
    };

    Menu.prototype.hideOldSubMenus = function (menuEl) {
    	var index = this.menuElements.indexOf(menuEl);

    	if (index > -1) {
    		for (var _i13 = this.menuElements.length - 1; _i13 > index; _i13--) {
    			var el = this.menuElements[_i13];

    			if (el.parentNode) {
    				el.parentNode.removeChild(el);
    			}

    			this.menuElements.pop();
    		}
    	}
    };

    Menu.prototype.positionMenu = function (element, parentEl, touch, e) {
    	var _this74 = this;

    	var docHeight = Math.max(document.body.offsetHeight, window.innerHeight),
    	    x,
    	    y,
    	    parentOffset;

    	if (!parentEl) {
    		x = touch ? e.touches[0].pageX : e.pageX;
    		y = touch ? e.touches[0].pageY : e.pageY;

    		this.positionReversedX = false;
    	} else {
    		parentOffset = Tabulator.prototype.helpers.elOffset(parentEl);
    		x = parentOffset.left + parentEl.offsetWidth;
    		y = parentOffset.top - 1;
    	}

    	element.style.top = y + "px";
    	element.style.left = x + "px";

    	setTimeout(function () {
    		_this74.table.rowManager.element.addEventListener("scroll", _this74.blurEvent);
    		document.body.addEventListener("click", _this74.blurEvent);
    		document.body.addEventListener("contextmenu", _this74.blurEvent);
    		window.addEventListener("resize", _this74.blurEvent);
    		document.body.addEventListener("keydown", _this74.escEvent);
    	}, 100);

    	document.body.appendChild(element);

    	//move menu to start on bottom edge if it is too close to the edge of the screen
    	if (y + element.offsetHeight >= docHeight) {
    		element.style.top = "";

    		if (parentEl) {
    			element.style.bottom = docHeight - parentOffset.top - parentEl.offsetHeight - 1 + "px";
    		} else {
    			element.style.bottom = docHeight - y + "px";
    		}
    	}

    	//move menu to start on right edge if it is too close to the edge of the screen
    	if (x + element.offsetWidth >= document.body.offsetWidth || this.positionReversedX) {
    		element.style.left = "";

    		if (parentEl) {
    			element.style.right = document.documentElement.offsetWidth - parentOffset.left + "px";
    		} else {
    			element.style.right = document.documentElement.offsetWidth - x + "px";
    		}

    		this.positionReversedX = true;
    	}
    };

    Menu.prototype.isOpen = function () {
    	return !!this.menuElements.length;
    };

    Menu.prototype.escMenu = function (e) {
    	if (e.keyCode == 27) {
    		this.hideMenu();
    	}
    };

    Menu.prototype.hideMenu = function () {
    	this.menuElements.forEach(function (menuEl) {
    		if (menuEl.parentNode) {
    			menuEl.parentNode.removeChild(menuEl);
    		}
    	});

    	document.body.removeEventListener("keydown", this.escEvent);
    	document.body.removeEventListener("click", this.blurEvent);
    	document.body.removeEventListener("contextmenu", this.blurEvent);
    	window.removeEventListener("resize", this.blurEvent);
    	this.table.rowManager.element.removeEventListener("scroll", this.blurEvent);
    };

    //default accessors
    Menu.prototype.menus = {};

    Tabulator.prototype.registerModule("menu", Menu);
    var MoveColumns = function MoveColumns(table) {
    	this.table = table; //hold Tabulator object
    	this.placeholderElement = this.createPlaceholderElement();
    	this.hoverElement = false; //floating column header element
    	this.checkTimeout = false; //click check timeout holder
    	this.checkPeriod = 250; //period to wait on mousedown to consider this a move and not a click
    	this.moving = false; //currently moving column
    	this.toCol = false; //destination column
    	this.toColAfter = false; //position of moving column relative to the desitnation column
    	this.startX = 0; //starting position within header element
    	this.autoScrollMargin = 40; //auto scroll on edge when within margin
    	this.autoScrollStep = 5; //auto scroll distance in pixels
    	this.autoScrollTimeout = false; //auto scroll timeout
    	this.touchMove = false;

    	this.moveHover = this.moveHover.bind(this);
    	this.endMove = this.endMove.bind(this);
    };

    MoveColumns.prototype.createPlaceholderElement = function () {
    	var el = document.createElement("div");

    	el.classList.add("tabulator-col");
    	el.classList.add("tabulator-col-placeholder");

    	return el;
    };

    MoveColumns.prototype.initializeColumn = function (column) {
    	var self = this,
    	    config = {},
    	    colEl;

    	if (!column.modules.frozen) {

    		colEl = column.getElement();

    		config.mousemove = function (e) {
    			if (column.parent === self.moving.parent) {
    				if ((self.touchMove ? e.touches[0].pageX : e.pageX) - Tabulator.prototype.helpers.elOffset(colEl).left + self.table.columnManager.element.scrollLeft > column.getWidth() / 2) {
    					if (self.toCol !== column || !self.toColAfter) {
    						colEl.parentNode.insertBefore(self.placeholderElement, colEl.nextSibling);
    						self.moveColumn(column, true);
    					}
    				} else {
    					if (self.toCol !== column || self.toColAfter) {
    						colEl.parentNode.insertBefore(self.placeholderElement, colEl);
    						self.moveColumn(column, false);
    					}
    				}
    			}
    		}.bind(self);

    		colEl.addEventListener("mousedown", function (e) {
    			self.touchMove = false;
    			if (e.which === 1) {
    				self.checkTimeout = setTimeout(function () {
    					self.startMove(e, column);
    				}, self.checkPeriod);
    			}
    		});

    		colEl.addEventListener("mouseup", function (e) {
    			if (e.which === 1) {
    				if (self.checkTimeout) {
    					clearTimeout(self.checkTimeout);
    				}
    			}
    		});

    		self.bindTouchEvents(column);
    	}

    	column.modules.moveColumn = config;
    };

    MoveColumns.prototype.bindTouchEvents = function (column) {
    	var self = this,
    	    colEl = column.getElement(),
    	    startXMove = false,
    	    nextCol,
    	    prevCol,
    	    nextColWidth,
    	    prevColWidth,
    	    nextColWidthLast,
    	    prevColWidthLast;

    	colEl.addEventListener("touchstart", function (e) {
    		self.checkTimeout = setTimeout(function () {
    			self.touchMove = true;
    			nextCol = column.nextColumn();
    			nextColWidth = nextCol ? nextCol.getWidth() / 2 : 0;
    			prevCol = column.prevColumn();
    			prevColWidth = prevCol ? prevCol.getWidth() / 2 : 0;
    			nextColWidthLast = 0;
    			prevColWidthLast = 0;
    			startXMove = false;

    			self.startMove(e, column);
    		}, self.checkPeriod);
    	}, { passive: true });

    	colEl.addEventListener("touchmove", function (e) {
    		var diff, moveToCol;

    		if (self.moving) {
    			self.moveHover(e);

    			if (!startXMove) {
    				startXMove = e.touches[0].pageX;
    			}

    			diff = e.touches[0].pageX - startXMove;

    			if (diff > 0) {
    				if (nextCol && diff - nextColWidthLast > nextColWidth) {
    					moveToCol = nextCol;

    					if (moveToCol !== column) {
    						startXMove = e.touches[0].pageX;
    						moveToCol.getElement().parentNode.insertBefore(self.placeholderElement, moveToCol.getElement().nextSibling);
    						self.moveColumn(moveToCol, true);
    					}
    				}
    			} else {
    				if (prevCol && -diff - prevColWidthLast > prevColWidth) {
    					moveToCol = prevCol;

    					if (moveToCol !== column) {
    						startXMove = e.touches[0].pageX;
    						moveToCol.getElement().parentNode.insertBefore(self.placeholderElement, moveToCol.getElement());
    						self.moveColumn(moveToCol, false);
    					}
    				}
    			}

    			if (moveToCol) {
    				nextCol = moveToCol.nextColumn();
    				nextColWidthLast = nextColWidth;
    				nextColWidth = nextCol ? nextCol.getWidth() / 2 : 0;
    				prevCol = moveToCol.prevColumn();
    				prevColWidthLast = prevColWidth;
    				prevColWidth = prevCol ? prevCol.getWidth() / 2 : 0;
    			}
    		}
    	}, { passive: true });

    	colEl.addEventListener("touchend", function (e) {
    		if (self.checkTimeout) {
    			clearTimeout(self.checkTimeout);
    		}
    		if (self.moving) {
    			self.endMove(e);
    		}
    	});
    };

    MoveColumns.prototype.startMove = function (e, column) {
    	var element = column.getElement();

    	this.moving = column;
    	this.startX = (this.touchMove ? e.touches[0].pageX : e.pageX) - Tabulator.prototype.helpers.elOffset(element).left;

    	this.table.element.classList.add("tabulator-block-select");

    	//create placeholder
    	this.placeholderElement.style.width = column.getWidth() + "px";
    	this.placeholderElement.style.height = column.getHeight() + "px";

    	element.parentNode.insertBefore(this.placeholderElement, element);
    	element.parentNode.removeChild(element);

    	//create hover element
    	this.hoverElement = element.cloneNode(true);
    	this.hoverElement.classList.add("tabulator-moving");

    	this.table.columnManager.getElement().appendChild(this.hoverElement);

    	this.hoverElement.style.left = "0";
    	this.hoverElement.style.bottom = "0";

    	if (!this.touchMove) {
    		this._bindMouseMove();

    		document.body.addEventListener("mousemove", this.moveHover);
    		document.body.addEventListener("mouseup", this.endMove);
    	}

    	this.moveHover(e);
    };

    MoveColumns.prototype._bindMouseMove = function () {
    	this.table.columnManager.columnsByIndex.forEach(function (column) {
    		if (column.modules.moveColumn.mousemove) {
    			column.getElement().addEventListener("mousemove", column.modules.moveColumn.mousemove);
    		}
    	});
    };

    MoveColumns.prototype._unbindMouseMove = function () {
    	this.table.columnManager.columnsByIndex.forEach(function (column) {
    		if (column.modules.moveColumn.mousemove) {
    			column.getElement().removeEventListener("mousemove", column.modules.moveColumn.mousemove);
    		}
    	});
    };

    MoveColumns.prototype.moveColumn = function (column, after) {
    	var movingCells = this.moving.getCells();

    	this.toCol = column;
    	this.toColAfter = after;

    	if (after) {
    		column.getCells().forEach(function (cell, i) {
    			var cellEl = cell.getElement(true);
    			cellEl.parentNode.insertBefore(movingCells[i].getElement(), cellEl.nextSibling);
    		});
    	} else {
    		column.getCells().forEach(function (cell, i) {
    			var cellEl = cell.getElement(true);
    			cellEl.parentNode.insertBefore(movingCells[i].getElement(), cellEl);
    		});
    	}
    };

    MoveColumns.prototype.endMove = function (e) {
    	if (e.which === 1 || this.touchMove) {
    		this._unbindMouseMove();

    		this.placeholderElement.parentNode.insertBefore(this.moving.getElement(), this.placeholderElement.nextSibling);
    		this.placeholderElement.parentNode.removeChild(this.placeholderElement);
    		this.hoverElement.parentNode.removeChild(this.hoverElement);

    		this.table.element.classList.remove("tabulator-block-select");

    		if (this.toCol) {
    			this.table.columnManager.moveColumnActual(this.moving, this.toCol, this.toColAfter);
    		}

    		this.moving = false;
    		this.toCol = false;
    		this.toColAfter = false;

    		if (!this.touchMove) {
    			document.body.removeEventListener("mousemove", this.moveHover);
    			document.body.removeEventListener("mouseup", this.endMove);
    		}
    	}
    };

    MoveColumns.prototype.moveHover = function (e) {
    	var self = this,
    	    columnHolder = self.table.columnManager.getElement(),
    	    scrollLeft = columnHolder.scrollLeft,
    	    xPos = (self.touchMove ? e.touches[0].pageX : e.pageX) - Tabulator.prototype.helpers.elOffset(columnHolder).left + scrollLeft,
    	    scrollPos;

    	self.hoverElement.style.left = xPos - self.startX + "px";

    	if (xPos - scrollLeft < self.autoScrollMargin) {
    		if (!self.autoScrollTimeout) {
    			self.autoScrollTimeout = setTimeout(function () {
    				scrollPos = Math.max(0, scrollLeft - 5);
    				self.table.rowManager.getElement().scrollLeft = scrollPos;
    				self.autoScrollTimeout = false;
    			}, 1);
    		}
    	}

    	if (scrollLeft + columnHolder.clientWidth - xPos < self.autoScrollMargin) {
    		if (!self.autoScrollTimeout) {
    			self.autoScrollTimeout = setTimeout(function () {
    				scrollPos = Math.min(columnHolder.clientWidth, scrollLeft + 5);
    				self.table.rowManager.getElement().scrollLeft = scrollPos;
    				self.autoScrollTimeout = false;
    			}, 1);
    		}
    	}
    };

    Tabulator.prototype.registerModule("moveColumn", MoveColumns);

    var MoveRows = function MoveRows(table) {

    	this.table = table; //hold Tabulator object
    	this.placeholderElement = this.createPlaceholderElement();
    	this.hoverElement = false; //floating row header element
    	this.checkTimeout = false; //click check timeout holder
    	this.checkPeriod = 150; //period to wait on mousedown to consider this a move and not a click
    	this.moving = false; //currently moving row
    	this.toRow = false; //destination row
    	this.toRowAfter = false; //position of moving row relative to the desitnation row
    	this.hasHandle = false; //row has handle instead of fully movable row
    	this.startY = 0; //starting Y position within header element
    	this.startX = 0; //starting X position within header element

    	this.moveHover = this.moveHover.bind(this);
    	this.endMove = this.endMove.bind(this);
    	this.tableRowDropEvent = false;

    	this.touchMove = false;

    	this.connection = false;
    	this.connectionSelectorsTables = false;
    	this.connectionSelectorsElements = false;
    	this.connectionElements = [];
    	this.connections = [];

    	this.connectedTable = false;
    	this.connectedRow = false;
    };

    MoveRows.prototype.createPlaceholderElement = function () {
    	var el = document.createElement("div");

    	el.classList.add("tabulator-row");
    	el.classList.add("tabulator-row-placeholder");

    	return el;
    };

    MoveRows.prototype.initialize = function (handle) {
    	this.connectionSelectorsTables = this.table.options.movableRowsConnectedTables;
    	this.connectionSelectorsElements = this.table.options.movableRowsConnectedElements;

    	this.connection = this.connectionSelectorsTables || this.connectionSelectorsElements;
    };

    MoveRows.prototype.setHandle = function (handle) {
    	this.hasHandle = handle;
    };

    MoveRows.prototype.initializeGroupHeader = function (group) {
    	var self = this,
    	    config = {};

    	//inter table drag drop
    	config.mouseup = function (e) {
    		self.tableRowDrop(e, row);
    	}.bind(self);

    	//same table drag drop
    	config.mousemove = function (e) {
    		if (e.pageY - Tabulator.prototype.helpers.elOffset(group.element).top + self.table.rowManager.element.scrollTop > group.getHeight() / 2) {
    			if (self.toRow !== group || !self.toRowAfter) {
    				var rowEl = group.getElement();
    				rowEl.parentNode.insertBefore(self.placeholderElement, rowEl.nextSibling);
    				self.moveRow(group, true);
    			}
    		} else {
    			if (self.toRow !== group || self.toRowAfter) {
    				var rowEl = group.getElement();
    				if (rowEl.previousSibling) {
    					rowEl.parentNode.insertBefore(self.placeholderElement, rowEl);
    					self.moveRow(group, false);
    				}
    			}
    		}
    	}.bind(self);

    	group.modules.moveRow = config;
    };

    MoveRows.prototype.initializeRow = function (row) {
    	var self = this,
    	    config = {},
    	    rowEl;

    	//inter table drag drop
    	config.mouseup = function (e) {
    		self.tableRowDrop(e, row);
    	}.bind(self);

    	//same table drag drop
    	config.mousemove = function (e) {
    		var rowEl = row.getElement();

    		if (e.pageY - Tabulator.prototype.helpers.elOffset(rowEl).top + self.table.rowManager.element.scrollTop > row.getHeight() / 2) {
    			if (self.toRow !== row || !self.toRowAfter) {
    				rowEl.parentNode.insertBefore(self.placeholderElement, rowEl.nextSibling);
    				self.moveRow(row, true);
    			}
    		} else {
    			if (self.toRow !== row || self.toRowAfter) {
    				rowEl.parentNode.insertBefore(self.placeholderElement, rowEl);
    				self.moveRow(row, false);
    			}
    		}
    	}.bind(self);

    	if (!this.hasHandle) {

    		rowEl = row.getElement();

    		rowEl.addEventListener("mousedown", function (e) {
    			if (e.which === 1) {
    				self.checkTimeout = setTimeout(function () {
    					self.startMove(e, row);
    				}, self.checkPeriod);
    			}
    		});

    		rowEl.addEventListener("mouseup", function (e) {
    			if (e.which === 1) {
    				if (self.checkTimeout) {
    					clearTimeout(self.checkTimeout);
    				}
    			}
    		});

    		this.bindTouchEvents(row, row.getElement());
    	}

    	row.modules.moveRow = config;
    };

    MoveRows.prototype.initializeCell = function (cell) {
    	var self = this,
    	    cellEl = cell.getElement(true);

    	cellEl.addEventListener("mousedown", function (e) {
    		if (e.which === 1) {
    			self.checkTimeout = setTimeout(function () {
    				self.startMove(e, cell.row);
    			}, self.checkPeriod);
    		}
    	});

    	cellEl.addEventListener("mouseup", function (e) {
    		if (e.which === 1) {
    			if (self.checkTimeout) {
    				clearTimeout(self.checkTimeout);
    			}
    		}
    	});

    	this.bindTouchEvents(cell.row, cellEl);
    };

    MoveRows.prototype.bindTouchEvents = function (row, element) {
    	var self = this,
    	    startYMove = false,
    	    nextRow,
    	    prevRow,
    	    nextRowHeight,
    	    prevRowHeight,
    	    nextRowHeightLast,
    	    prevRowHeightLast;

    	element.addEventListener("touchstart", function (e) {
    		self.checkTimeout = setTimeout(function () {
    			self.touchMove = true;
    			nextRow = row.nextRow();
    			nextRowHeight = nextRow ? nextRow.getHeight() / 2 : 0;
    			prevRow = row.prevRow();
    			prevRowHeight = prevRow ? prevRow.getHeight() / 2 : 0;
    			nextRowHeightLast = 0;
    			prevRowHeightLast = 0;
    			startYMove = false;

    			self.startMove(e, row);
    		}, self.checkPeriod);
    	}, { passive: true });
    	this.moving, this.toRow, this.toRowAfter;
    	element.addEventListener("touchmove", function (e) {

    		var diff, moveToRow;

    		if (self.moving) {
    			e.preventDefault();

    			self.moveHover(e);

    			if (!startYMove) {
    				startYMove = e.touches[0].pageY;
    			}

    			diff = e.touches[0].pageY - startYMove;

    			if (diff > 0) {
    				if (nextRow && diff - nextRowHeightLast > nextRowHeight) {
    					moveToRow = nextRow;

    					if (moveToRow !== row) {
    						startYMove = e.touches[0].pageY;
    						moveToRow.getElement().parentNode.insertBefore(self.placeholderElement, moveToRow.getElement().nextSibling);
    						self.moveRow(moveToRow, true);
    					}
    				}
    			} else {
    				if (prevRow && -diff - prevRowHeightLast > prevRowHeight) {
    					moveToRow = prevRow;

    					if (moveToRow !== row) {
    						startYMove = e.touches[0].pageY;
    						moveToRow.getElement().parentNode.insertBefore(self.placeholderElement, moveToRow.getElement());
    						self.moveRow(moveToRow, false);
    					}
    				}
    			}

    			if (moveToRow) {
    				nextRow = moveToRow.nextRow();
    				nextRowHeightLast = nextRowHeight;
    				nextRowHeight = nextRow ? nextRow.getHeight() / 2 : 0;
    				prevRow = moveToRow.prevRow();
    				prevRowHeightLast = prevRowHeight;
    				prevRowHeight = prevRow ? prevRow.getHeight() / 2 : 0;
    			}
    		}
    	});

    	element.addEventListener("touchend", function (e) {
    		if (self.checkTimeout) {
    			clearTimeout(self.checkTimeout);
    		}
    		if (self.moving) {
    			self.endMove(e);
    			self.touchMove = false;
    		}
    	});
    };

    MoveRows.prototype._bindMouseMove = function () {
    	var self = this;

    	self.table.rowManager.getDisplayRows().forEach(function (row) {
    		if ((row.type === "row" || row.type === "group") && row.modules.moveRow.mousemove) {
    			row.getElement().addEventListener("mousemove", row.modules.moveRow.mousemove);
    		}
    	});
    };

    MoveRows.prototype._unbindMouseMove = function () {
    	var self = this;

    	self.table.rowManager.getDisplayRows().forEach(function (row) {
    		if ((row.type === "row" || row.type === "group") && row.modules.moveRow.mousemove) {
    			row.getElement().removeEventListener("mousemove", row.modules.moveRow.mousemove);
    		}
    	});
    };

    MoveRows.prototype.startMove = function (e, row) {
    	var element = row.getElement();

    	this.setStartPosition(e, row);

    	this.moving = row;

    	this.table.element.classList.add("tabulator-block-select");

    	//create placeholder
    	this.placeholderElement.style.width = row.getWidth() + "px";
    	this.placeholderElement.style.height = row.getHeight() + "px";

    	if (!this.connection) {
    		element.parentNode.insertBefore(this.placeholderElement, element);
    		element.parentNode.removeChild(element);
    	} else {
    		this.table.element.classList.add("tabulator-movingrow-sending");
    		this.connectToTables(row);
    	}

    	//create hover element
    	this.hoverElement = element.cloneNode(true);
    	this.hoverElement.classList.add("tabulator-moving");

    	if (this.connection) {
    		document.body.appendChild(this.hoverElement);
    		this.hoverElement.style.left = "0";
    		this.hoverElement.style.top = "0";
    		this.hoverElement.style.width = this.table.element.clientWidth + "px";
    		this.hoverElement.style.whiteSpace = "nowrap";
    		this.hoverElement.style.overflow = "hidden";
    		this.hoverElement.style.pointerEvents = "none";
    	} else {
    		this.table.rowManager.getTableElement().appendChild(this.hoverElement);

    		this.hoverElement.style.left = "0";
    		this.hoverElement.style.top = "0";

    		this._bindMouseMove();
    	}

    	document.body.addEventListener("mousemove", this.moveHover);
    	document.body.addEventListener("mouseup", this.endMove);

    	this.moveHover(e);
    };

    MoveRows.prototype.setStartPosition = function (e, row) {
    	var pageX = this.touchMove ? e.touches[0].pageX : e.pageX,
    	    pageY = this.touchMove ? e.touches[0].pageY : e.pageY,
    	    element,
    	    position;

    	element = row.getElement();
    	if (this.connection) {
    		position = element.getBoundingClientRect();

    		this.startX = position.left - pageX + window.pageXOffset;
    		this.startY = position.top - pageY + window.pageYOffset;
    	} else {
    		this.startY = pageY - element.getBoundingClientRect().top;
    	}
    };

    MoveRows.prototype.endMove = function (e) {
    	if (!e || e.which === 1 || this.touchMove) {
    		this._unbindMouseMove();

    		if (!this.connection) {
    			this.placeholderElement.parentNode.insertBefore(this.moving.getElement(), this.placeholderElement.nextSibling);
    			this.placeholderElement.parentNode.removeChild(this.placeholderElement);
    		}

    		this.hoverElement.parentNode.removeChild(this.hoverElement);

    		this.table.element.classList.remove("tabulator-block-select");

    		if (this.toRow) {
    			this.table.rowManager.moveRow(this.moving, this.toRow, this.toRowAfter);
    		}

    		this.moving = false;
    		this.toRow = false;
    		this.toRowAfter = false;

    		document.body.removeEventListener("mousemove", this.moveHover);
    		document.body.removeEventListener("mouseup", this.endMove);

    		if (this.connection) {
    			this.table.element.classList.remove("tabulator-movingrow-sending");
    			this.disconnectFromTables();
    		}
    	}
    };

    MoveRows.prototype.moveRow = function (row, after) {
    	this.toRow = row;
    	this.toRowAfter = after;
    };

    MoveRows.prototype.moveHover = function (e) {
    	if (this.connection) {
    		this.moveHoverConnections.call(this, e);
    	} else {
    		this.moveHoverTable.call(this, e);
    	}
    };

    MoveRows.prototype.moveHoverTable = function (e) {
    	var rowHolder = this.table.rowManager.getElement(),
    	    scrollTop = rowHolder.scrollTop,
    	    yPos = (this.touchMove ? e.touches[0].pageY : e.pageY) - rowHolder.getBoundingClientRect().top + scrollTop;

    	this.hoverElement.style.top = yPos - this.startY + "px";
    };

    MoveRows.prototype.moveHoverConnections = function (e) {
    	this.hoverElement.style.left = this.startX + (this.touchMove ? e.touches[0].pageX : e.pageX) + "px";
    	this.hoverElement.style.top = this.startY + (this.touchMove ? e.touches[0].pageY : e.pageY) + "px";
    };

    MoveRows.prototype.elementRowDrop = function (e, element, row) {
    	if (this.table.options.movableRowsElementDrop) {
    		this.table.options.movableRowsElementDrop(e, element, row ? row.getComponent() : false);
    	}
    };

    //establish connection with other tables
    MoveRows.prototype.connectToTables = function (row) {
    	var _this75 = this;

    	var connectionTables;

    	if (this.connectionSelectorsTables) {
    		connectionTables = this.table.modules.comms.getConnections(this.connectionSelectorsTables);

    		this.table.options.movableRowsSendingStart.call(this.table, connectionTables);

    		this.table.modules.comms.send(this.connectionSelectorsTables, "moveRow", "connect", {
    			row: row
    		});
    	}

    	if (this.connectionSelectorsElements) {

    		this.connectionElements = [];

    		if (!Array.isArray(this.connectionSelectorsElements)) {
    			this.connectionSelectorsElements = [this.connectionSelectorsElements];
    		}

    		this.connectionSelectorsElements.forEach(function (query) {
    			if (typeof query === "string") {
    				_this75.connectionElements = _this75.connectionElements.concat(Array.prototype.slice.call(document.querySelectorAll(query)));
    			} else {
    				_this75.connectionElements.push(query);
    			}
    		});

    		this.connectionElements.forEach(function (element) {
    			var dropEvent = function dropEvent(e) {
    				_this75.elementRowDrop(e, element, _this75.moving);
    			};

    			element.addEventListener("mouseup", dropEvent);
    			element.tabulatorElementDropEvent = dropEvent;

    			element.classList.add("tabulator-movingrow-receiving");
    		});
    	}
    };

    //disconnect from other tables
    MoveRows.prototype.disconnectFromTables = function () {
    	var connectionTables;

    	if (this.connectionSelectorsTables) {
    		connectionTables = this.table.modules.comms.getConnections(this.connectionSelectorsTables);

    		this.table.options.movableRowsSendingStop.call(this.table, connectionTables);

    		this.table.modules.comms.send(this.connectionSelectorsTables, "moveRow", "disconnect");
    	}

    	this.connectionElements.forEach(function (element) {
    		element.classList.remove("tabulator-movingrow-receiving");
    		element.removeEventListener("mouseup", element.tabulatorElementDropEvent);
    		delete element.tabulatorElementDropEvent;
    	});
    };

    //accept incomming connection
    MoveRows.prototype.connect = function (table, row) {
    	var self = this;
    	if (!this.connectedTable) {
    		this.connectedTable = table;
    		this.connectedRow = row;

    		this.table.element.classList.add("tabulator-movingrow-receiving");

    		self.table.rowManager.getDisplayRows().forEach(function (row) {
    			if (row.type === "row" && row.modules.moveRow && row.modules.moveRow.mouseup) {
    				row.getElement().addEventListener("mouseup", row.modules.moveRow.mouseup);
    			}
    		});

    		self.tableRowDropEvent = self.tableRowDrop.bind(self);

    		self.table.element.addEventListener("mouseup", self.tableRowDropEvent);

    		this.table.options.movableRowsReceivingStart.call(this.table, row, table);

    		return true;
    	} else {
    		console.warn("Move Row Error - Table cannot accept connection, already connected to table:", this.connectedTable);
    		return false;
    	}
    };

    //close incomming connection
    MoveRows.prototype.disconnect = function (table) {
    	var self = this;
    	if (table === this.connectedTable) {
    		this.connectedTable = false;
    		this.connectedRow = false;

    		this.table.element.classList.remove("tabulator-movingrow-receiving");

    		self.table.rowManager.getDisplayRows().forEach(function (row) {
    			if (row.type === "row" && row.modules.moveRow && row.modules.moveRow.mouseup) {
    				row.getElement().removeEventListener("mouseup", row.modules.moveRow.mouseup);
    			}
    		});

    		self.table.element.removeEventListener("mouseup", self.tableRowDropEvent);

    		this.table.options.movableRowsReceivingStop.call(this.table, table);
    	} else {
    		console.warn("Move Row Error - trying to disconnect from non connected table");
    	}
    };

    MoveRows.prototype.dropComplete = function (table, row, success) {
    	var sender = false;

    	if (success) {

    		switch (_typeof(this.table.options.movableRowsSender)) {
    			case "string":
    				sender = this.senders[this.table.options.movableRowsSender];
    				break;

    			case "function":
    				sender = this.table.options.movableRowsSender;
    				break;
    		}

    		if (sender) {
    			sender.call(this, this.moving.getComponent(), row ? row.getComponent() : undefined, table);
    		} else {
    			if (this.table.options.movableRowsSender) {
    				console.warn("Mover Row Error - no matching sender found:", this.table.options.movableRowsSender);
    			}
    		}

    		this.table.options.movableRowsSent.call(this.table, this.moving.getComponent(), row ? row.getComponent() : undefined, table);
    	} else {
    		this.table.options.movableRowsSentFailed.call(this.table, this.moving.getComponent(), row ? row.getComponent() : undefined, table);
    	}

    	this.endMove();
    };

    MoveRows.prototype.tableRowDrop = function (e, row) {
    	var receiver = false,
    	    success = false;

    	e.stopImmediatePropagation();

    	switch (_typeof(this.table.options.movableRowsReceiver)) {
    		case "string":
    			receiver = this.receivers[this.table.options.movableRowsReceiver];
    			break;

    		case "function":
    			receiver = this.table.options.movableRowsReceiver;
    			break;
    	}

    	if (receiver) {
    		success = receiver.call(this, this.connectedRow.getComponent(), row ? row.getComponent() : undefined, this.connectedTable);
    	} else {
    		console.warn("Mover Row Error - no matching receiver found:", this.table.options.movableRowsReceiver);
    	}

    	if (success) {
    		this.table.options.movableRowsReceived.call(this.table, this.connectedRow.getComponent(), row ? row.getComponent() : undefined, this.connectedTable);
    	} else {
    		this.table.options.movableRowsReceivedFailed.call(this.table, this.connectedRow.getComponent(), row ? row.getComponent() : undefined, this.connectedTable);
    	}

    	this.table.modules.comms.send(this.connectedTable, "moveRow", "dropcomplete", {
    		row: row,
    		success: success
    	});
    };

    MoveRows.prototype.receivers = {
    	insert: function insert(fromRow, toRow, fromTable) {
    		this.table.addRow(fromRow.getData(), undefined, toRow);
    		return true;
    	},

    	add: function add(fromRow, toRow, fromTable) {
    		this.table.addRow(fromRow.getData());
    		return true;
    	},

    	update: function update(fromRow, toRow, fromTable) {
    		if (toRow) {
    			toRow.update(fromRow.getData());
    			return true;
    		}

    		return false;
    	},

    	replace: function replace(fromRow, toRow, fromTable) {
    		if (toRow) {
    			this.table.addRow(fromRow.getData(), undefined, toRow);
    			toRow.delete();
    			return true;
    		}

    		return false;
    	}
    };

    MoveRows.prototype.senders = {
    	delete: function _delete(fromRow, toRow, toTable) {
    		fromRow.delete();
    	}
    };

    MoveRows.prototype.commsReceived = function (table, action, data) {
    	switch (action) {
    		case "connect":
    			return this.connect(table, data.row);

    		case "disconnect":
    			return this.disconnect(table);

    		case "dropcomplete":
    			return this.dropComplete(table, data.row, data.success);
    	}
    };

    Tabulator.prototype.registerModule("moveRow", MoveRows);
    var Mutator = function Mutator(table) {
    	this.table = table; //hold Tabulator object
    	this.allowedTypes = ["", "data", "edit", "clipboard"]; //list of muatation types
    	this.enabled = true;
    };

    //initialize column mutator
    Mutator.prototype.initializeColumn = function (column) {
    	var self = this,
    	    match = false,
    	    config = {};

    	this.allowedTypes.forEach(function (type) {
    		var key = "mutator" + (type.charAt(0).toUpperCase() + type.slice(1)),
    		    mutator;

    		if (column.definition[key]) {
    			mutator = self.lookupMutator(column.definition[key]);

    			if (mutator) {
    				match = true;

    				config[key] = {
    					mutator: mutator,
    					params: column.definition[key + "Params"] || {}
    				};
    			}
    		}
    	});

    	if (match) {
    		column.modules.mutate = config;
    	}
    };

    Mutator.prototype.lookupMutator = function (value) {
    	var mutator = false;

    	//set column mutator
    	switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
    		case "string":
    			if (this.mutators[value]) {
    				mutator = this.mutators[value];
    			} else {
    				console.warn("Mutator Error - No such mutator found, ignoring: ", value);
    			}
    			break;

    		case "function":
    			mutator = value;
    			break;
    	}

    	return mutator;
    };

    //apply mutator to row
    Mutator.prototype.transformRow = function (data, type, updatedData) {
    	var self = this,
    	    key = "mutator" + (type.charAt(0).toUpperCase() + type.slice(1)),
    	    value;

    	if (this.enabled) {

    		self.table.columnManager.traverse(function (column) {
    			var mutator, params, component;

    			if (column.modules.mutate) {
    				mutator = column.modules.mutate[key] || column.modules.mutate.mutator || false;

    				if (mutator) {
    					value = column.getFieldValue(typeof updatedData !== "undefined" ? updatedData : data);

    					if (type == "data" || typeof value !== "undefined") {
    						component = column.getComponent();
    						params = typeof mutator.params === "function" ? mutator.params(value, data, type, component) : mutator.params;
    						column.setFieldValue(data, mutator.mutator(value, data, type, params, component));
    					}
    				}
    			}
    		});
    	}

    	return data;
    };

    //apply mutator to new cell value
    Mutator.prototype.transformCell = function (cell, value) {
    	var mutator = cell.column.modules.mutate.mutatorEdit || cell.column.modules.mutate.mutator || false,
    	    tempData = {};

    	if (mutator) {
    		tempData = Object.assign(tempData, cell.row.getData());
    		cell.column.setFieldValue(tempData, value);
    		return mutator.mutator(value, tempData, "edit", mutator.params, cell.getComponent());
    	} else {
    		return value;
    	}
    };

    Mutator.prototype.enable = function () {
    	this.enabled = true;
    };

    Mutator.prototype.disable = function () {
    	this.enabled = false;
    };

    //default mutators
    Mutator.prototype.mutators = {};

    Tabulator.prototype.registerModule("mutator", Mutator);
    var Page = function Page(table) {

    	this.table = table; //hold Tabulator object

    	this.mode = "local";
    	this.progressiveLoad = false;

    	this.size = 0;
    	this.page = 1;
    	this.count = 5;
    	this.max = 1;

    	this.displayIndex = 0; //index in display pipeline

    	this.initialLoad = true;

    	this.pageSizes = [];

    	this.dataReceivedNames = {};
    	this.dataSentNames = {};

    	this.createElements();
    };

    Page.prototype.createElements = function () {

    	var button;

    	this.element = document.createElement("span");
    	this.element.classList.add("tabulator-paginator");

    	this.pagesElement = document.createElement("span");
    	this.pagesElement.classList.add("tabulator-pages");

    	button = document.createElement("button");
    	button.classList.add("tabulator-page");
    	button.setAttribute("type", "button");
    	button.setAttribute("role", "button");
    	button.setAttribute("aria-label", "");
    	button.setAttribute("title", "");

    	this.firstBut = button.cloneNode(true);
    	this.firstBut.setAttribute("data-page", "first");

    	this.prevBut = button.cloneNode(true);
    	this.prevBut.setAttribute("data-page", "prev");

    	this.nextBut = button.cloneNode(true);
    	this.nextBut.setAttribute("data-page", "next");

    	this.lastBut = button.cloneNode(true);
    	this.lastBut.setAttribute("data-page", "last");

    	if (this.table.options.paginationSizeSelector) {
    		this.pageSizeSelect = document.createElement("select");
    		this.pageSizeSelect.classList.add("tabulator-page-size");
    	}
    };

    Page.prototype.generatePageSizeSelectList = function () {
    	var _this76 = this;

    	var pageSizes = [];

    	if (this.pageSizeSelect) {

    		if (Array.isArray(this.table.options.paginationSizeSelector)) {
    			pageSizes = this.table.options.paginationSizeSelector;
    			this.pageSizes = pageSizes;

    			if (this.pageSizes.indexOf(this.size) == -1) {
    				pageSizes.unshift(this.size);
    			}
    		} else {

    			if (this.pageSizes.indexOf(this.size) == -1) {
    				pageSizes = [];

    				for (var _i14 = 1; _i14 < 5; _i14++) {
    					pageSizes.push(this.size * _i14);
    				}

    				this.pageSizes = pageSizes;
    			} else {
    				pageSizes = this.pageSizes;
    			}
    		}

    		while (this.pageSizeSelect.firstChild) {
    			this.pageSizeSelect.removeChild(this.pageSizeSelect.firstChild);
    		}pageSizes.forEach(function (item) {
    			var itemEl = document.createElement("option");
    			itemEl.value = item;

    			if (item === true) {
    				_this76.table.modules.localize.bind("pagination|all", function (value) {
    					itemEl.innerHTML = value;
    				});
    			} else {
    				itemEl.innerHTML = item;
    			}

    			_this76.pageSizeSelect.appendChild(itemEl);
    		});

    		this.pageSizeSelect.value = this.size;
    	}
    };

    //setup pageination
    Page.prototype.initialize = function (hidden) {
    	var self = this,
    	    pageSelectLabel,
    	    testElRow,
    	    testElCell;

    	//update param names
    	this.dataSentNames = Object.assign({}, this.paginationDataSentNames);
    	this.dataSentNames = Object.assign(this.dataSentNames, this.table.options.paginationDataSent);

    	this.dataReceivedNames = Object.assign({}, this.paginationDataReceivedNames);
    	this.dataReceivedNames = Object.assign(this.dataReceivedNames, this.table.options.paginationDataReceived);

    	//build pagination element

    	//bind localizations
    	self.table.modules.localize.bind("pagination|first", function (value) {
    		self.firstBut.innerHTML = value;
    	});

    	self.table.modules.localize.bind("pagination|first_title", function (value) {
    		self.firstBut.setAttribute("aria-label", value);
    		self.firstBut.setAttribute("title", value);
    	});

    	self.table.modules.localize.bind("pagination|prev", function (value) {
    		self.prevBut.innerHTML = value;
    	});

    	self.table.modules.localize.bind("pagination|prev_title", function (value) {
    		self.prevBut.setAttribute("aria-label", value);
    		self.prevBut.setAttribute("title", value);
    	});

    	self.table.modules.localize.bind("pagination|next", function (value) {
    		self.nextBut.innerHTML = value;
    	});

    	self.table.modules.localize.bind("pagination|next_title", function (value) {
    		self.nextBut.setAttribute("aria-label", value);
    		self.nextBut.setAttribute("title", value);
    	});

    	self.table.modules.localize.bind("pagination|last", function (value) {
    		self.lastBut.innerHTML = value;
    	});

    	self.table.modules.localize.bind("pagination|last_title", function (value) {
    		self.lastBut.setAttribute("aria-label", value);
    		self.lastBut.setAttribute("title", value);
    	});

    	//click bindings
    	self.firstBut.addEventListener("click", function () {
    		self.setPage(1).then(function () {}).catch(function () {});
    	});

    	self.prevBut.addEventListener("click", function () {
    		self.previousPage().then(function () {}).catch(function () {});
    	});

    	self.nextBut.addEventListener("click", function () {
    		self.nextPage().then(function () {}).catch(function () {});
    	});

    	self.lastBut.addEventListener("click", function () {
    		self.setPage(self.max).then(function () {}).catch(function () {});
    	});

    	if (self.table.options.paginationElement) {
    		self.element = self.table.options.paginationElement;
    	}

    	if (this.pageSizeSelect) {
    		pageSelectLabel = document.createElement("label");

    		self.table.modules.localize.bind("pagination|page_size", function (value) {
    			self.pageSizeSelect.setAttribute("aria-label", value);
    			self.pageSizeSelect.setAttribute("title", value);
    			pageSelectLabel.innerHTML = value;
    		});

    		self.element.appendChild(pageSelectLabel);
    		self.element.appendChild(self.pageSizeSelect);

    		self.pageSizeSelect.addEventListener("change", function (e) {
    			self.setPageSize(self.pageSizeSelect.value == "true" ? true : self.pageSizeSelect.value);
    			self.setPage(1).then(function () {}).catch(function () {});
    		});
    	}

    	//append to DOM
    	self.element.appendChild(self.firstBut);
    	self.element.appendChild(self.prevBut);
    	self.element.appendChild(self.pagesElement);
    	self.element.appendChild(self.nextBut);
    	self.element.appendChild(self.lastBut);

    	if (!self.table.options.paginationElement && !hidden) {
    		self.table.footerManager.append(self.element, self);
    	}

    	//set default values
    	self.mode = self.table.options.pagination;

    	if (self.table.options.paginationSize) {
    		self.size = self.table.options.paginationSize;
    	} else {
    		testElRow = document.createElement("div");
    		testElRow.classList.add("tabulator-row");
    		testElRow.style.visibility = hidden;

    		testElCell = document.createElement("div");
    		testElCell.classList.add("tabulator-cell");
    		testElCell.innerHTML = "Page Row Test";

    		testElRow.appendChild(testElCell);

    		self.table.rowManager.getTableElement().appendChild(testElRow);

    		self.size = Math.floor(self.table.rowManager.getElement().clientHeight / testElRow.offsetHeight);

    		self.table.rowManager.getTableElement().removeChild(testElRow);
    	}

    	// self.page = self.table.options.paginationInitialPage || 1;
    	self.count = self.table.options.paginationButtonCount;

    	self.generatePageSizeSelectList();
    };

    Page.prototype.initializeProgressive = function (mode) {
    	this.initialize(true);
    	this.mode = "progressive_" + mode;
    	this.progressiveLoad = true;
    };

    Page.prototype.setDisplayIndex = function (index) {
    	this.displayIndex = index;
    };

    Page.prototype.getDisplayIndex = function () {
    	return this.displayIndex;
    };

    //calculate maximum page from number of rows
    Page.prototype.setMaxRows = function (rowCount) {
    	if (!rowCount) {
    		this.max = 1;
    	} else {
    		this.max = this.size === true ? 1 : Math.ceil(rowCount / this.size);
    	}

    	if (this.page > this.max) {
    		this.page = this.max;
    	}
    };

    //reset to first page without triggering action
    Page.prototype.reset = function (force, columnsChanged) {
    	if (this.mode == "local" || force) {
    		this.page = 1;
    	}

    	if (columnsChanged) {
    		this.initialLoad = true;
    	}

    	return true;
    };

    //set the maxmum page
    Page.prototype.setMaxPage = function (max) {

    	max = parseInt(max);

    	this.max = max || 1;

    	if (this.page > this.max) {
    		this.page = this.max;
    		this.trigger();
    	}
    };

    //set current page number
    Page.prototype.setPage = function (page) {
    	var _this77 = this;

    	var self = this;

    	switch (page) {
    		case "first":
    			return this.setPage(1);

    		case "prev":
    			return this.previousPage();

    		case "next":
    			return this.nextPage();

    		case "last":
    			return this.setPage(this.max);
    	}

    	return new Promise(function (resolve, reject) {

    		page = parseInt(page);

    		if (page > 0 && page <= _this77.max || _this77.mode !== "local") {
    			_this77.page = page;
    			_this77.trigger().then(function () {
    				resolve();
    			}).catch(function () {
    				reject();
    			});

    			if (self.table.options.persistence && self.table.modExists("persistence", true) && self.table.modules.persistence.config.page) {
    				self.table.modules.persistence.save("page");
    			}
    		} else {
    			console.warn("Pagination Error - Requested page is out of range of 1 - " + _this77.max + ":", page);
    			reject();
    		}
    	});
    };

    Page.prototype.setPageToRow = function (row) {
    	var _this78 = this;

    	return new Promise(function (resolve, reject) {

    		var rows = _this78.table.rowManager.getDisplayRows(_this78.displayIndex - 1);
    		var index = rows.indexOf(row);

    		if (index > -1) {
    			var page = _this78.size === true ? 1 : Math.ceil((index + 1) / _this78.size);

    			_this78.setPage(page).then(function () {
    				resolve();
    			}).catch(function () {
    				reject();
    			});
    		} else {
    			console.warn("Pagination Error - Requested row is not visible");
    			reject();
    		}
    	});
    };

    Page.prototype.setPageSize = function (size) {
    	if (size !== true) {
    		size = parseInt(size);
    	}

    	if (size > 0) {
    		this.size = size;
    	}

    	if (this.pageSizeSelect) {
    		// this.pageSizeSelect.value = size;
    		this.generatePageSizeSelectList();
    	}

    	if (this.table.options.persistence && this.table.modExists("persistence", true) && this.table.modules.persistence.config.page) {
    		this.table.modules.persistence.save("page");
    	}
    };

    //setup the pagination buttons
    Page.prototype._setPageButtons = function () {
    	var self = this;

    	var leftSize = Math.floor((this.count - 1) / 2);
    	var rightSize = Math.ceil((this.count - 1) / 2);
    	var min = this.max - this.page + leftSize + 1 < this.count ? this.max - this.count + 1 : Math.max(this.page - leftSize, 1);
    	var max = this.page <= rightSize ? Math.min(this.count, this.max) : Math.min(this.page + rightSize, this.max);

    	while (self.pagesElement.firstChild) {
    		self.pagesElement.removeChild(self.pagesElement.firstChild);
    	}if (self.page == 1) {
    		self.firstBut.disabled = true;
    		self.prevBut.disabled = true;
    	} else {
    		self.firstBut.disabled = false;
    		self.prevBut.disabled = false;
    	}

    	if (self.page == self.max) {
    		self.lastBut.disabled = true;
    		self.nextBut.disabled = true;
    	} else {
    		self.lastBut.disabled = false;
    		self.nextBut.disabled = false;
    	}

    	for (var _i15 = min; _i15 <= max; _i15++) {
    		if (_i15 > 0 && _i15 <= self.max) {
    			self.pagesElement.appendChild(self._generatePageButton(_i15));
    		}
    	}

    	this.footerRedraw();
    };

    Page.prototype._generatePageButton = function (page) {
    	var self = this,
    	    button = document.createElement("button");

    	button.classList.add("tabulator-page");
    	if (page == self.page) {
    		button.classList.add("active");
    	}

    	button.setAttribute("type", "button");
    	button.setAttribute("role", "button");

    	self.table.modules.localize.bind("pagination|page_title", function (value) {
    		button.setAttribute("aria-label", value + " " + page);
    		button.setAttribute("title", value + " " + page);
    	});

    	button.setAttribute("data-page", page);
    	button.textContent = page;

    	button.addEventListener("click", function (e) {
    		self.setPage(page).then(function () {}).catch(function () {});
    	});

    	return button;
    };

    //previous page
    Page.prototype.previousPage = function () {
    	var _this79 = this;

    	return new Promise(function (resolve, reject) {
    		if (_this79.page > 1) {
    			_this79.page--;
    			_this79.trigger().then(function () {
    				resolve();
    			}).catch(function () {
    				reject();
    			});

    			if (_this79.table.options.persistence && _this79.table.modExists("persistence", true) && _this79.table.modules.persistence.config.page) {
    				_this79.table.modules.persistence.save("page");
    			}
    		} else {
    			console.warn("Pagination Error - Previous page would be less than page 1:", 0);
    			reject();
    		}
    	});
    };

    //next page
    Page.prototype.nextPage = function () {
    	var _this80 = this;

    	return new Promise(function (resolve, reject) {
    		if (_this80.page < _this80.max) {
    			_this80.page++;
    			_this80.trigger().then(function () {
    				resolve();
    			}).catch(function () {
    				reject();
    			});

    			if (_this80.table.options.persistence && _this80.table.modExists("persistence", true) && _this80.table.modules.persistence.config.page) {
    				_this80.table.modules.persistence.save("page");
    			}
    		} else {
    			if (!_this80.progressiveLoad) {
    				console.warn("Pagination Error - Next page would be greater than maximum page of " + _this80.max + ":", _this80.max + 1);
    			}
    			reject();
    		}
    	});
    };

    //return current page number
    Page.prototype.getPage = function () {
    	return this.page;
    };

    //return max page number
    Page.prototype.getPageMax = function () {
    	return this.max;
    };

    Page.prototype.getPageSize = function (size) {
    	return this.size;
    };

    Page.prototype.getMode = function () {
    	return this.mode;
    };

    //return appropriate rows for current page
    Page.prototype.getRows = function (data) {
    	var output, start, end;

    	if (this.mode == "local") {
    		output = [];

    		if (this.size === true) {
    			start = 0;
    			end = data.length;
    		} else {
    			start = this.size * (this.page - 1);
    			end = start + parseInt(this.size);
    		}

    		this._setPageButtons();

    		for (var _i16 = start; _i16 < end; _i16++) {
    			if (data[_i16]) {
    				output.push(data[_i16]);
    			}
    		}

    		return output;
    	} else {

    		this._setPageButtons();

    		return data.slice(0);
    	}
    };

    Page.prototype.trigger = function () {
    	var _this81 = this;

    	var left;

    	return new Promise(function (resolve, reject) {

    		switch (_this81.mode) {
    			case "local":
    				left = _this81.table.rowManager.scrollLeft;

    				_this81.table.rowManager.refreshActiveData("page");
    				_this81.table.rowManager.scrollHorizontal(left);

    				_this81.table.options.pageLoaded.call(_this81.table, _this81.getPage());
    				resolve();
    				break;

    			case "remote":
    			case "progressive_load":
    			case "progressive_scroll":
    				_this81.table.modules.ajax.blockActiveRequest();
    				_this81._getRemotePage().then(function () {
    					resolve();
    				}).catch(function () {
    					reject();
    				});
    				break;

    			default:
    				console.warn("Pagination Error - no such pagination mode:", _this81.mode);
    				reject();
    		}
    	});
    };

    Page.prototype._getRemotePage = function () {
    	var _this82 = this;

    	var self = this,
    	    oldParams,
    	    pageParams;

    	return new Promise(function (resolve, reject) {

    		if (!self.table.modExists("ajax", true)) {
    			reject();
    		}

    		//record old params and restore after request has been made
    		oldParams = Tabulator.prototype.helpers.deepClone(self.table.modules.ajax.getParams() || {});
    		pageParams = self.table.modules.ajax.getParams();

    		//configure request params
    		pageParams[_this82.dataSentNames.page] = self.page;

    		//set page size if defined
    		if (_this82.size) {
    			pageParams[_this82.dataSentNames.size] = _this82.size;
    		}

    		//set sort data if defined
    		if (_this82.table.options.ajaxSorting && _this82.table.modExists("sort")) {
    			var sorters = self.table.modules.sort.getSort();

    			sorters.forEach(function (item) {
    				delete item.column;
    			});

    			pageParams[_this82.dataSentNames.sorters] = sorters;
    		}

    		//set filter data if defined
    		if (_this82.table.options.ajaxFiltering && _this82.table.modExists("filter")) {
    			var filters = self.table.modules.filter.getFilters(true, true);
    			pageParams[_this82.dataSentNames.filters] = filters;
    		}

    		self.table.modules.ajax.setParams(pageParams);

    		self.table.modules.ajax.sendRequest(_this82.progressiveLoad).then(function (data) {
    			self._parseRemoteData(data);
    			resolve();
    		}).catch(function (e) {
    			reject();
    		});

    		self.table.modules.ajax.setParams(oldParams);
    	});
    };

    Page.prototype._parseRemoteData = function (data) {
    	var self = this,
    	    left,
    	    data,
    	    margin;

    	if (typeof data[this.dataReceivedNames.last_page] === "undefined") {
    		console.warn("Remote Pagination Error - Server response missing '" + this.dataReceivedNames.last_page + "' property");
    	}

    	if (data[this.dataReceivedNames.data]) {
    		this.max = parseInt(data[this.dataReceivedNames.last_page]) || 1;

    		if (this.progressiveLoad) {
    			switch (this.mode) {
    				case "progressive_load":

    					if (this.page == 1) {
    						this.table.rowManager.setData(data[this.dataReceivedNames.data], false, this.initialLoad && this.page == 1);
    					} else {
    						this.table.rowManager.addRows(data[this.dataReceivedNames.data]);
    					}

    					if (this.page < this.max) {
    						setTimeout(function () {
    							self.nextPage().then(function () {}).catch(function () {});
    						}, self.table.options.ajaxProgressiveLoadDelay);
    					}
    					break;

    				case "progressive_scroll":
    					data = this.table.rowManager.getData().concat(data[this.dataReceivedNames.data]);

    					this.table.rowManager.setData(data, true, this.initialLoad && this.page == 1);

    					margin = this.table.options.ajaxProgressiveLoadScrollMargin || this.table.rowManager.element.clientHeight * 2;

    					if (self.table.rowManager.element.scrollHeight <= self.table.rowManager.element.clientHeight + margin) {
    						self.nextPage().then(function () {}).catch(function () {});
    					}
    					break;
    			}
    		} else {
    			left = this.table.rowManager.scrollLeft;

    			this.table.rowManager.setData(data[this.dataReceivedNames.data], false, this.initialLoad && this.page == 1);

    			this.table.rowManager.scrollHorizontal(left);

    			this.table.columnManager.scrollHorizontal(left);

    			this.table.options.pageLoaded.call(this.table, this.getPage());
    		}

    		this.initialLoad = false;
    	} else {
    		console.warn("Remote Pagination Error - Server response missing '" + this.dataReceivedNames.data + "' property");
    	}
    };

    //handle the footer element being redrawn
    Page.prototype.footerRedraw = function () {
    	var footer = this.table.footerManager.element;

    	if (Math.ceil(footer.clientWidth) - footer.scrollWidth < 0) {
    		this.pagesElement.style.display = 'none';
    	} else {
    		this.pagesElement.style.display = '';

    		if (Math.ceil(footer.clientWidth) - footer.scrollWidth < 0) {
    			this.pagesElement.style.display = 'none';
    		}
    	}
    };

    //set the paramter names for pagination requests
    Page.prototype.paginationDataSentNames = {
    	"page": "page",
    	"size": "size",
    	"sorters": "sorters",
    	// "sort_dir":"sort_dir",
    	"filters": "filters"
    	// "filter_value":"filter_value",
    	// "filter_type":"filter_type",
    };

    //set the property names for pagination responses
    Page.prototype.paginationDataReceivedNames = {
    	"current_page": "current_page",
    	"last_page": "last_page",
    	"data": "data"
    };

    Tabulator.prototype.registerModule("page", Page);

    var Persistence = function Persistence(table) {
    	this.table = table; //hold Tabulator object
    	this.mode = "";
    	this.id = "";
    	// this.persistProps = ["field", "width", "visible"];
    	this.defWatcherBlock = false;
    	this.config = {};
    	this.readFunc = false;
    	this.writeFunc = false;
    };

    // Test for whether localStorage is available for use.
    Persistence.prototype.localStorageTest = function () {
    	var testKey = "_tabulator_test";

    	try {
    		window.localStorage.setItem(testKey, testKey);
    		window.localStorage.removeItem(testKey);
    		return true;
    	} catch (e) {
    		return false;
    	}
    };

    //setup parameters
    Persistence.prototype.initialize = function () {
    	//determine persistent layout storage type

    	var mode = this.table.options.persistenceMode,
    	    id = this.table.options.persistenceID,
    	    retreivedData;

    	this.mode = mode !== true ? mode : this.localStorageTest() ? "local" : "cookie";

    	if (this.table.options.persistenceReaderFunc) {
    		if (typeof this.table.options.persistenceReaderFunc === "function") {
    			this.readFunc = this.table.options.persistenceReaderFunc;
    		} else {
    			if (this.readers[this.table.options.persistenceReaderFunc]) {
    				this.readFunc = this.readers[this.table.options.persistenceReaderFunc];
    			} else {
    				console.warn("Persistence Read Error - invalid reader set", this.table.options.persistenceReaderFunc);
    			}
    		}
    	} else {
    		if (this.readers[this.mode]) {
    			this.readFunc = this.readers[this.mode];
    		} else {
    			console.warn("Persistence Read Error - invalid reader set", this.mode);
    		}
    	}

    	if (this.table.options.persistenceWriterFunc) {
    		if (typeof this.table.options.persistenceWriterFunc === "function") {
    			this.writeFunc = this.table.options.persistenceWriterFunc;
    		} else {
    			if (this.readers[this.table.options.persistenceWriterFunc]) {
    				this.writeFunc = this.readers[this.table.options.persistenceWriterFunc];
    			} else {
    				console.warn("Persistence Write Error - invalid reader set", this.table.options.persistenceWriterFunc);
    			}
    		}
    	} else {
    		if (this.writers[this.mode]) {
    			this.writeFunc = this.writers[this.mode];
    		} else {
    			console.warn("Persistence Write Error - invalid writer set", this.mode);
    		}
    	}

    	//set storage tag
    	this.id = "tabulator-" + (id || this.table.element.getAttribute("id") || "");

    	this.config = {
    		sort: this.table.options.persistence === true || this.table.options.persistence.sort,
    		filter: this.table.options.persistence === true || this.table.options.persistence.filter,
    		group: this.table.options.persistence === true || this.table.options.persistence.group,
    		page: this.table.options.persistence === true || this.table.options.persistence.page,
    		columns: this.table.options.persistence === true ? ["title", "width", "visible"] : this.table.options.persistence.columns
    	};

    	//load pagination data if needed
    	if (this.config.page) {
    		retreivedData = this.retreiveData("page");

    		if (retreivedData) {
    			if (typeof retreivedData.paginationSize !== "undefined" && (this.config.page === true || this.config.page.size)) {
    				this.table.options.paginationSize = retreivedData.paginationSize;
    			}

    			if (typeof retreivedData.paginationInitialPage !== "undefined" && (this.config.page === true || this.config.page.page)) {
    				this.table.options.paginationInitialPage = retreivedData.paginationInitialPage;
    			}
    		}
    	}

    	//load group data if needed
    	if (this.config.group) {
    		retreivedData = this.retreiveData("group");

    		if (retreivedData) {
    			if (typeof retreivedData.groupBy !== "undefined" && (this.config.group === true || this.config.group.groupBy)) {
    				this.table.options.groupBy = retreivedData.groupBy;
    			}
    			if (typeof retreivedData.groupStartOpen !== "undefined" && (this.config.group === true || this.config.group.groupStartOpen)) {
    				this.table.options.groupStartOpen = retreivedData.groupStartOpen;
    			}
    			if (typeof retreivedData.groupHeader !== "undefined" && (this.config.group === true || this.config.group.groupHeader)) {
    				this.table.options.groupHeader = retreivedData.groupHeader;
    			}
    		}
    	}

    	if (this.config.columns) {
    		this.table.options.columns = this.load("columns", this.table.options.columns);
    	}
    };

    Persistence.prototype.initializeColumn = function (column) {
    	var self = this,
    	    def,
    	    keys;

    	if (this.config.columns) {
    		this.defWatcherBlock = true;

    		def = column.getDefinition();

    		keys = this.config.columns === true ? Object.keys(def) : this.config.columns;

    		keys.forEach(function (key) {
    			var props = Object.getOwnPropertyDescriptor(def, key);
    			var value = def[key];
    			if (props) {
    				Object.defineProperty(def, key, {
    					set: function set(newValue) {
    						value = newValue;

    						if (!self.defWatcherBlock) {
    							self.save("columns");
    						}

    						if (props.set) {
    							props.set(newValue);
    						}
    					},
    					get: function get() {
    						if (props.get) {
    							props.get();
    						}
    						return value;
    					}
    				});
    			}
    		});

    		this.defWatcherBlock = false;
    	}
    };

    //load saved definitions
    Persistence.prototype.load = function (type, current) {
    	var data = this.retreiveData(type);

    	if (current) {
    		data = data ? this.mergeDefinition(current, data) : current;
    	}

    	return data;
    };

    //retreive data from memory
    Persistence.prototype.retreiveData = function (type) {
    	return this.readFunc ? this.readFunc(this.id, type) : false;
    };

    //merge old and new column definitions
    Persistence.prototype.mergeDefinition = function (oldCols, newCols) {
    	var self = this,
    	    output = [];

    	// oldCols = oldCols || [];
    	newCols = newCols || [];

    	newCols.forEach(function (column, to) {

    		var from = self._findColumn(oldCols, column),
    		    keys;

    		if (from) {

    			if (self.config.columns === true || self.config.columns == undefined) {
    				keys = Object.keys(from);
    				keys.push("width");
    			} else {
    				keys = self.config.columns;
    			}

    			keys.forEach(function (key) {
    				if (key !== "columns" && typeof column[key] !== "undefined") {
    					from[key] = column[key];
    				}
    			});

    			if (from.columns) {
    				from.columns = self.mergeDefinition(from.columns, column.columns);
    			}

    			output.push(from);
    		}
    	});

    	oldCols.forEach(function (column, i) {
    		var from = self._findColumn(newCols, column);
    		if (!from) {
    			if (output.length > i) {
    				output.splice(i, 0, column);
    			} else {
    				output.push(column);
    			}
    		}
    	});

    	return output;
    };

    //find matching columns
    Persistence.prototype._findColumn = function (columns, subject) {
    	var type = subject.columns ? "group" : subject.field ? "field" : "object";

    	return columns.find(function (col) {
    		switch (type) {
    			case "group":
    				return col.title === subject.title && col.columns.length === subject.columns.length;

    			case "field":
    				return col.field === subject.field;

    			case "object":
    				return col === subject;
    		}
    	});
    };

    //save data
    Persistence.prototype.save = function (type) {
    	var data = {};

    	switch (type) {
    		case "columns":
    			data = this.parseColumns(this.table.columnManager.getColumns());
    			break;

    		case "filter":
    			data = this.table.modules.filter.getFilters();
    			break;

    		case "sort":
    			data = this.validateSorters(this.table.modules.sort.getSort());
    			break;

    		case "group":
    			data = this.getGroupConfig();
    			break;

    		case "page":
    			data = this.getPageConfig();
    			break;
    	}

    	if (this.writeFunc) {
    		this.writeFunc(this.id, type, data);
    	}
    };

    //ensure sorters contain no function data
    Persistence.prototype.validateSorters = function (data) {
    	data.forEach(function (item) {
    		item.column = item.field;
    		delete item.field;
    	});

    	return data;
    };

    Persistence.prototype.getGroupConfig = function () {
    	var data = {};

    	if (this.config.group) {
    		if (this.config.group === true || this.config.group.groupBy) {
    			data.groupBy = this.table.options.groupBy;
    		}

    		if (this.config.group === true || this.config.group.groupStartOpen) {
    			data.groupStartOpen = this.table.options.groupStartOpen;
    		}

    		if (this.config.group === true || this.config.group.groupHeader) {
    			data.groupHeader = this.table.options.groupHeader;
    		}
    	}

    	return data;
    };

    Persistence.prototype.getPageConfig = function () {
    	var data = {};

    	if (this.config.page) {
    		if (this.config.page === true || this.config.page.size) {
    			data.paginationSize = this.table.modules.page.getPageSize();
    		}

    		if (this.config.page === true || this.config.page.page) {
    			data.paginationInitialPage = this.table.modules.page.getPage();
    		}
    	}

    	return data;
    };

    //parse columns for data to store
    Persistence.prototype.parseColumns = function (columns) {
    	var self = this,
    	    definitions = [],
    	    excludedKeys = ["headerContextMenu", "headerMenu", "contextMenu", "clickMenu"];

    	columns.forEach(function (column) {
    		var defStore = {},
    		    colDef = column.getDefinition(),
    		    keys;

    		if (column.isGroup) {
    			defStore.title = colDef.title;
    			defStore.columns = self.parseColumns(column.getColumns());
    		} else {
    			defStore.field = column.getField();

    			if (self.config.columns === true || self.config.columns == undefined) {
    				keys = Object.keys(colDef);
    				keys.push("width");
    			} else {
    				keys = self.config.columns;
    			}

    			keys.forEach(function (key) {

    				switch (key) {
    					case "width":
    						defStore.width = column.getWidth();
    						break;
    					case "visible":
    						defStore.visible = column.visible;
    						break;

    					default:
    						if (typeof colDef[key] !== "function" && excludedKeys.indexOf(key) === -1) {
    							defStore[key] = colDef[key];
    						}
    				}
    			});
    		}

    		definitions.push(defStore);
    	});

    	return definitions;
    };

    // read peristence information from storage
    Persistence.prototype.readers = {
    	local: function local(id, type) {
    		var data = localStorage.getItem(id + "-" + type);

    		return data ? JSON.parse(data) : false;
    	},
    	cookie: function cookie(id, type) {
    		var cookie = document.cookie,
    		    key = id + "-" + type,
    		    cookiePos = cookie.indexOf(key + "="),
    		    end,
    		    data;

    		//if cookie exists, decode and load column data into tabulator
    		if (cookiePos > -1) {
    			cookie = cookie.substr(cookiePos);

    			end = cookie.indexOf(";");

    			if (end > -1) {
    				cookie = cookie.substr(0, end);
    			}

    			data = cookie.replace(key + "=", "");
    		}

    		return data ? JSON.parse(data) : false;
    	}
    };

    //write persistence information to storage
    Persistence.prototype.writers = {
    	local: function local(id, type, data) {
    		localStorage.setItem(id + "-" + type, JSON.stringify(data));
    	},
    	cookie: function cookie(id, type, data) {
    		var expireDate = new Date();

    		expireDate.setDate(expireDate.getDate() + 10000);

    		document.cookie = id + "-" + type + "=" + JSON.stringify(data) + "; expires=" + expireDate.toUTCString();
    	}
    };

    Tabulator.prototype.registerModule("persistence", Persistence);

    var Print = function Print(table) {
    	this.table = table; //hold Tabulator object
    	this.element = false;
    	this.manualBlock = false;
    };

    Print.prototype.initialize = function () {
    	window.addEventListener("beforeprint", this.replaceTable.bind(this));
    	window.addEventListener("afterprint", this.cleanup.bind(this));
    };

    Print.prototype.replaceTable = function () {
    	if (!this.manualBlock) {
    		this.element = document.createElement("div");
    		this.element.classList.add("tabulator-print-table");

    		this.element.appendChild(this.table.modules.export.genereateTable(this.table.options.printConfig, this.table.options.printStyled, this.table.options.printRowRange, "print"));

    		this.table.element.style.display = "none";

    		this.table.element.parentNode.insertBefore(this.element, this.table.element);
    	}
    };

    Print.prototype.cleanup = function () {
    	document.body.classList.remove("tabulator-print-fullscreen-hide");

    	if (this.element && this.element.parentNode) {
    		this.element.parentNode.removeChild(this.element);
    		this.table.element.style.display = "";
    	}
    };

    Print.prototype.printFullscreen = function (visible, style, config) {
    	var scrollX = window.scrollX,
    	    scrollY = window.scrollY,
    	    headerEl = document.createElement("div"),
    	    footerEl = document.createElement("div"),
    	    tableEl = this.table.modules.export.genereateTable(typeof config != "undefined" ? config : this.table.options.printConfig, typeof style != "undefined" ? style : this.table.options.printStyled, visible, "print"),
    	    headerContent,
    	    footerContent;

    	this.manualBlock = true;

    	this.element = document.createElement("div");
    	this.element.classList.add("tabulator-print-fullscreen");

    	if (this.table.options.printHeader) {
    		headerEl.classList.add("tabulator-print-header");

    		headerContent = typeof this.table.options.printHeader == "function" ? this.table.options.printHeader.call(this.table) : this.table.options.printHeader;

    		if (typeof headerContent == "string") {
    			headerEl.innerHTML = headerContent;
    		} else {
    			headerEl.appendChild(headerContent);
    		}

    		this.element.appendChild(headerEl);
    	}

    	this.element.appendChild(tableEl);

    	if (this.table.options.printFooter) {
    		footerEl.classList.add("tabulator-print-footer");

    		footerContent = typeof this.table.options.printFooter == "function" ? this.table.options.printFooter.call(this.table) : this.table.options.printFooter;

    		if (typeof footerContent == "string") {
    			footerEl.innerHTML = footerContent;
    		} else {
    			footerEl.appendChild(footerContent);
    		}

    		this.element.appendChild(footerEl);
    	}

    	document.body.classList.add("tabulator-print-fullscreen-hide");
    	document.body.appendChild(this.element);

    	if (this.table.options.printFormatter) {
    		this.table.options.printFormatter(this.element, tableEl);
    	}

    	window.print();

    	this.cleanup();

    	window.scrollTo(scrollX, scrollY);

    	this.manualBlock = false;
    };

    Tabulator.prototype.registerModule("print", Print);
    var ReactiveData = function ReactiveData(table) {
    	this.table = table; //hold Tabulator object
    	this.data = false;
    	this.blocked = false; //block reactivity while performing update
    	this.origFuncs = {}; // hold original data array functions to allow replacement after data is done with
    	this.currentVersion = 0;
    };

    ReactiveData.prototype.watchData = function (data) {
    	var self = this,
    	    version;

    	this.currentVersion++;

    	version = this.currentVersion;

    	self.unwatchData();

    	self.data = data;

    	//override array push function
    	self.origFuncs.push = data.push;

    	Object.defineProperty(self.data, "push", {
    		enumerable: false,
    		configurable: true,
    		value: function value() {
    			var args = Array.from(arguments);

    			if (!self.blocked && version === self.currentVersion) {
    				args.forEach(function (arg) {
    					self.table.rowManager.addRowActual(arg, false);
    				});
    			}

    			return self.origFuncs.push.apply(data, arguments);
    		}
    	});

    	//override array unshift function
    	self.origFuncs.unshift = data.unshift;

    	Object.defineProperty(self.data, "unshift", {
    		enumerable: false,
    		configurable: true,
    		value: function value() {
    			var args = Array.from(arguments);

    			if (!self.blocked && version === self.currentVersion) {
    				args.forEach(function (arg) {
    					self.table.rowManager.addRowActual(arg, true);
    				});
    			}

    			return self.origFuncs.unshift.apply(data, arguments);
    		}
    	});

    	//override array shift function
    	self.origFuncs.shift = data.shift;

    	Object.defineProperty(self.data, "shift", {
    		enumerable: false,
    		configurable: true,
    		value: function value() {
    			var row;

    			if (!self.blocked && version === self.currentVersion) {
    				if (self.data.length) {
    					row = self.table.rowManager.getRowFromDataObject(self.data[0]);

    					if (row) {
    						row.deleteActual();
    					}
    				}
    			}

    			return self.origFuncs.shift.call(data);
    		}
    	});

    	//override array pop function
    	self.origFuncs.pop = data.pop;

    	Object.defineProperty(self.data, "pop", {
    		enumerable: false,
    		configurable: true,
    		value: function value() {
    			var row;
    			if (!self.blocked && version === self.currentVersion) {
    				if (self.data.length) {
    					row = self.table.rowManager.getRowFromDataObject(self.data[self.data.length - 1]);

    					if (row) {
    						row.deleteActual();
    					}
    				}
    			}
    			return self.origFuncs.pop.call(data);
    		}
    	});

    	//override array splice function
    	self.origFuncs.splice = data.splice;

    	Object.defineProperty(self.data, "splice", {
    		enumerable: false,
    		configurable: true,
    		value: function value() {
    			var args = Array.from(arguments),
    			    start = args[0] < 0 ? data.length + args[0] : args[0],
    			    end = args[1],
    			    newRows = args[2] ? args.slice(2) : false,
    			    startRow;

    			if (!self.blocked && version === self.currentVersion) {

    				//add new rows
    				if (newRows) {
    					startRow = data[start] ? self.table.rowManager.getRowFromDataObject(data[start]) : false;

    					if (startRow) {
    						newRows.forEach(function (rowData) {
    							self.table.rowManager.addRowActual(rowData, true, startRow, true);
    						});
    					} else {
    						newRows = newRows.slice().reverse();

    						newRows.forEach(function (rowData) {
    							self.table.rowManager.addRowActual(rowData, true, false, true);
    						});
    					}
    				}

    				//delete removed rows
    				if (end !== 0) {
    					var oldRows = data.slice(start, typeof args[1] === "undefined" ? args[1] : start + end);

    					oldRows.forEach(function (rowData, i) {
    						var row = self.table.rowManager.getRowFromDataObject(rowData);

    						if (row) {
    							row.deleteActual(i !== oldRows.length - 1);
    						}
    					});
    				}

    				if (newRows || end !== 0) {
    					self.table.rowManager.reRenderInPosition();
    				}
    			}

    			return self.origFuncs.splice.apply(data, arguments);
    		}
    	});
    };

    ReactiveData.prototype.unwatchData = function () {
    	if (this.data !== false) {
    		for (var key in this.origFuncs) {
    			Object.defineProperty(this.data, key, {
    				enumerable: true,
    				configurable: true,
    				writable: true,
    				value: this.origFuncs.key
    			});
    		}
    	}
    };

    ReactiveData.prototype.watchRow = function (row) {
    	var data = row.getData();

    	this.blocked = true;

    	for (var key in data) {
    		this.watchKey(row, data, key);
    	}

    	if (this.table.options.dataTree) {
    		this.watchTreeChildren(row);
    	}

    	this.blocked = false;
    };

    ReactiveData.prototype.watchTreeChildren = function (row) {
    	var self = this,
    	    childField = row.getData()[this.table.options.dataTreeChildField],
    	    origFuncs = {};

    	function rebuildTree() {
    		self.table.modules.dataTree.initializeRow(row);
    		self.table.modules.dataTree.layoutRow(row);
    		self.table.rowManager.refreshActiveData("tree", false, true);
    	}

    	if (childField) {

    		origFuncs.push = childField.push;

    		Object.defineProperty(childField, "push", {
    			enumerable: false,
    			configurable: true,
    			value: function value() {
    				var result = origFuncs.push.apply(childField, arguments);

    				rebuildTree();

    				return result;
    			}
    		});

    		origFuncs.unshift = childField.unshift;

    		Object.defineProperty(childField, "unshift", {
    			enumerable: false,
    			configurable: true,
    			value: function value() {
    				var result = origFuncs.unshift.apply(childField, arguments);

    				rebuildTree();

    				return result;
    			}
    		});

    		origFuncs.shift = childField.shift;

    		Object.defineProperty(childField, "shift", {
    			enumerable: false,
    			configurable: true,
    			value: function value() {
    				var result = origFuncs.shift.call(childField);

    				rebuildTree();

    				return result;
    			}
    		});

    		origFuncs.pop = childField.pop;

    		Object.defineProperty(childField, "pop", {
    			enumerable: false,
    			configurable: true,
    			value: function value() {
    				var result = origFuncs.pop.call(childField);

    				rebuildTree();

    				return result;
    			}
    		});

    		origFuncs.splice = childField.splice;

    		Object.defineProperty(childField, "splice", {
    			enumerable: false,
    			configurable: true,
    			value: function value() {
    				var result = origFuncs.splice.apply(childField, arguments);

    				rebuildTree();

    				return result;
    			}
    		});
    	}
    };

    ReactiveData.prototype.watchKey = function (row, data, key) {
    	var self = this,
    	    props = Object.getOwnPropertyDescriptor(data, key),
    	    value = data[key],
    	    version = this.currentVersion;

    	Object.defineProperty(data, key, {
    		set: function set(newValue) {
    			value = newValue;
    			if (!self.blocked && version === self.currentVersion) {
    				var update = {};
    				update[key] = newValue;
    				row.updateData(update);
    			}

    			if (props.set) {
    				props.set(newValue);
    			}
    		},
    		get: function get() {

    			if (props.get) {
    				props.get();
    			}

    			return value;
    		}
    	});
    };

    ReactiveData.prototype.unwatchRow = function (row) {
    	var data = row.getData();

    	for (var key in data) {
    		Object.defineProperty(data, key, {
    			value: data[key]
    		});
    	}
    };

    ReactiveData.prototype.block = function () {
    	this.blocked = true;
    };

    ReactiveData.prototype.unblock = function () {
    	this.blocked = false;
    };

    Tabulator.prototype.registerModule("reactiveData", ReactiveData);

    var ResizeColumns = function ResizeColumns(table) {
    	this.table = table; //hold Tabulator object
    	this.startColumn = false;
    	this.startX = false;
    	this.startWidth = false;
    	this.handle = null;
    	this.prevHandle = null;
    };

    ResizeColumns.prototype.initializeColumn = function (type, column, element) {
    	var self = this,
    	    variableHeight = false,
    	    mode = this.table.options.resizableColumns;

    	//set column resize mode
    	if (type === "header") {
    		variableHeight = column.definition.formatter == "textarea" || column.definition.variableHeight;
    		column.modules.resize = { variableHeight: variableHeight };
    	}

    	if (mode === true || mode == type) {

    		var handle = document.createElement('div');
    		handle.className = "tabulator-col-resize-handle";

    		var prevHandle = document.createElement('div');
    		prevHandle.className = "tabulator-col-resize-handle prev";

    		handle.addEventListener("click", function (e) {
    			e.stopPropagation();
    		});

    		var handleDown = function handleDown(e) {
    			var nearestColumn = column.getLastColumn();

    			if (nearestColumn && self._checkResizability(nearestColumn)) {
    				self.startColumn = column;
    				self._mouseDown(e, nearestColumn, handle);
    			}
    		};

    		handle.addEventListener("mousedown", handleDown);
    		handle.addEventListener("touchstart", handleDown, { passive: true });

    		//reszie column on  double click
    		handle.addEventListener("dblclick", function (e) {
    			var col = column.getLastColumn();

    			if (col && self._checkResizability(col)) {
    				e.stopPropagation();
    				col.reinitializeWidth(true);
    			}
    		});

    		prevHandle.addEventListener("click", function (e) {
    			e.stopPropagation();
    		});

    		var prevHandleDown = function prevHandleDown(e) {
    			var nearestColumn, colIndex, prevColumn;

    			nearestColumn = column.getFirstColumn();

    			if (nearestColumn) {
    				colIndex = self.table.columnManager.findColumnIndex(nearestColumn);
    				prevColumn = colIndex > 0 ? self.table.columnManager.getColumnByIndex(colIndex - 1) : false;

    				if (prevColumn && self._checkResizability(prevColumn)) {
    					self.startColumn = column;
    					self._mouseDown(e, prevColumn, prevHandle);
    				}
    			}
    		};

    		prevHandle.addEventListener("mousedown", prevHandleDown);
    		prevHandle.addEventListener("touchstart", prevHandleDown, { passive: true });

    		//resize column on double click
    		prevHandle.addEventListener("dblclick", function (e) {
    			var nearestColumn, colIndex, prevColumn;

    			nearestColumn = column.getFirstColumn();

    			if (nearestColumn) {
    				colIndex = self.table.columnManager.findColumnIndex(nearestColumn);
    				prevColumn = colIndex > 0 ? self.table.columnManager.getColumnByIndex(colIndex - 1) : false;

    				if (prevColumn && self._checkResizability(prevColumn)) {
    					e.stopPropagation();
    					prevColumn.reinitializeWidth(true);
    				}
    			}
    		});

    		element.appendChild(handle);
    		element.appendChild(prevHandle);
    	}
    };

    ResizeColumns.prototype._checkResizability = function (column) {
    	return typeof column.definition.resizable != "undefined" ? column.definition.resizable : this.table.options.resizableColumns;
    };

    ResizeColumns.prototype._mouseDown = function (e, column, handle) {
    	var self = this;

    	self.table.element.classList.add("tabulator-block-select");

    	function mouseMove(e) {
    		// self.table.columnManager.tempScrollBlock();

    		if (self.table.rtl) {
    			column.setWidth(self.startWidth - ((typeof e.screenX === "undefined" ? e.touches[0].screenX : e.screenX) - self.startX));
    		} else {
    			column.setWidth(self.startWidth + ((typeof e.screenX === "undefined" ? e.touches[0].screenX : e.screenX) - self.startX));
    		}

    		if (self.table.options.virtualDomHoz) {
    			self.table.vdomHoz.reinitialize(true);
    		}

    		if (!self.table.browserSlow && column.modules.resize && column.modules.resize.variableHeight) {
    			column.checkCellHeights();
    		}
    	}

    	function mouseUp(e) {

    		//block editor from taking action while resizing is taking place
    		if (self.startColumn.modules.edit) {
    			self.startColumn.modules.edit.blocked = false;
    		}

    		if (self.table.browserSlow && column.modules.resize && column.modules.resize.variableHeight) {
    			column.checkCellHeights();
    		}

    		document.body.removeEventListener("mouseup", mouseUp);
    		document.body.removeEventListener("mousemove", mouseMove);

    		handle.removeEventListener("touchmove", mouseMove);
    		handle.removeEventListener("touchend", mouseUp);

    		self.table.element.classList.remove("tabulator-block-select");

    		if (self.table.options.persistence && self.table.modExists("persistence", true) && self.table.modules.persistence.config.columns) {
    			self.table.modules.persistence.save("columns");
    		}

    		self.table.options.columnResized.call(self.table, column.getComponent());
    	}

    	e.stopPropagation(); //prevent resize from interfereing with movable columns

    	//block editor from taking action while resizing is taking place
    	if (self.startColumn.modules.edit) {
    		self.startColumn.modules.edit.blocked = true;
    	}

    	self.startX = typeof e.screenX === "undefined" ? e.touches[0].screenX : e.screenX;
    	self.startWidth = column.getWidth();

    	document.body.addEventListener("mousemove", mouseMove);
    	document.body.addEventListener("mouseup", mouseUp);
    	handle.addEventListener("touchmove", mouseMove, { passive: true });
    	handle.addEventListener("touchend", mouseUp);
    };

    Tabulator.prototype.registerModule("resizeColumns", ResizeColumns);
    var ResizeRows = function ResizeRows(table) {
    	this.table = table; //hold Tabulator object
    	this.startColumn = false;
    	this.startY = false;
    	this.startHeight = false;
    	this.handle = null;
    	this.prevHandle = null;
    };

    ResizeRows.prototype.initializeRow = function (row) {
    	var self = this,
    	    rowEl = row.getElement();

    	var handle = document.createElement('div');
    	handle.className = "tabulator-row-resize-handle";

    	var prevHandle = document.createElement('div');
    	prevHandle.className = "tabulator-row-resize-handle prev";

    	handle.addEventListener("click", function (e) {
    		e.stopPropagation();
    	});

    	var handleDown = function handleDown(e) {
    		self.startRow = row;
    		self._mouseDown(e, row, handle);
    	};

    	handle.addEventListener("mousedown", handleDown);
    	handle.addEventListener("touchstart", handleDown, { passive: true });

    	prevHandle.addEventListener("click", function (e) {
    		e.stopPropagation();
    	});

    	var prevHandleDown = function prevHandleDown(e) {
    		var prevRow = self.table.rowManager.prevDisplayRow(row);

    		if (prevRow) {
    			self.startRow = prevRow;
    			self._mouseDown(e, prevRow, prevHandle);
    		}
    	};

    	prevHandle.addEventListener("mousedown", prevHandleDown);
    	prevHandle.addEventListener("touchstart", prevHandleDown, { passive: true });

    	rowEl.appendChild(handle);
    	rowEl.appendChild(prevHandle);
    };

    ResizeRows.prototype._mouseDown = function (e, row, handle) {
    	var self = this;

    	self.table.element.classList.add("tabulator-block-select");

    	function mouseMove(e) {
    		row.setHeight(self.startHeight + ((typeof e.screenY === "undefined" ? e.touches[0].screenY : e.screenY) - self.startY));
    	}

    	function mouseUp(e) {

    		// //block editor from taking action while resizing is taking place
    		// if(self.startColumn.modules.edit){
    		// 	self.startColumn.modules.edit.blocked = false;
    		// }

    		document.body.removeEventListener("mouseup", mouseMove);
    		document.body.removeEventListener("mousemove", mouseMove);

    		handle.removeEventListener("touchmove", mouseMove);
    		handle.removeEventListener("touchend", mouseUp);

    		self.table.element.classList.remove("tabulator-block-select");

    		self.table.options.rowResized.call(this.table, row.getComponent());
    	}

    	e.stopPropagation(); //prevent resize from interfereing with movable columns

    	//block editor from taking action while resizing is taking place
    	// if(self.startColumn.modules.edit){
    	// 	self.startColumn.modules.edit.blocked = true;
    	// }

    	self.startY = typeof e.screenY === "undefined" ? e.touches[0].screenY : e.screenY;
    	self.startHeight = row.getHeight();

    	document.body.addEventListener("mousemove", mouseMove);
    	document.body.addEventListener("mouseup", mouseUp);

    	handle.addEventListener("touchmove", mouseMove, { passive: true });
    	handle.addEventListener("touchend", mouseUp);
    };

    Tabulator.prototype.registerModule("resizeRows", ResizeRows);
    var ResizeTable = function ResizeTable(table) {
    	this.table = table; //hold Tabulator object
    	this.binding = false;
    	this.observer = false;
    	this.containerObserver = false;

    	this.tableHeight = 0;
    	this.tableWidth = 0;
    	this.containerHeight = 0;
    	this.containerWidth = 0;

    	this.autoResize = false;
    };

    ResizeTable.prototype.initialize = function (row) {
    	var _this83 = this;

    	var table = this.table,
    	    tableStyle;

    	this.tableHeight = table.element.clientHeight;
    	this.tableWidth = table.element.clientWidth;

    	if (table.element.parentNode) {
    		this.containerHeight = table.element.parentNode.clientHeight;
    		this.containerWidth = table.element.parentNode.clientWidth;
    	}

    	if (typeof ResizeObserver !== "undefined" && table.rowManager.getRenderMode() === "virtual") {

    		this.autoResize = true;

    		this.observer = new ResizeObserver(function (entry) {
    			if (!table.browserMobile || table.browserMobile && !table.modules.edit.currentCell) {

    				var nodeHeight = Math.floor(entry[0].contentRect.height);
    				var nodeWidth = Math.floor(entry[0].contentRect.width);

    				if (_this83.tableHeight != nodeHeight || _this83.tableWidth != nodeWidth) {
    					_this83.tableHeight = nodeHeight;
    					_this83.tableWidth = nodeWidth;

    					if (table.element.parentNode) {
    						_this83.containerHeight = table.element.parentNode.clientHeight;
    						_this83.containerWidth = table.element.parentNode.clientWidth;
    					}

    					if (table.options.virtualDomHoz) {
    						table.vdomHoz.reinitialize(true);
    					}

    					table.redraw();
    				}
    			}
    		});

    		this.observer.observe(table.element);

    		tableStyle = window.getComputedStyle(table.element);

    		if (this.table.element.parentNode && !this.table.rowManager.fixedHeight && (tableStyle.getPropertyValue("max-height") || tableStyle.getPropertyValue("min-height"))) {

    			this.containerObserver = new ResizeObserver(function (entry) {
    				if (!table.browserMobile || table.browserMobile && !table.modules.edit.currentCell) {

    					var nodeHeight = Math.floor(entry[0].contentRect.height);
    					var nodeWidth = Math.floor(entry[0].contentRect.width);

    					if (_this83.containerHeight != nodeHeight || _this83.containerWidth != nodeWidth) {
    						_this83.containerHeight = nodeHeight;
    						_this83.containerWidth = nodeWidth;
    						_this83.tableHeight = table.element.clientHeight;
    						_this83.tableWidth = table.element.clientWidth;
    					}

    					if (table.options.virtualDomHoz) {
    						table.vdomHoz.reinitialize(true);
    					}

    					table.redraw();
    				}
    			});

    			this.containerObserver.observe(this.table.element.parentNode);
    		}
    	} else {
    		this.binding = function () {
    			if (!table.browserMobile || table.browserMobile && !table.modules.edit.currentCell) {
    				if (table.options.virtualDomHoz) {
    					table.vdomHoz.reinitialize(true);
    				}

    				table.redraw();
    			}
    		};

    		window.addEventListener("resize", this.binding);
    	}
    };

    ResizeTable.prototype.clearBindings = function (row) {
    	if (this.binding) {
    		window.removeEventListener("resize", this.binding);
    	}

    	if (this.observer) {
    		this.observer.unobserve(this.table.element);
    	}

    	if (this.containerObserver) {
    		this.containerObserver.unobserve(this.table.element.parentNode);
    	}
    };

    Tabulator.prototype.registerModule("resizeTable", ResizeTable);
    var ResponsiveLayout = function ResponsiveLayout(table) {
    	this.table = table; //hold Tabulator object
    	this.columns = [];
    	this.hiddenColumns = [];
    	this.mode = "";
    	this.index = 0;
    	this.collapseFormatter = [];
    	this.collapseStartOpen = true;
    	this.collapseHandleColumn = false;
    };

    //generate resposive columns list
    ResponsiveLayout.prototype.initialize = function () {
    	var self = this,
    	    columns = [];

    	this.mode = this.table.options.responsiveLayout;
    	this.collapseFormatter = this.table.options.responsiveLayoutCollapseFormatter || this.formatCollapsedData;
    	this.collapseStartOpen = this.table.options.responsiveLayoutCollapseStartOpen;
    	this.hiddenColumns = [];

    	//detemine level of responsivity for each column
    	this.table.columnManager.columnsByIndex.forEach(function (column, i) {
    		if (column.modules.responsive) {
    			if (column.modules.responsive.order && column.modules.responsive.visible) {
    				column.modules.responsive.index = i;
    				columns.push(column);

    				if (!column.visible && self.mode === "collapse") {
    					self.hiddenColumns.push(column);
    				}
    			}
    		}
    	});

    	//sort list by responsivity
    	columns = columns.reverse();
    	columns = columns.sort(function (a, b) {
    		var diff = b.modules.responsive.order - a.modules.responsive.order;
    		return diff || b.modules.responsive.index - a.modules.responsive.index;
    	});

    	this.columns = columns;

    	if (this.mode === "collapse") {
    		this.generateCollapsedContent();
    	}

    	//assign collapse column
    	for (var _iterator = this.table.columnManager.columnsByIndex, _isArray = Array.isArray(_iterator), _i17 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    		var _ref;

    		if (_isArray) {
    			if (_i17 >= _iterator.length) break;
    			_ref = _iterator[_i17++];
    		} else {
    			_i17 = _iterator.next();
    			if (_i17.done) break;
    			_ref = _i17.value;
    		}

    		var col = _ref;

    		if (col.definition.formatter == "responsiveCollapse") {
    			this.collapseHandleColumn = col;
    			break;
    		}
    	}

    	if (this.collapseHandleColumn) {
    		if (this.hiddenColumns.length) {
    			this.collapseHandleColumn.show();
    		} else {
    			this.collapseHandleColumn.hide();
    		}
    	}
    };

    //define layout information
    ResponsiveLayout.prototype.initializeColumn = function (column) {
    	var def = column.getDefinition();

    	column.modules.responsive = { order: typeof def.responsive === "undefined" ? 1 : def.responsive, visible: def.visible === false ? false : true };
    };

    ResponsiveLayout.prototype.initializeRow = function (row) {
    	var el;

    	if (row.type !== "calc") {
    		el = document.createElement("div");
    		el.classList.add("tabulator-responsive-collapse");

    		row.modules.responsiveLayout = {
    			element: el,
    			open: this.collapseStartOpen
    		};

    		if (!this.collapseStartOpen) {
    			el.style.display = 'none';
    		}
    	}
    };

    ResponsiveLayout.prototype.layoutRow = function (row) {
    	var rowEl = row.getElement();

    	if (row.modules.responsiveLayout) {
    		rowEl.appendChild(row.modules.responsiveLayout.element);
    		this.generateCollapsedRowContent(row);
    	}
    };

    //update column visibility
    ResponsiveLayout.prototype.updateColumnVisibility = function (column, visible) {
    	if (column.modules.responsive) {
    		column.modules.responsive.visible = visible;
    		this.initialize();
    	}
    };

    ResponsiveLayout.prototype.hideColumn = function (column) {
    	var colCount = this.hiddenColumns.length;

    	column.hide(false, true);

    	if (this.mode === "collapse") {
    		this.hiddenColumns.unshift(column);
    		this.generateCollapsedContent();

    		if (this.collapseHandleColumn && !colCount) {
    			this.collapseHandleColumn.show();
    		}
    	}
    };

    ResponsiveLayout.prototype.showColumn = function (column) {
    	var index;

    	column.show(false, true);
    	//set column width to prevent calculation loops on uninitialized columns
    	column.setWidth(column.getWidth());

    	if (this.mode === "collapse") {
    		index = this.hiddenColumns.indexOf(column);

    		if (index > -1) {
    			this.hiddenColumns.splice(index, 1);
    		}

    		this.generateCollapsedContent();

    		if (this.collapseHandleColumn && !this.hiddenColumns.length) {
    			this.collapseHandleColumn.hide();
    		}
    	}
    };

    //redraw columns to fit space
    ResponsiveLayout.prototype.update = function () {
    	var self = this,
    	    working = true;

    	while (working) {

    		var width = self.table.modules.layout.getMode() == "fitColumns" ? self.table.columnManager.getFlexBaseWidth() : self.table.columnManager.getWidth();

    		var diff = (self.table.options.headerVisible ? self.table.columnManager.element.clientWidth : self.table.element.clientWidth) - width;

    		if (diff < 0) {
    			//table is too wide
    			var column = self.columns[self.index];

    			if (column) {
    				self.hideColumn(column);
    				self.index++;
    			} else {
    				working = false;
    			}
    		} else {

    			//table has spare space
    			var _column = self.columns[self.index - 1];

    			if (_column) {
    				if (diff > 0) {
    					if (diff >= _column.getWidth()) {
    						self.showColumn(_column);
    						self.index--;
    					} else {
    						working = false;
    					}
    				} else {
    					working = false;
    				}
    			} else {
    				working = false;
    			}
    		}

    		if (!self.table.rowManager.activeRowsCount) {
    			self.table.rowManager.renderEmptyScroll();
    		}
    	}
    };

    ResponsiveLayout.prototype.generateCollapsedContent = function () {
    	var self = this,
    	    rows = this.table.rowManager.getDisplayRows();

    	rows.forEach(function (row) {
    		self.generateCollapsedRowContent(row);
    	});
    };

    ResponsiveLayout.prototype.generateCollapsedRowContent = function (row) {
    	var el, contents;

    	if (row.modules.responsiveLayout) {
    		el = row.modules.responsiveLayout.element;

    		while (el.firstChild) {
    			el.removeChild(el.firstChild);
    		}contents = this.collapseFormatter(this.generateCollapsedRowData(row));
    		if (contents) {
    			el.appendChild(contents);
    		}
    	}
    };

    ResponsiveLayout.prototype.generateCollapsedRowData = function (row) {
    	var self = this,
    	    data = row.getData(),
    	    output = [],
    	    mockCellComponent;

    	this.hiddenColumns.forEach(function (column) {
    		var value = column.getFieldValue(data);

    		if (column.definition.title && column.field) {
    			if (column.modules.format && self.table.options.responsiveLayoutCollapseUseFormatters) {

    				mockCellComponent = {
    					value: false,
    					data: {},
    					getValue: function getValue() {
    						return value;
    					},
    					getData: function getData() {
    						return data;
    					},
    					getElement: function getElement() {
    						return document.createElement("div");
    					},
    					getRow: function getRow() {
    						return row.getComponent();
    					},
    					getColumn: function getColumn() {
    						return column.getComponent();
    					}
    				};

    				output.push({
    					field: column.field,
    					title: column.definition.title,
    					value: column.modules.format.formatter.call(self.table.modules.format, mockCellComponent, column.modules.format.params)
    				});
    			} else {
    				output.push({
    					field: column.field,
    					title: column.definition.title,
    					value: value
    				});
    			}
    		}
    	});

    	return output;
    };

    ResponsiveLayout.prototype.formatCollapsedData = function (data) {
    	var list = document.createElement("table");

    	data.forEach(function (item) {
    		var row = document.createElement("tr");
    		var titleData = document.createElement("td");
    		var valueData = document.createElement("td");
    		var node_content;

    		var titleHighlight = document.createElement("strong");
    		titleData.appendChild(titleHighlight);
    		this.table.modules.localize.bind("columns|" + item.field, function (text) {
    			titleHighlight.innerText = text || item.title;
    		});

    		if (item.value instanceof Node) {
    			node_content = document.createElement("div");
    			node_content.appendChild(item.value);
    			valueData.appendChild(node_content);
    		} else {
    			valueData.innerHTML = item.value;
    		}

    		row.appendChild(titleData);
    		row.appendChild(valueData);
    		list.appendChild(row);
    	}, this);

    	return Object.keys(data).length ? list : "";
    };

    Tabulator.prototype.registerModule("responsiveLayout", ResponsiveLayout);

    var SelectRow = function SelectRow(table) {
    	this.table = table; //hold Tabulator object
    	this.selecting = false; //flag selecting in progress
    	this.lastClickedRow = false; //last clicked row
    	this.selectPrev = []; //hold previously selected element for drag drop selection
    	this.selectedRows = []; //hold selected rows
    	this.headerCheckboxElement = null; // hold header select element
    };

    SelectRow.prototype.clearSelectionData = function (silent) {
    	this.selecting = false;
    	this.lastClickedRow = false;
    	this.selectPrev = [];
    	this.selectedRows = [];

    	if (!silent) {
    		this._rowSelectionChanged();
    	}
    };

    SelectRow.prototype.initializeRow = function (row) {
    	var self = this,
    	    element = row.getElement();

    	// trigger end of row selection
    	var endSelect = function endSelect() {

    		setTimeout(function () {
    			self.selecting = false;
    		}, 50);

    		document.body.removeEventListener("mouseup", endSelect);
    	};

    	row.modules.select = { selected: false };

    	//set row selection class
    	if (self.table.options.selectableCheck.call(this.table, row.getComponent())) {
    		element.classList.add("tabulator-selectable");
    		element.classList.remove("tabulator-unselectable");

    		if (self.table.options.selectable && self.table.options.selectable != "highlight") {
    			if (self.table.options.selectableRangeMode === "click") {
    				element.addEventListener("click", function (e) {
    					if (e.shiftKey) {
    						self.table._clearSelection();
    						self.lastClickedRow = self.lastClickedRow || row;

    						var lastClickedRowIdx = self.table.rowManager.getDisplayRowIndex(self.lastClickedRow);
    						var rowIdx = self.table.rowManager.getDisplayRowIndex(row);

    						var fromRowIdx = lastClickedRowIdx <= rowIdx ? lastClickedRowIdx : rowIdx;
    						var toRowIdx = lastClickedRowIdx >= rowIdx ? lastClickedRowIdx : rowIdx;

    						var rows = self.table.rowManager.getDisplayRows().slice(0);
    						var toggledRows = rows.splice(fromRowIdx, toRowIdx - fromRowIdx + 1);

    						if (e.ctrlKey || e.metaKey) {
    							toggledRows.forEach(function (toggledRow) {
    								if (toggledRow !== self.lastClickedRow) {

    									if (self.table.options.selectable !== true && !self.isRowSelected(row)) {
    										if (self.selectedRows.length < self.table.options.selectable) {
    											self.toggleRow(toggledRow);
    										}
    									} else {
    										self.toggleRow(toggledRow);
    									}
    								}
    							});
    							self.lastClickedRow = row;
    						} else {
    							self.deselectRows(undefined, true);

    							if (self.table.options.selectable !== true) {
    								if (toggledRows.length > self.table.options.selectable) {
    									toggledRows = toggledRows.slice(0, self.table.options.selectable);
    								}
    							}

    							self.selectRows(toggledRows);
    						}
    						self.table._clearSelection();
    					} else if (e.ctrlKey || e.metaKey) {
    						self.toggleRow(row);
    						self.lastClickedRow = row;
    					} else {
    						self.deselectRows(undefined, true);
    						self.selectRows(row);
    						self.lastClickedRow = row;
    					}
    				});
    			} else {
    				element.addEventListener("click", function (e) {
    					if (!self.table.modExists("edit") || !self.table.modules.edit.getCurrentCell()) {
    						self.table._clearSelection();
    					}

    					if (!self.selecting) {
    						self.toggleRow(row);
    					}
    				});

    				element.addEventListener("mousedown", function (e) {
    					if (e.shiftKey) {
    						self.table._clearSelection();

    						self.selecting = true;

    						self.selectPrev = [];

    						document.body.addEventListener("mouseup", endSelect);
    						document.body.addEventListener("keyup", endSelect);

    						self.toggleRow(row);

    						return false;
    					}
    				});

    				element.addEventListener("mouseenter", function (e) {
    					if (self.selecting) {
    						self.table._clearSelection();
    						self.toggleRow(row);

    						if (self.selectPrev[1] == row) {
    							self.toggleRow(self.selectPrev[0]);
    						}
    					}
    				});

    				element.addEventListener("mouseout", function (e) {
    					if (self.selecting) {
    						self.table._clearSelection();
    						self.selectPrev.unshift(row);
    					}
    				});
    			}
    		}
    	} else {
    		element.classList.add("tabulator-unselectable");
    		element.classList.remove("tabulator-selectable");
    	}
    };

    //toggle row selection
    SelectRow.prototype.toggleRow = function (row) {
    	if (this.table.options.selectableCheck.call(this.table, row.getComponent())) {
    		if (row.modules.select && row.modules.select.selected) {
    			this._deselectRow(row);
    		} else {
    			this._selectRow(row);
    		}
    	}
    };

    //select a number of rows
    SelectRow.prototype.selectRows = function (rows) {
    	var _this84 = this;

    	var rowMatch;

    	switch (typeof rows === 'undefined' ? 'undefined' : _typeof(rows)) {
    		case "undefined":
    			this.table.rowManager.rows.forEach(function (row) {
    				_this84._selectRow(row, true, true);
    			});

    			this._rowSelectionChanged();
    			break;

    		case "string":

    			rowMatch = this.table.rowManager.findRow(rows);

    			if (rowMatch) {
    				this._selectRow(rowMatch, true, true);
    			} else {
    				this.table.rowManager.getRows(rows).forEach(function (row) {
    					_this84._selectRow(row, true, true);
    				});
    			}

    			this._rowSelectionChanged();
    			break;

    		default:
    			if (Array.isArray(rows)) {
    				rows.forEach(function (row) {
    					_this84._selectRow(row, true, true);
    				});

    				this._rowSelectionChanged();
    			} else {
    				this._selectRow(rows, false, true);
    			}
    			break;
    	}
    };

    //select an individual row
    SelectRow.prototype._selectRow = function (rowInfo, silent, force) {

    	//handle max row count
    	if (!isNaN(this.table.options.selectable) && this.table.options.selectable !== true && !force) {
    		if (this.selectedRows.length >= this.table.options.selectable) {
    			if (this.table.options.selectableRollingSelection) {
    				this._deselectRow(this.selectedRows[0]);
    			} else {
    				return false;
    			}
    		}
    	}

    	var row = this.table.rowManager.findRow(rowInfo);

    	if (row) {
    		if (this.selectedRows.indexOf(row) == -1) {
    			row.getElement().classList.add("tabulator-selected");
    			if (!row.modules.select) {
    				row.modules.select = {};
    			}

    			row.modules.select.selected = true;
    			if (row.modules.select.checkboxEl) {
    				row.modules.select.checkboxEl.checked = true;
    			}

    			this.selectedRows.push(row);

    			if (this.table.options.dataTreeSelectPropagate) {
    				this.childRowSelection(row, true);
    			}

    			if (!silent) {
    				this.table.options.rowSelected.call(this.table, row.getComponent());
    			}

    			this._rowSelectionChanged(silent);
    		}
    	} else {
    		if (!silent) {
    			console.warn("Selection Error - No such row found, ignoring selection:" + rowInfo);
    		}
    	}
    };

    SelectRow.prototype.isRowSelected = function (row) {
    	return this.selectedRows.indexOf(row) !== -1;
    };

    //deselect a number of rows
    SelectRow.prototype.deselectRows = function (rows, silent) {
    	var self = this,
    	    rowCount;

    	if (typeof rows == "undefined") {

    		rowCount = self.selectedRows.length;

    		for (var _i18 = 0; _i18 < rowCount; _i18++) {
    			self._deselectRow(self.selectedRows[0], true);
    		}

    		self._rowSelectionChanged(silent);
    	} else {
    		if (Array.isArray(rows)) {
    			rows.forEach(function (row) {
    				self._deselectRow(row, true);
    			});

    			self._rowSelectionChanged(silent);
    		} else {
    			self._deselectRow(rows, silent);
    		}
    	}
    };

    //deselect an individual row
    SelectRow.prototype._deselectRow = function (rowInfo, silent) {
    	var self = this,
    	    row = self.table.rowManager.findRow(rowInfo),
    	    index;

    	if (row) {
    		index = self.selectedRows.findIndex(function (selectedRow) {
    			return selectedRow == row;
    		});

    		if (index > -1) {

    			row.getElement().classList.remove("tabulator-selected");
    			if (!row.modules.select) {
    				row.modules.select = {};
    			}

    			row.modules.select.selected = false;
    			if (row.modules.select.checkboxEl) {
    				row.modules.select.checkboxEl.checked = false;
    			}
    			self.selectedRows.splice(index, 1);

    			if (this.table.options.dataTreeSelectPropagate) {
    				this.childRowSelection(row, false);
    			}

    			if (!silent) {
    				self.table.options.rowDeselected.call(this.table, row.getComponent());
    			}

    			self._rowSelectionChanged(silent);
    		}
    	} else {
    		if (!silent) {
    			console.warn("Deselection Error - No such row found, ignoring selection:" + rowInfo);
    		}
    	}
    };

    SelectRow.prototype.getSelectedData = function () {
    	var data = [];

    	this.selectedRows.forEach(function (row) {
    		data.push(row.getData());
    	});

    	return data;
    };

    SelectRow.prototype.getSelectedRows = function () {

    	var rows = [];

    	this.selectedRows.forEach(function (row) {
    		rows.push(row.getComponent());
    	});

    	return rows;
    };

    SelectRow.prototype._rowSelectionChanged = function (silent) {
    	if (this.headerCheckboxElement) {
    		if (this.selectedRows.length === 0) {
    			this.headerCheckboxElement.checked = false;
    			this.headerCheckboxElement.indeterminate = false;
    		} else if (this.table.rowManager.rows.length === this.selectedRows.length) {
    			this.headerCheckboxElement.checked = true;
    			this.headerCheckboxElement.indeterminate = false;
    		} else {
    			this.headerCheckboxElement.indeterminate = true;
    			this.headerCheckboxElement.checked = false;
    		}
    	}

    	if (!silent) {
    		this.table.options.rowSelectionChanged.call(this.table, this.getSelectedData(), this.getSelectedRows());
    	}
    };

    SelectRow.prototype.registerRowSelectCheckbox = function (row, element) {
    	if (!row._row.modules.select) {
    		row._row.modules.select = {};
    	}

    	row._row.modules.select.checkboxEl = element;
    };

    SelectRow.prototype.registerHeaderSelectCheckbox = function (element) {
    	this.headerCheckboxElement = element;
    };

    SelectRow.prototype.childRowSelection = function (row, select) {
    	var children = this.table.modules.dataTree.getChildren(row, true);

    	if (select) {
    		for (var _iterator2 = children, _isArray2 = Array.isArray(_iterator2), _i19 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
    			var _ref2;

    			if (_isArray2) {
    				if (_i19 >= _iterator2.length) break;
    				_ref2 = _iterator2[_i19++];
    			} else {
    				_i19 = _iterator2.next();
    				if (_i19.done) break;
    				_ref2 = _i19.value;
    			}

    			var child = _ref2;

    			this._selectRow(child, true);
    		}
    	} else {
    		for (var _iterator3 = children, _isArray3 = Array.isArray(_iterator3), _i20 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
    			var _ref3;

    			if (_isArray3) {
    				if (_i20 >= _iterator3.length) break;
    				_ref3 = _iterator3[_i20++];
    			} else {
    				_i20 = _iterator3.next();
    				if (_i20.done) break;
    				_ref3 = _i20.value;
    			}

    			var _child = _ref3;

    			this._deselectRow(_child, true);
    		}
    	}
    };

    Tabulator.prototype.registerModule("selectRow", SelectRow);

    var Sort = function Sort(table) {
    	this.table = table; //hold Tabulator object
    	this.sortList = []; //holder current sort
    	this.changed = false; //has the sort changed since last render
    };

    //initialize column header for sorting
    Sort.prototype.initializeColumn = function (column, content) {
    	var self = this,
    	    sorter = false,
    	    colEl,
    	    arrowEl;

    	switch (_typeof(column.definition.sorter)) {
    		case "string":
    			if (self.sorters[column.definition.sorter]) {
    				sorter = self.sorters[column.definition.sorter];
    			} else {
    				console.warn("Sort Error - No such sorter found: ", column.definition.sorter);
    			}
    			break;

    		case "function":
    			sorter = column.definition.sorter;
    			break;
    	}

    	column.modules.sort = {
    		sorter: sorter, dir: "none",
    		params: column.definition.sorterParams || {},
    		startingDir: column.definition.headerSortStartingDir || "asc",
    		tristate: typeof column.definition.headerSortTristate !== "undefined" ? column.definition.headerSortTristate : this.table.options.headerSortTristate
    	};

    	if (typeof column.definition.headerSort === "undefined" ? this.table.options.headerSort !== false : column.definition.headerSort !== false) {

    		colEl = column.getElement();

    		colEl.classList.add("tabulator-sortable");

    		arrowEl = document.createElement("div");
    		arrowEl.classList.add("tabulator-col-sorter");

    		if (_typeof(this.table.options.headerSortElement) == "object") {
    			arrowEl.appendChild(this.table.options.headerSortElement);
    		} else {
    			arrowEl.innerHTML = this.table.options.headerSortElement;
    		}

    		//create sorter arrow
    		content.appendChild(arrowEl);

    		column.modules.sort.element = arrowEl;

    		//sort on click
    		colEl.addEventListener("click", function (e) {
    			var dir = "",
    			    sorters = [],
    			    match = false;

    			if (column.modules.sort) {
    				if (column.modules.sort.tristate) {
    					if (column.modules.sort.dir == "none") {
    						dir = column.modules.sort.startingDir;
    					} else {
    						if (column.modules.sort.dir == column.modules.sort.startingDir) {
    							dir = column.modules.sort.dir == "asc" ? "desc" : "asc";
    						} else {
    							dir = "none";
    						}
    					}
    				} else {
    					switch (column.modules.sort.dir) {
    						case "asc":
    							dir = "desc";
    							break;

    						case "desc":
    							dir = "asc";
    							break;

    						default:
    							dir = column.modules.sort.startingDir;
    					}
    				}

    				if (self.table.options.columnHeaderSortMulti && (e.shiftKey || e.ctrlKey)) {
    					sorters = self.getSort();

    					match = sorters.findIndex(function (sorter) {
    						return sorter.field === column.getField();
    					});

    					if (match > -1) {
    						sorters[match].dir = dir;

    						if (match != sorters.length - 1) {
    							match = sorters.splice(match, 1)[0];
    							if (dir != "none") {
    								sorters.push(match);
    							}
    						}
    					} else {
    						if (dir != "none") {
    							sorters.push({ column: column, dir: dir });
    						}
    					}

    					//add to existing sort
    					self.setSort(sorters);
    				} else {
    					if (dir == "none") {
    						self.clear();
    					} else {
    						//sort by column only
    						self.setSort(column, dir);
    					}
    				}

    				self.table.rowManager.sorterRefresh(!self.sortList.length);
    			}
    		});
    	}
    };

    //check if the sorters have changed since last use
    Sort.prototype.hasChanged = function () {
    	var changed = this.changed;
    	this.changed = false;
    	return changed;
    };

    //return current sorters
    Sort.prototype.getSort = function () {
    	var self = this,
    	    sorters = [];

    	self.sortList.forEach(function (item) {
    		if (item.column) {
    			sorters.push({ column: item.column.getComponent(), field: item.column.getField(), dir: item.dir });
    		}
    	});

    	return sorters;
    };

    //change sort list and trigger sort
    Sort.prototype.setSort = function (sortList, dir) {
    	var self = this,
    	    newSortList = [];

    	if (!Array.isArray(sortList)) {
    		sortList = [{ column: sortList, dir: dir }];
    	}

    	sortList.forEach(function (item) {
    		var column;

    		column = self.table.columnManager.findColumn(item.column);

    		if (column) {
    			item.column = column;
    			newSortList.push(item);
    			self.changed = true;
    		} else {
    			console.warn("Sort Warning - Sort field does not exist and is being ignored: ", item.column);
    		}
    	});

    	self.sortList = newSortList;

    	if (this.table.options.persistence && this.table.modExists("persistence", true) && this.table.modules.persistence.config.sort) {
    		this.table.modules.persistence.save("sort");
    	}
    };

    //clear sorters
    Sort.prototype.clear = function () {
    	this.setSort([]);
    };

    //find appropriate sorter for column
    Sort.prototype.findSorter = function (column) {
    	var row = this.table.rowManager.activeRows[0],
    	    sorter = "string",
    	    field,
    	    value;

    	if (row) {
    		row = row.getData();
    		field = column.getField();

    		if (field) {

    			value = column.getFieldValue(row);

    			switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
    				case "undefined":
    					sorter = "string";
    					break;

    				case "boolean":
    					sorter = "boolean";
    					break;

    				default:
    					if (!isNaN(value) && value !== "") {
    						sorter = "number";
    					} else {
    						if (value.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i)) {
    							sorter = "alphanum";
    						}
    					}
    					break;
    			}
    		}
    	}

    	return this.sorters[sorter];
    };

    //work through sort list sorting data
    Sort.prototype.sort = function (data) {
    	var self = this,
    	    sortList = this.table.options.sortOrderReverse ? self.sortList.slice().reverse() : self.sortList,
    	    sortListActual = [],
    	    rowComponents = [];

    	if (self.table.options.dataSorting) {
    		self.table.options.dataSorting.call(self.table, self.getSort());
    	}

    	self.clearColumnHeaders();

    	if (!self.table.options.ajaxSorting) {

    		//build list of valid sorters and trigger column specific callbacks before sort begins
    		sortList.forEach(function (item, i) {
    			var sortObj = item.column.modules.sort;

    			if (item.column && sortObj) {

    				//if no sorter has been defined, take a guess
    				if (!sortObj.sorter) {
    					sortObj.sorter = self.findSorter(item.column);
    				}

    				item.params = typeof sortObj.params === "function" ? sortObj.params(item.column.getComponent(), item.dir) : sortObj.params;

    				sortListActual.push(item);
    			}

    			self.setColumnHeader(item.column, item.dir);
    		});

    		//sort data
    		if (sortListActual.length) {
    			self._sortItems(data, sortListActual);
    		}
    	} else {
    		sortList.forEach(function (item, i) {
    			self.setColumnHeader(item.column, item.dir);
    		});
    	}

    	if (self.table.options.dataSorted) {
    		data.forEach(function (row) {
    			rowComponents.push(row.getComponent());
    		});

    		self.table.options.dataSorted.call(self.table, self.getSort(), rowComponents);
    	}
    };

    //clear sort arrows on columns
    Sort.prototype.clearColumnHeaders = function () {
    	this.table.columnManager.getRealColumns().forEach(function (column) {
    		if (column.modules.sort) {
    			column.modules.sort.dir = "none";
    			column.getElement().setAttribute("aria-sort", "none");
    		}
    	});
    };

    //set the column header sort direction
    Sort.prototype.setColumnHeader = function (column, dir) {
    	column.modules.sort.dir = dir;
    	column.getElement().setAttribute("aria-sort", dir);
    };

    //sort each item in sort list
    Sort.prototype._sortItems = function (data, sortList) {
    	var _this85 = this;

    	var sorterCount = sortList.length - 1;

    	data.sort(function (a, b) {
    		var result;

    		for (var i = sorterCount; i >= 0; i--) {
    			var sortItem = sortList[i];

    			result = _this85._sortRow(a, b, sortItem.column, sortItem.dir, sortItem.params);

    			if (result !== 0) {
    				break;
    			}
    		}

    		return result;
    	});
    };

    //process individual rows for a sort function on active data
    Sort.prototype._sortRow = function (a, b, column, dir, params) {
    	var el1Comp, el2Comp;

    	//switch elements depending on search direction
    	var el1 = dir == "asc" ? a : b;
    	var el2 = dir == "asc" ? b : a;

    	a = column.getFieldValue(el1.getData());
    	b = column.getFieldValue(el2.getData());

    	a = typeof a !== "undefined" ? a : "";
    	b = typeof b !== "undefined" ? b : "";

    	el1Comp = el1.getComponent();
    	el2Comp = el2.getComponent();

    	return column.modules.sort.sorter.call(this, a, b, el1Comp, el2Comp, column.getComponent(), dir, params);
    };

    //default data sorters
    Sort.prototype.sorters = {

    	//sort numbers
    	number: function number(a, b, aRow, bRow, column, dir, params) {
    		var alignEmptyValues = params.alignEmptyValues;
    		var decimal = params.decimalSeparator;
    		var thousand = params.thousandSeparator;
    		var emptyAlign = 0;

    		a = String(a);
    		b = String(b);

    		if (thousand) {
    			a = a.split(thousand).join("");
    			b = b.split(thousand).join("");
    		}

    		if (decimal) {
    			a = a.split(decimal).join(".");
    			b = b.split(decimal).join(".");
    		}

    		a = parseFloat(a);
    		b = parseFloat(b);

    		//handle non numeric values
    		if (isNaN(a)) {
    			emptyAlign = isNaN(b) ? 0 : -1;
    		} else if (isNaN(b)) {
    			emptyAlign = 1;
    		} else {
    			//compare valid values
    			return a - b;
    		}

    		//fix empty values in position
    		if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
    			emptyAlign *= -1;
    		}

    		return emptyAlign;
    	},

    	//sort strings
    	string: function string(a, b, aRow, bRow, column, dir, params) {
    		var alignEmptyValues = params.alignEmptyValues;
    		var emptyAlign = 0;
    		var locale;

    		//handle empty values
    		if (!a) {
    			emptyAlign = !b ? 0 : -1;
    		} else if (!b) {
    			emptyAlign = 1;
    		} else {
    			//compare valid values
    			switch (_typeof(params.locale)) {
    				case "boolean":
    					if (params.locale) {
    						locale = this.table.modules.localize.getLocale();
    					}
    					break;
    				case "string":
    					locale = params.locale;
    					break;
    			}

    			return String(a).toLowerCase().localeCompare(String(b).toLowerCase(), locale);
    		}

    		//fix empty values in position
    		if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
    			emptyAlign *= -1;
    		}

    		return emptyAlign;
    	},

    	//sort date
    	date: function date(a, b, aRow, bRow, column, dir, params) {
    		if (!params.format) {
    			params.format = "DD/MM/YYYY";
    		}

    		return this.sorters.datetime.call(this, a, b, aRow, bRow, column, dir, params);
    	},

    	//sort HH:mm formatted times
    	time: function time(a, b, aRow, bRow, column, dir, params) {
    		if (!params.format) {
    			params.format = "HH:mm";
    		}

    		return this.sorters.datetime.call(this, a, b, aRow, bRow, column, dir, params);
    	},

    	//sort datetime
    	datetime: function datetime(a, b, aRow, bRow, column, dir, params) {
    		var format = params.format || "DD/MM/YYYY HH:mm:ss",
    		    alignEmptyValues = params.alignEmptyValues,
    		    emptyAlign = 0;

    		if (typeof moment != "undefined") {
    			a = moment(a, format);
    			b = moment(b, format);

    			if (!a.isValid()) {
    				emptyAlign = !b.isValid() ? 0 : -1;
    			} else if (!b.isValid()) {
    				emptyAlign = 1;
    			} else {
    				//compare valid values
    				return a - b;
    			}

    			//fix empty values in position
    			if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
    				emptyAlign *= -1;
    			}

    			return emptyAlign;
    		} else {
    			console.error("Sort Error - 'datetime' sorter is dependant on moment.js");
    		}
    	},

    	//sort booleans
    	boolean: function boolean(a, b, aRow, bRow, column, dir, params) {
    		var el1 = a === true || a === "true" || a === "True" || a === 1 ? 1 : 0;
    		var el2 = b === true || b === "true" || b === "True" || b === 1 ? 1 : 0;

    		return el1 - el2;
    	},

    	//sort if element contains any data
    	array: function array(a, b, aRow, bRow, column, dir, params) {
    		var el1 = 0;
    		var el2 = 0;
    		var type = params.type || "length";
    		var alignEmptyValues = params.alignEmptyValues;
    		var emptyAlign = 0;

    		function calc(value) {

    			switch (type) {
    				case "length":
    					return value.length;

    				case "sum":
    					return value.reduce(function (c, d) {
    						return c + d;
    					});

    				case "max":
    					return Math.max.apply(null, value);

    				case "min":
    					return Math.min.apply(null, value);

    				case "avg":
    					return value.reduce(function (c, d) {
    						return c + d;
    					}) / value.length;
    			}
    		}

    		//handle non array values
    		if (!Array.isArray(a)) {
    			alignEmptyValues = !Array.isArray(b) ? 0 : -1;
    		} else if (!Array.isArray(b)) {
    			alignEmptyValues = 1;
    		} else {

    			//compare valid values
    			el1 = a ? calc(a) : 0;
    			el2 = b ? calc(b) : 0;

    			return el1 - el2;
    		}

    		//fix empty values in position
    		if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
    			emptyAlign *= -1;
    		}

    		return emptyAlign;
    	},

    	//sort if element contains any data
    	exists: function exists(a, b, aRow, bRow, column, dir, params) {
    		var el1 = typeof a == "undefined" ? 0 : 1;
    		var el2 = typeof b == "undefined" ? 0 : 1;

    		return el1 - el2;
    	},

    	//sort alpha numeric strings
    	alphanum: function alphanum(as, bs, aRow, bRow, column, dir, params) {
    		var a,
    		    b,
    		    a1,
    		    b1,
    		    i = 0,
    		    L,
    		    rx = /(\d+)|(\D+)/g,
    		    rd = /\d/;
    		var alignEmptyValues = params.alignEmptyValues;
    		var emptyAlign = 0;

    		//handle empty values
    		if (!as && as !== 0) {
    			emptyAlign = !bs && bs !== 0 ? 0 : -1;
    		} else if (!bs && bs !== 0) {
    			emptyAlign = 1;
    		} else {

    			if (isFinite(as) && isFinite(bs)) return as - bs;
    			a = String(as).toLowerCase();
    			b = String(bs).toLowerCase();
    			if (a === b) return 0;
    			if (!(rd.test(a) && rd.test(b))) return a > b ? 1 : -1;
    			a = a.match(rx);
    			b = b.match(rx);
    			L = a.length > b.length ? b.length : a.length;
    			while (i < L) {
    				a1 = a[i];
    				b1 = b[i++];
    				if (a1 !== b1) {
    					if (isFinite(a1) && isFinite(b1)) {
    						if (a1.charAt(0) === "0") a1 = "." + a1;
    						if (b1.charAt(0) === "0") b1 = "." + b1;
    						return a1 - b1;
    					} else return a1 > b1 ? 1 : -1;
    				}
    			}

    			return a.length > b.length;
    		}

    		//fix empty values in position
    		if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
    			emptyAlign *= -1;
    		}

    		return emptyAlign;
    	}
    };

    Tabulator.prototype.registerModule("sort", Sort);

    var Validate = function Validate(table) {
    	this.table = table;
    	this.invalidCells = [];
    };

    //validate
    Validate.prototype.initializeColumn = function (column) {
    	var self = this,
    	    config = [],
    	    validator;

    	if (column.definition.validator) {

    		if (Array.isArray(column.definition.validator)) {
    			column.definition.validator.forEach(function (item) {
    				validator = self._extractValidator(item);

    				if (validator) {
    					config.push(validator);
    				}
    			});
    		} else {
    			validator = this._extractValidator(column.definition.validator);

    			if (validator) {
    				config.push(validator);
    			}
    		}

    		column.modules.validate = config.length ? config : false;
    	}
    };

    Validate.prototype._extractValidator = function (value) {
    	var type, params, pos;

    	switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
    		case "string":
    			pos = value.indexOf(':');

    			if (pos > -1) {
    				type = value.substring(0, pos);
    				params = value.substring(pos + 1);
    			} else {
    				type = value;
    			}

    			return this._buildValidator(type, params);

    		case "function":
    			return this._buildValidator(value);

    		case "object":
    			return this._buildValidator(value.type, value.parameters);
    	}
    };

    Validate.prototype._buildValidator = function (type, params) {

    	var func = typeof type == "function" ? type : this.validators[type];

    	if (!func) {
    		console.warn("Validator Setup Error - No matching validator found:", type);
    		return false;
    	} else {
    		return {
    			type: typeof type == "function" ? "function" : type,
    			func: func,
    			params: params
    		};
    	}
    };

    Validate.prototype.validate = function (validators, cell, value) {
    	var self = this,
    	    valid = [],
    	    invalidIndex = this.invalidCells.indexOf(cell);

    	if (validators) {
    		validators.forEach(function (item) {
    			if (!item.func.call(self, cell.getComponent(), value, item.params)) {
    				valid.push({
    					type: item.type,
    					parameters: item.params
    				});
    			}
    		});
    	}

    	valid = valid.length ? valid : true;

    	if (!cell.modules.validate) {
    		cell.modules.validate = {};
    	}

    	if (valid === true) {
    		cell.modules.validate.invalid = false;
    		cell.getElement().classList.remove("tabulator-validation-fail");

    		if (invalidIndex > -1) {
    			this.invalidCells.splice(invalidIndex, 1);
    		}
    	} else {
    		cell.modules.validate.invalid = true;

    		if (this.table.options.validationMode !== "manual") {
    			cell.getElement().classList.add("tabulator-validation-fail");
    		}

    		if (invalidIndex == -1) {
    			this.invalidCells.push(cell);
    		}
    	}

    	return valid;
    };

    Validate.prototype.getInvalidCells = function () {
    	var output = [];

    	this.invalidCells.forEach(function (cell) {
    		output.push(cell.getComponent());
    	});

    	return output;
    };

    Validate.prototype.clearValidation = function (cell) {
    	var invalidIndex;

    	if (cell.modules.validate && cell.modules.validate.invalid) {

    		cell.getElement().classList.remove("tabulator-validation-fail");
    		cell.modules.validate.invalid = false;

    		invalidIndex = this.invalidCells.indexOf(cell);

    		if (invalidIndex > -1) {
    			this.invalidCells.splice(invalidIndex, 1);
    		}
    	}
    };

    Validate.prototype.validators = {

    	//is integer
    	integer: function integer(cell, value, parameters) {
    		if (value === "" || value === null || typeof value === "undefined") {
    			return true;
    		}
    		value = Number(value);
    		return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
    	},

    	//is float
    	float: function float(cell, value, parameters) {
    		if (value === "" || value === null || typeof value === "undefined") {
    			return true;
    		}
    		value = Number(value);
    		return typeof value === 'number' && isFinite(value) && value % 1 !== 0;
    	},

    	//must be a number
    	numeric: function numeric(cell, value, parameters) {
    		if (value === "" || value === null || typeof value === "undefined") {
    			return true;
    		}
    		return !isNaN(value);
    	},

    	//must be a string
    	string: function string(cell, value, parameters) {
    		if (value === "" || value === null || typeof value === "undefined") {
    			return true;
    		}
    		return isNaN(value);
    	},

    	//maximum value
    	max: function max(cell, value, parameters) {
    		if (value === "" || value === null || typeof value === "undefined") {
    			return true;
    		}
    		return parseFloat(value) <= parameters;
    	},

    	//minimum value
    	min: function min(cell, value, parameters) {
    		if (value === "" || value === null || typeof value === "undefined") {
    			return true;
    		}
    		return parseFloat(value) >= parameters;
    	},

    	//starts with  value
    	starts: function starts(cell, value, parameters) {
    		if (value === "" || value === null || typeof value === "undefined") {
    			return true;
    		}
    		return String(value).toLowerCase().startsWith(String(parameters).toLowerCase());
    	},

    	//ends with  value
    	ends: function ends(cell, value, parameters) {
    		if (value === "" || value === null || typeof value === "undefined") {
    			return true;
    		}
    		return String(value).toLowerCase().endsWith(String(parameters).toLowerCase());
    	},

    	//minimum string length
    	minLength: function minLength(cell, value, parameters) {
    		if (value === "" || value === null || typeof value === "undefined") {
    			return true;
    		}
    		return String(value).length >= parameters;
    	},

    	//maximum string length
    	maxLength: function maxLength(cell, value, parameters) {
    		if (value === "" || value === null || typeof value === "undefined") {
    			return true;
    		}
    		return String(value).length <= parameters;
    	},

    	//in provided value list
    	in: function _in(cell, value, parameters) {
    		if (value === "" || value === null || typeof value === "undefined") {
    			return true;
    		}
    		if (typeof parameters == "string") {
    			parameters = parameters.split("|");
    		}

    		return value === "" || parameters.indexOf(value) > -1;
    	},

    	//must match provided regex
    	regex: function regex(cell, value, parameters) {
    		if (value === "" || value === null || typeof value === "undefined") {
    			return true;
    		}
    		var reg = new RegExp(parameters);

    		return reg.test(value);
    	},

    	//value must be unique in this column
    	unique: function unique(cell, value, parameters) {
    		if (value === "" || value === null || typeof value === "undefined") {
    			return true;
    		}
    		var unique = true;

    		var cellData = cell.getData();
    		var column = cell.getColumn()._getSelf();

    		this.table.rowManager.rows.forEach(function (row) {
    			var data = row.getData();

    			if (data !== cellData) {
    				if (value == column.getFieldValue(data)) {
    					unique = false;
    				}
    			}
    		});

    		return unique;
    	},

    	//must have a value
    	required: function required(cell, value, parameters) {
    		return value !== "" && value !== null && typeof value !== "undefined";
    	}
    };

    Tabulator.prototype.registerModule("validate", Validate);

    /* src\Tabulator\index.svelte generated by Svelte v3.38.2 */
    const file$6 = "src\\Tabulator\\index.svelte";

    // (270:0) {:else}
    function create_else_block(ctx) {
    	let t;
    	let div1;
    	let div0;
    	let div0_class_value;
    	let mounted;
    	let dispose;
    	let if_block = /*showHeader*/ ctx[2] && create_if_block_1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", div0_class_value = "" + (null_to_empty(/*cssClass*/ ctx[1]) + " svelte-1rqar45"));
    			add_location(div0, file$6, 384, 4, 10526);
    			attr_dev(div1, "id", "tabulator-id");
    			attr_dev(div1, "class", "tabulator-svelte-table");
    			set_style(div1, "padding", "0 5px");
    			add_location(div1, file$6, 378, 2, 10405);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			/*div1_binding*/ ctx[32](div1);

    			if (!mounted) {
    				dispose = action_destroyer(/*action*/ ctx[9].call(null, div0, /*config*/ ctx[8]));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*showHeader*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1(ctx);
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty[0] & /*cssClass*/ 2 && div0_class_value !== (div0_class_value = "" + (null_to_empty(/*cssClass*/ ctx[1]) + " svelte-1rqar45"))) {
    				attr_dev(div0, "class", div0_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div1);
    			/*div1_binding*/ ctx[32](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(270:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (268:0) {#if loading}
    function create_if_block$1(ctx) {
    	let div;
    	let i;

    	const block = {
    		c: function create() {
    			div = element("div");
    			i = element("i");
    			attr_dev(i, "class", "fas fa-sync fa-spin fa-3x");
    			add_location(i, file$6, 268, 22, 7443);
    			attr_dev(div, "class", "loader svelte-1rqar45");
    			add_location(div, file$6, 268, 2, 7423);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, i);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(268:0) {#if loading}",
    		ctx
    	});

    	return block;
    }

    // (271:2) {#if showHeader}
    function create_if_block_1(ctx) {
    	let div3;
    	let div0;
    	let form;
    	let input;
    	let t0;
    	let button0;
    	let t1;
    	let button1;
    	let span0;
    	let t2;
    	let button2;
    	let span1;
    	let t3;
    	let div1;
    	let button3;
    	let span2;
    	let t4;
    	let button4;
    	let span3;
    	let t5;
    	let div2;
    	let button5;
    	let span4;
    	let t6;
    	let button6;
    	let span5;
    	let t7;
    	let t8;
    	let button7;
    	let span6;
    	let t9;
    	let t10;
    	let button8;
    	let span7;
    	let t11;
    	let t12;
    	let button9;
    	let span8;
    	let t13;
    	let mounted;
    	let dispose;

    	function select_block_type_1(ctx, dirty) {
    		if (/*hits*/ ctx[6].length > 0) return create_if_block_2;
    		return create_else_block_1;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			form = element("form");
    			input = element("input");
    			t0 = space();
    			button0 = element("button");
    			if_block.c();
    			t1 = space();
    			button1 = element("button");
    			span0 = element("span");
    			t2 = space();
    			button2 = element("button");
    			span1 = element("span");
    			t3 = space();
    			div1 = element("div");
    			button3 = element("button");
    			span2 = element("span");
    			t4 = space();
    			button4 = element("button");
    			span3 = element("span");
    			t5 = space();
    			div2 = element("div");
    			button5 = element("button");
    			span4 = element("span");
    			t6 = space();
    			button6 = element("button");
    			span5 = element("span");
    			t7 = text(" ");
    			t8 = space();
    			button7 = element("button");
    			span6 = element("span");
    			t9 = text("  TXT");
    			t10 = space();
    			button8 = element("button");
    			span7 = element("span");
    			t11 = text("  CSV");
    			t12 = space();
    			button9 = element("button");
    			span8 = element("span");
    			t13 = text("  HTML");
    			attr_dev(input, "type", "search");
    			attr_dev(input, "name", "search");
    			attr_dev(input, "placeholder", "Search Text");
    			set_style(input, "border-radius", "4px 0 0 4px");
    			attr_dev(input, "class", "form-control");
    			add_location(input, file$6, 279, 10, 7766);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn btn-default btn-large");
    			add_location(button0, file$6, 289, 10, 8052);
    			attr_dev(span0, "class", "icon icon-down-dir");
    			add_location(span0, file$6, 301, 12, 8471);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn btn-default btn-large");
    			add_location(button1, file$6, 296, 10, 8332);
    			attr_dev(span1, "class", "icon icon-up-dir");
    			add_location(span1, file$6, 308, 12, 8676);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn btn-default btn-large");
    			add_location(button2, file$6, 303, 10, 8539);
    			attr_dev(form, "class", "btn-group");
    			set_style(form, "display", "flex");
    			add_location(form, file$6, 274, 8, 7632);
    			set_style(div0, "display", "inline-flex");
    			add_location(div0, file$6, 273, 6, 7588);
    			attr_dev(span2, "class", "icon icon-down-bold");
    			add_location(span2, file$6, 320, 10, 8968);
    			attr_dev(button3, "type", "button");
    			attr_dev(button3, "class", "btn btn-default btn-large");
    			add_location(button3, file$6, 315, 8, 8831);
    			attr_dev(span3, "class", "icon icon-up-bold");
    			add_location(span3, file$6, 327, 10, 9167);
    			attr_dev(button4, "type", "button");
    			attr_dev(button4, "class", "btn btn-default btn-large");
    			add_location(button4, file$6, 322, 8, 9033);
    			attr_dev(div1, "class", "btn-group");
    			add_location(div1, file$6, 314, 6, 8798);
    			attr_dev(span4, "class", "icon icon-popup");
    			add_location(span4, file$6, 338, 10, 9432);
    			attr_dev(button5, "type", "button");
    			attr_dev(button5, "class", "btn btn-default btn-large");
    			add_location(button5, file$6, 333, 8, 9300);
    			attr_dev(span5, "class", "icon icon-camera");
    			add_location(span5, file$6, 347, 10, 9661);
    			attr_dev(button6, "type", "button");
    			attr_dev(button6, "class", "btn btn-default btn-large");
    			add_location(button6, file$6, 342, 8, 9524);
    			attr_dev(span6, "class", "icon icon-install");
    			add_location(span6, file$6, 355, 10, 9863);
    			attr_dev(button7, "type", "button");
    			attr_dev(button7, "class", "btn btn-default btn-large");
    			add_location(button7, file$6, 350, 8, 9731);
    			attr_dev(span7, "class", "icon icon-install");
    			add_location(span7, file$6, 363, 10, 10070);
    			attr_dev(button8, "type", "button");
    			attr_dev(button8, "class", "btn btn-default btn-large");
    			add_location(button8, file$6, 358, 8, 9938);
    			attr_dev(span8, "class", "icon icon-install");
    			add_location(span8, file$6, 371, 10, 10278);
    			attr_dev(button9, "type", "button");
    			attr_dev(button9, "class", "btn btn-default btn-large");
    			add_location(button9, file$6, 366, 8, 10145);
    			attr_dev(div2, "class", "btn-group");
    			add_location(div2, file$6, 332, 6, 9267);
    			attr_dev(div3, "class", "toolbar-actions");
    			add_location(div3, file$6, 271, 4, 7523);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div0, form);
    			append_dev(form, input);
    			set_input_value(input, /*searchText*/ ctx[5]);
    			append_dev(form, t0);
    			append_dev(form, button0);
    			if_block.m(button0, null);
    			append_dev(form, t1);
    			append_dev(form, button1);
    			append_dev(button1, span0);
    			append_dev(form, t2);
    			append_dev(form, button2);
    			append_dev(button2, span1);
    			append_dev(div3, t3);
    			append_dev(div3, div1);
    			append_dev(div1, button3);
    			append_dev(button3, span2);
    			append_dev(div1, t4);
    			append_dev(div1, button4);
    			append_dev(button4, span3);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			append_dev(div2, button5);
    			append_dev(button5, span4);
    			append_dev(div2, t6);
    			append_dev(div2, button6);
    			append_dev(button6, span5);
    			append_dev(button6, t7);
    			append_dev(div2, t8);
    			append_dev(div2, button7);
    			append_dev(button7, span6);
    			append_dev(button7, t9);
    			append_dev(div2, t10);
    			append_dev(div2, button8);
    			append_dev(button8, span7);
    			append_dev(button8, t11);
    			append_dev(div2, t12);
    			append_dev(div2, button9);
    			append_dev(button9, span8);
    			append_dev(button9, t13);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[31]),
    					listen_dev(button1, "click", /*goDown*/ ctx[11], false, false, false),
    					listen_dev(button2, "click", /*goUp*/ ctx[12], false, false, false),
    					listen_dev(form, "submit", prevent_default(/*search*/ ctx[10]), false, true, false),
    					listen_dev(button3, "click", /*scrollToBottom*/ ctx[13], false, false, false),
    					listen_dev(button4, "click", /*scrollToTop*/ ctx[14], false, false, false),
    					listen_dev(button5, "click", /*copyTable*/ ctx[15], false, false, false),
    					listen_dev(button6, "click", /*takeScreenShot*/ ctx[3], false, false, false),
    					listen_dev(button7, "click", /*exportTXT*/ ctx[17], false, false, false),
    					listen_dev(button8, "click", /*exportCSV*/ ctx[16], false, false, false),
    					listen_dev(button9, "click", /*exportHTML*/ ctx[18], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*searchText*/ 32) {
    				set_input_value(input, /*searchText*/ ctx[5]);
    			}

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(button0, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(271:2) {#if showHeader}",
    		ctx
    	});

    	return block;
    }

    // (293:12) {:else}
    function create_else_block_1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("0/0");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(293:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (291:12) {#if hits.length > 0}
    function create_if_block_2(ctx) {
    	let t0_value = (/*gotoRowIndex*/ ctx[7]
    	? /*gotoRowIndex*/ ctx[7] + 1
    	: 0) + "";

    	let t0;
    	let t1;
    	let t2_value = /*hits*/ ctx[6].length + "";
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = text("/");
    			t2 = text(t2_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*gotoRowIndex*/ 128 && t0_value !== (t0_value = (/*gotoRowIndex*/ ctx[7]
    			? /*gotoRowIndex*/ ctx[7] + 1
    			: 0) + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*hits*/ 64 && t2_value !== (t2_value = /*hits*/ ctx[6].length + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(291:12) {#if hits.length > 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*loading*/ ctx[0]) return create_if_block$1;
    		return create_else_block;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let firstItem;
    	let lastItem;
    	let hits;
    	let gotoRowIndex;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Tabulator", slots, []);
    	let { columns = [] } = $$props;
    	let { data = [] } = $$props;
    	let { height = "" } = $$props;
    	let { layout = "fitColumns" } = $$props;

    	let { rowClick = () => {
    		
    	} } = $$props;

    	let { rowDblClick = () => {
    		
    	} } = $$props;

    	let { loading = false } = $$props;
    	let { rowFormatter = formatRow } = $$props;
    	let { cssClass = "" } = $$props;
    	let { index = "id" } = $$props;
    	let { exportFileName = "file" } = $$props;
    	let { showHeader = true } = $$props;
    	let { txtFormatter = null } = $$props;

    	let { htmlFormatter = (list, options, setFileContents) => {
    		const thead = `<tr>${list[0].columns.map(col => {
			return `<th style="padding: 5px; vertical-align:top">${col.value}</th>`;
		}).join("")}</tr>`;

    		const tbody = list.filter(row => row.type == "row").map(row => {
    			const line = row.columns.map(d => ` <td style="border: 1px solid gainsboro; padding: 5px; vertical-align:top">${d.value}</td>`);
    			return `<tr>${line.join("")}</tr>`;
    		});

    		const content = `<table style="font-family: monospace;border-collapse: collapse; width:100%;">
      <thead style="text-align: left; background-color: gainsboro;">
         ${thead}
        </thead>
      <tbody>
        ${tbody.join("")}
      </tbody>
    </table>`;

    		setFileContents(content, "text/plain");
    		return null;
    	} } = $$props;

    	// wrapping div element
    	let el;

    	// const evenRowColor = "#EFEFEF";
    	const config = { columns, data, height, layout, rowClick };

    	let table;

    	// $: table && table.clearHeaderFilter();
    	const action = (node, config) => {
    		$$invalidate(30, table = new Tabulator(node,
    		{
    				height, // set height of table (in CSS or here), this enables the Virtual DOM and improves render speed dramatically (can be any valid css height value)
    				data, //assign data to table
    				layout, //fit columns to width of table (optional)
    				columns,
    				headerFilterPlaceholder: "filtro",
    				resizableColumns: true,
    				rowClick,
    				rowDblClick,
    				rowFormatter,
    				clipboard: "copy",
    				clipboardCopyStyled: true,
    				clipboardCopyConfig: {
    					formatCells: false, //show raw cell values without formatter
    					
    				},
    				dataTree: true,
    				dataTreeStartExpanded: false,
    				index,
    				dataFiltered(filters, rows) {
    					$$invalidate(6, hits = []);
    					$$invalidate(7, gotoRowIndex = null);
    					activeRowId = null;
    				},
    				dataLoaded(data) {
    					// clear header filters when getting new data set
    					this.clearHeaderFilter();
    				}
    			}));

    		return {
    			destroy() {
    				table.destroy();
    			}
    		};
    	};

    	// search parameters
    	let searchText = "";

    	let activeRowId = null;

    	/**
     * SEARCH TEXT
     * -----------------------------------------------------------
     * Searches for given text and highlights the matches
     */
    	const search = () => {
    		if (!searchText) {
    			$$invalidate(6, hits = []);
    			$$invalidate(7, gotoRowIndex = null);
    			activeRowId = null;
    			return true;
    		}

    		// get column field names
    		const fieldNames = columns.map(c => c.field);

    		$$invalidate(6, hits = data.filter(d => {
    			const rowValues = fieldNames.map(v => d[v]);
    			const rowText = rowValues.join("");
    			return rowText.toLowerCase().includes(searchText.toLowerCase());
    		}).map(d => d[index]));

    		table.redraw(true);
    	};

    	function formatRow(row) {
    		const data = row.getData();
    		const rowId = data[index];

    		if (!searchText) {
    			return;
    		}

    		// paint row yellow
    		if (hits.includes(rowId)) {
    			row.getElement().style.backgroundColor = "lightyellow";
    		} else {
    			row.getElement().style.backgroundColor = null;
    		}
    	}

    	/**
     * SCROLL DOWN TO ROW
     * --------------------------------------------------
     * Scroll down to row after search filter
     */
    	function goDown() {
    		if (hits.length == 0) {
    			return;
    		}

    		if (gotoRowIndex === null) {
    			activeRowId = hits[0];
    			$$invalidate(7, gotoRowIndex = 0);
    		} else {
    			if (gotoRowIndex >= hits.length - 1) {
    				$$invalidate(7, gotoRowIndex = hits.length - 1);
    			} else {
    				$$invalidate(7, gotoRowIndex++, gotoRowIndex);
    				activeRowId = hits[gotoRowIndex];
    			}
    		}

    		table.scrollToRow(activeRowId);
    	}

    	function goUp() {
    		if (hits.length == 0) {
    			return;
    		}

    		if (gotoRowIndex > 0) {
    			$$invalidate(7, gotoRowIndex--, gotoRowIndex);
    			activeRowId = hits[gotoRowIndex];
    		}

    		table.scrollToRow(activeRowId);
    	}

    	/**
     * NAVIGATION FUNCTIONS
     */
    	const scrollToBottom = () => {
    		table.scrollToRow(lastItem);
    	};

    	const scrollToTop = () => {
    		table.scrollToRow(firstItem);
    	};

    	const copyTable = node => {
    		table.copyToClipboard("all");
    	};

    	const exportCSV = () => {
    		const ts = new Date().toISOString().replace(":", "_").replace(".", "_");
    		const fileName = `${exportFileName}_${ts}.csv`;
    		table.download("csv", fileName);
    	};

    	const exportTXT = () => {
    		const ts = new Date().toISOString().replace(":", "_").replace(".", "_");
    		const fileName = `${exportFileName}_${ts}.txt`;

    		// decide to use formatter functions
    		if (txtFormatter) {
    			table.download(txtFormatter, fileName);
    		} else {
    			table.download("csv", fileName, { delimiter: "\t", columnHeaders: false });
    		}
    	};

    	const exportHTML = () => {
    		const ts = new Date().toISOString().replace(":", "_").replace(".", "_");
    		const fileName = `${exportFileName}_${ts}.html`;

    		if (htmlFormatter) {
    			table.download(htmlFormatter, fileName);
    		} else {
    			table.download("html", fileName);
    		}
    	};

    	const takeScreenShot = () => {
    		const ts = new Date().toISOString().replace(":", "_").replace(".", "_");
    		const fileName = `${exportFileName}_${ts}.png`;
    		const container = document.querySelector(".tabulator-svelte-table  .tabulator-tableHolder");

    		html2canvas(container).then(function (canvas) {
    			const link = document.createElement("a");
    			document.body.appendChild(link);
    			link.download = fileName;
    			link.href = canvas.toDataURL("image/png");
    			link.target = "_blank";
    			link.click();
    			document.body.removeChild(link);
    		});
    	};

    	const writable_props = [
    		"columns",
    		"data",
    		"height",
    		"layout",
    		"rowClick",
    		"rowDblClick",
    		"loading",
    		"rowFormatter",
    		"cssClass",
    		"index",
    		"exportFileName",
    		"showHeader",
    		"txtFormatter",
    		"htmlFormatter"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tabulator> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		searchText = this.value;
    		$$invalidate(5, searchText);
    	}

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			el = $$value;
    			$$invalidate(4, el);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("columns" in $$props) $$invalidate(19, columns = $$props.columns);
    		if ("data" in $$props) $$invalidate(20, data = $$props.data);
    		if ("height" in $$props) $$invalidate(21, height = $$props.height);
    		if ("layout" in $$props) $$invalidate(22, layout = $$props.layout);
    		if ("rowClick" in $$props) $$invalidate(23, rowClick = $$props.rowClick);
    		if ("rowDblClick" in $$props) $$invalidate(24, rowDblClick = $$props.rowDblClick);
    		if ("loading" in $$props) $$invalidate(0, loading = $$props.loading);
    		if ("rowFormatter" in $$props) $$invalidate(25, rowFormatter = $$props.rowFormatter);
    		if ("cssClass" in $$props) $$invalidate(1, cssClass = $$props.cssClass);
    		if ("index" in $$props) $$invalidate(26, index = $$props.index);
    		if ("exportFileName" in $$props) $$invalidate(27, exportFileName = $$props.exportFileName);
    		if ("showHeader" in $$props) $$invalidate(2, showHeader = $$props.showHeader);
    		if ("txtFormatter" in $$props) $$invalidate(28, txtFormatter = $$props.txtFormatter);
    		if ("htmlFormatter" in $$props) $$invalidate(29, htmlFormatter = $$props.htmlFormatter);
    	};

    	$$self.$capture_state = () => ({
    		html2canvas,
    		Tabulator,
    		columns,
    		data,
    		height,
    		layout,
    		rowClick,
    		rowDblClick,
    		loading,
    		rowFormatter,
    		cssClass,
    		index,
    		exportFileName,
    		showHeader,
    		txtFormatter,
    		htmlFormatter,
    		el,
    		config,
    		table,
    		action,
    		searchText,
    		activeRowId,
    		search,
    		formatRow,
    		goDown,
    		goUp,
    		scrollToBottom,
    		scrollToTop,
    		copyTable,
    		exportCSV,
    		exportTXT,
    		exportHTML,
    		takeScreenShot,
    		firstItem,
    		lastItem,
    		hits,
    		gotoRowIndex
    	});

    	$$self.$inject_state = $$props => {
    		if ("columns" in $$props) $$invalidate(19, columns = $$props.columns);
    		if ("data" in $$props) $$invalidate(20, data = $$props.data);
    		if ("height" in $$props) $$invalidate(21, height = $$props.height);
    		if ("layout" in $$props) $$invalidate(22, layout = $$props.layout);
    		if ("rowClick" in $$props) $$invalidate(23, rowClick = $$props.rowClick);
    		if ("rowDblClick" in $$props) $$invalidate(24, rowDblClick = $$props.rowDblClick);
    		if ("loading" in $$props) $$invalidate(0, loading = $$props.loading);
    		if ("rowFormatter" in $$props) $$invalidate(25, rowFormatter = $$props.rowFormatter);
    		if ("cssClass" in $$props) $$invalidate(1, cssClass = $$props.cssClass);
    		if ("index" in $$props) $$invalidate(26, index = $$props.index);
    		if ("exportFileName" in $$props) $$invalidate(27, exportFileName = $$props.exportFileName);
    		if ("showHeader" in $$props) $$invalidate(2, showHeader = $$props.showHeader);
    		if ("txtFormatter" in $$props) $$invalidate(28, txtFormatter = $$props.txtFormatter);
    		if ("htmlFormatter" in $$props) $$invalidate(29, htmlFormatter = $$props.htmlFormatter);
    		if ("el" in $$props) $$invalidate(4, el = $$props.el);
    		if ("table" in $$props) $$invalidate(30, table = $$props.table);
    		if ("searchText" in $$props) $$invalidate(5, searchText = $$props.searchText);
    		if ("activeRowId" in $$props) activeRowId = $$props.activeRowId;
    		if ("firstItem" in $$props) firstItem = $$props.firstItem;
    		if ("lastItem" in $$props) lastItem = $$props.lastItem;
    		if ("hits" in $$props) $$invalidate(6, hits = $$props.hits);
    		if ("gotoRowIndex" in $$props) $$invalidate(7, gotoRowIndex = $$props.gotoRowIndex);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*data, index*/ 68157440) {
    			// first and last items
    			firstItem = data.length > 0 && data[0][index];
    		}

    		if ($$self.$$.dirty[0] & /*data, index*/ 68157440) {
    			lastItem = data.length > 0 && data[data.length - 1][index];
    		}

    		if ($$self.$$.dirty[0] & /*table, data*/ 1074790400) {
    			table && table.replaceData(data);
    		}

    		if ($$self.$$.dirty[0] & /*table, columns*/ 1074266112) {
    			table && table.setColumns(columns);
    		}
    	};

    	$$invalidate(6, hits = []);
    	$$invalidate(7, gotoRowIndex = null);

    	return [
    		loading,
    		cssClass,
    		showHeader,
    		takeScreenShot,
    		el,
    		searchText,
    		hits,
    		gotoRowIndex,
    		config,
    		action,
    		search,
    		goDown,
    		goUp,
    		scrollToBottom,
    		scrollToTop,
    		copyTable,
    		exportCSV,
    		exportTXT,
    		exportHTML,
    		columns,
    		data,
    		height,
    		layout,
    		rowClick,
    		rowDblClick,
    		rowFormatter,
    		index,
    		exportFileName,
    		txtFormatter,
    		htmlFormatter,
    		table,
    		input_input_handler,
    		div1_binding
    	];
    }

    class Tabulator_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$6,
    			create_fragment$6,
    			safe_not_equal,
    			{
    				columns: 19,
    				data: 20,
    				height: 21,
    				layout: 22,
    				rowClick: 23,
    				rowDblClick: 24,
    				loading: 0,
    				rowFormatter: 25,
    				cssClass: 1,
    				index: 26,
    				exportFileName: 27,
    				showHeader: 2,
    				txtFormatter: 28,
    				htmlFormatter: 29,
    				takeScreenShot: 3
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tabulator_1",
    			options,
    			id: create_fragment$6.name
    		});
    	}

    	get columns() {
    		throw new Error("<Tabulator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set columns(value) {
    		throw new Error("<Tabulator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get data() {
    		throw new Error("<Tabulator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Tabulator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Tabulator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Tabulator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get layout() {
    		throw new Error("<Tabulator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set layout(value) {
    		throw new Error("<Tabulator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rowClick() {
    		throw new Error("<Tabulator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rowClick(value) {
    		throw new Error("<Tabulator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rowDblClick() {
    		throw new Error("<Tabulator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rowDblClick(value) {
    		throw new Error("<Tabulator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error("<Tabulator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error("<Tabulator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rowFormatter() {
    		throw new Error("<Tabulator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rowFormatter(value) {
    		throw new Error("<Tabulator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cssClass() {
    		throw new Error("<Tabulator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cssClass(value) {
    		throw new Error("<Tabulator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get index() {
    		throw new Error("<Tabulator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<Tabulator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get exportFileName() {
    		throw new Error("<Tabulator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set exportFileName(value) {
    		throw new Error("<Tabulator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showHeader() {
    		throw new Error("<Tabulator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showHeader(value) {
    		throw new Error("<Tabulator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get txtFormatter() {
    		throw new Error("<Tabulator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set txtFormatter(value) {
    		throw new Error("<Tabulator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get htmlFormatter() {
    		throw new Error("<Tabulator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set htmlFormatter(value) {
    		throw new Error("<Tabulator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get takeScreenShot() {
    		return this.$$.ctx[3];
    	}

    	set takeScreenShot(value) {
    		throw new Error("<Tabulator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    let id = 1;

    function getId() {
      return `svelte-tabs-${id++}`;
    }

    /* src\SvelteTabs\Tabs.svelte generated by Svelte v3.38.2 */
    const file$5 = "src\\SvelteTabs\\Tabs.svelte";

    function create_fragment$5(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "svelte-tabs");
    			add_location(div, file$5, 102, 0, 2542);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "keydown", /*handleKeyDown*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const TABS = {};

    function removeAndUpdateSelected(arr, item, selectedStore) {
    	const index = arr.indexOf(item);
    	arr.splice(index, 1);

    	selectedStore.update(selected => selected === item
    	? arr[index] || arr[arr.length - 1]
    	: selected);
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $selectedTab;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Tabs", slots, ['default']);
    	let { selectedTabIndex = 0 } = $$props;
    	const tabElements = [];
    	const tabs = [];
    	const panels = [];
    	const controls = writable({});
    	const labeledBy = writable({});
    	const selectedTab = writable(null);
    	validate_store(selectedTab, "selectedTab");
    	component_subscribe($$self, selectedTab, value => $$invalidate(5, $selectedTab = value));
    	const selectedPanel = writable(null);

    	function registerItem(arr, item, selectedStore) {
    		arr.push(item);
    		selectedStore.update(selected => selected || item);
    		onDestroy(() => removeAndUpdateSelected(arr, item, selectedStore));
    	}

    	function selectTab(tab) {
    		$$invalidate(2, selectedTabIndex = tabs.indexOf(tab));
    		selectedTab.set(tab);
    		selectedPanel.set(panels[selectedTabIndex]);
    	}

    	setContext(TABS, {
    		registerTab(tab) {
    			registerItem(tabs, tab, selectedTab);
    		},
    		registerTabElement(tabElement) {
    			tabElements.push(tabElement);
    		},
    		registerPanel(panel) {
    			registerItem(panels, panel, selectedPanel);
    		},
    		selectTab,
    		selectedTab,
    		selectedPanel,
    		controls,
    		labeledBy
    	});

    	onMount(() => {
    		selectTab(tabs[selectedTabIndex]);
    	});

    	afterUpdate(() => {
    		for (let i = 0; i < tabs.length; i++) {
    			controls.update(controlsData => ({
    				...controlsData,
    				[tabs[i].id]: panels[i].id
    			}));

    			labeledBy.update(labeledByData => ({
    				...labeledByData,
    				[panels[i].id]: tabs[i].id
    			}));
    		}
    	});

    	async function handleKeyDown(event) {
    		if (event.target.classList.contains("svelte-tabs__tab")) {
    			let selectedIndex = tabs.indexOf($selectedTab);

    			switch (event.key) {
    				case "ArrowRight":
    					selectedIndex += 1;
    					if (selectedIndex > tabs.length - 1) {
    						selectedIndex = 0;
    					}
    					selectTab(tabs[selectedIndex]);
    					tabElements[selectedIndex].focus();
    					break;
    				case "ArrowLeft":
    					selectedIndex -= 1;
    					if (selectedIndex < 0) {
    						selectedIndex = tabs.length - 1;
    					}
    					selectTab(tabs[selectedIndex]);
    					tabElements[selectedIndex].focus();
    			}
    		}
    	}

    	const writable_props = ["selectedTabIndex"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tabs> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("selectedTabIndex" in $$props) $$invalidate(2, selectedTabIndex = $$props.selectedTabIndex);
    		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		TABS,
    		afterUpdate,
    		setContext,
    		onDestroy,
    		onMount,
    		tick,
    		writable,
    		selectedTabIndex,
    		tabElements,
    		tabs,
    		panels,
    		controls,
    		labeledBy,
    		selectedTab,
    		selectedPanel,
    		removeAndUpdateSelected,
    		registerItem,
    		selectTab,
    		handleKeyDown,
    		$selectedTab
    	});

    	$$self.$inject_state = $$props => {
    		if ("selectedTabIndex" in $$props) $$invalidate(2, selectedTabIndex = $$props.selectedTabIndex);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*selectedTabIndex*/ 4) ;
    	};

    	return [selectedTab, handleKeyDown, selectedTabIndex, $$scope, slots];
    }

    class Tabs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { selectedTabIndex: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tabs",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get selectedTabIndex() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedTabIndex(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\SvelteTabs\Tab.svelte generated by Svelte v3.38.2 */
    const file$4 = "src\\SvelteTabs\\Tab.svelte";

    function create_fragment$4(ctx) {
    	let li;
    	let li_aria_controls_value;
    	let li_tabindex_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

    	const block = {
    		c: function create() {
    			li = element("li");
    			if (default_slot) default_slot.c();
    			attr_dev(li, "role", "tab");
    			attr_dev(li, "id", /*tab*/ ctx[3].id);
    			attr_dev(li, "aria-controls", li_aria_controls_value = /*$controls*/ ctx[2][/*tab*/ ctx[3].id]);
    			attr_dev(li, "aria-selected", /*isSelected*/ ctx[1]);
    			attr_dev(li, "tabindex", li_tabindex_value = /*isSelected*/ ctx[1] ? 0 : -1);
    			attr_dev(li, "class", "svelte-tabs__tab svelte-lg6f9k");
    			toggle_class(li, "svelte-tabs__selected", /*isSelected*/ ctx[1]);
    			add_location(li, file$4, 30, 0, 477);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (default_slot) {
    				default_slot.m(li, null);
    			}

    			/*li_binding*/ ctx[10](li);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(li, "click", /*click_handler*/ ctx[11], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*$controls*/ 4 && li_aria_controls_value !== (li_aria_controls_value = /*$controls*/ ctx[2][/*tab*/ ctx[3].id])) {
    				attr_dev(li, "aria-controls", li_aria_controls_value);
    			}

    			if (!current || dirty & /*isSelected*/ 2) {
    				attr_dev(li, "aria-selected", /*isSelected*/ ctx[1]);
    			}

    			if (!current || dirty & /*isSelected*/ 2 && li_tabindex_value !== (li_tabindex_value = /*isSelected*/ ctx[1] ? 0 : -1)) {
    				attr_dev(li, "tabindex", li_tabindex_value);
    			}

    			if (dirty & /*isSelected*/ 2) {
    				toggle_class(li, "svelte-tabs__selected", /*isSelected*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot) default_slot.d(detaching);
    			/*li_binding*/ ctx[10](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let $selectedTab;
    	let $controls;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Tab", slots, ['default']);
    	let tabEl;
    	const tab = { id: getId() };
    	const { registerTab, registerTabElement, selectTab, selectedTab, controls } = getContext(TABS);
    	validate_store(selectedTab, "selectedTab");
    	component_subscribe($$self, selectedTab, value => $$invalidate(7, $selectedTab = value));
    	validate_store(controls, "controls");
    	component_subscribe($$self, controls, value => $$invalidate(2, $controls = value));
    	let isSelected;
    	registerTab(tab);

    	onMount(async () => {
    		await tick();
    		registerTabElement(tabEl);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tab> was created with unknown prop '${key}'`);
    	});

    	function li_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			tabEl = $$value;
    			$$invalidate(0, tabEl);
    		});
    	}

    	const click_handler = () => selectTab(tab);

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		onMount,
    		tick,
    		getId,
    		TABS,
    		tabEl,
    		tab,
    		registerTab,
    		registerTabElement,
    		selectTab,
    		selectedTab,
    		controls,
    		isSelected,
    		$selectedTab,
    		$controls
    	});

    	$$self.$inject_state = $$props => {
    		if ("tabEl" in $$props) $$invalidate(0, tabEl = $$props.tabEl);
    		if ("isSelected" in $$props) $$invalidate(1, isSelected = $$props.isSelected);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$selectedTab*/ 128) {
    			$$invalidate(1, isSelected = $selectedTab === tab);
    		}
    	};

    	return [
    		tabEl,
    		isSelected,
    		$controls,
    		tab,
    		selectTab,
    		selectedTab,
    		controls,
    		$selectedTab,
    		$$scope,
    		slots,
    		li_binding,
    		click_handler
    	];
    }

    class Tab extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tab",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src\SvelteTabs\TabList.svelte generated by Svelte v3.38.2 */

    const file$3 = "src\\SvelteTabs\\TabList.svelte";

    function create_fragment$3(ctx) {
    	let ul;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			if (default_slot) default_slot.c();
    			attr_dev(ul, "role", "tablist");
    			attr_dev(ul, "class", "svelte-tabs__tab-list svelte-lp409l");
    			add_location(ul, file$3, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			if (default_slot) {
    				default_slot.m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TabList", slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TabList> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class TabList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabList",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src\SvelteTabs\TabPanel.svelte generated by Svelte v3.38.2 */
    const file$2 = "src\\SvelteTabs\\TabPanel.svelte";

    // (21:2) {#if $selectedPanel === panel}
    function create_if_block(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(21:2) {#if $selectedPanel === panel}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let div;
    	let div_aria_labelledby_value;
    	let current;
    	let if_block = /*$selectedPanel*/ ctx[1] === /*panel*/ ctx[2] && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "id", /*panel*/ ctx[2].id);
    			attr_dev(div, "aria-labelledby", div_aria_labelledby_value = /*$labeledBy*/ ctx[0][/*panel*/ ctx[2].id]);
    			attr_dev(div, "class", "svelte-tabs__tab-panel svelte-wi195k");
    			attr_dev(div, "role", "tabpanel");
    			add_location(div, file$2, 14, 0, 266);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$selectedPanel*/ ctx[1] === /*panel*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$selectedPanel*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*$labeledBy*/ 1 && div_aria_labelledby_value !== (div_aria_labelledby_value = /*$labeledBy*/ ctx[0][/*panel*/ ctx[2].id])) {
    				attr_dev(div, "aria-labelledby", div_aria_labelledby_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $labeledBy;
    	let $selectedPanel;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TabPanel", slots, ['default']);
    	const panel = { id: getId() };
    	const { registerPanel, selectedPanel, labeledBy } = getContext(TABS);
    	validate_store(selectedPanel, "selectedPanel");
    	component_subscribe($$self, selectedPanel, value => $$invalidate(1, $selectedPanel = value));
    	validate_store(labeledBy, "labeledBy");
    	component_subscribe($$self, labeledBy, value => $$invalidate(0, $labeledBy = value));
    	registerPanel(panel);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TabPanel> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		getId,
    		TABS,
    		panel,
    		registerPanel,
    		selectedPanel,
    		labeledBy,
    		$labeledBy,
    		$selectedPanel
    	});

    	return [$labeledBy, $selectedPanel, panel, selectedPanel, labeledBy, $$scope, slots];
    }

    class TabPanel extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabPanel",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* tests\SvelteTabs\index.svelte generated by Svelte v3.38.2 */
    const file$1 = "tests\\SvelteTabs\\index.svelte";

    // (7:4) <Tab>
    function create_default_slot_7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("One");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(7:4) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (8:4) <Tab>
    function create_default_slot_6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Two");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(8:4) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (9:4) <Tab>
    function create_default_slot_5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Three");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(9:4) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (6:2) <TabList>
    function create_default_slot_4(ctx) {
    	let tab0;
    	let t0;
    	let tab1;
    	let t1;
    	let tab2;
    	let current;

    	tab0 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tab1 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tab2 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tab0.$$.fragment);
    			t0 = space();
    			create_component(tab1.$$.fragment);
    			t1 = space();
    			create_component(tab2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tab0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tab1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tab2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tab0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tab0_changes.$$scope = { dirty, ctx };
    			}

    			tab0.$set(tab0_changes);
    			const tab1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tab1_changes.$$scope = { dirty, ctx };
    			}

    			tab1.$set(tab1_changes);
    			const tab2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tab2_changes.$$scope = { dirty, ctx };
    			}

    			tab2.$set(tab2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab0.$$.fragment, local);
    			transition_in(tab1.$$.fragment, local);
    			transition_in(tab2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab0.$$.fragment, local);
    			transition_out(tab1.$$.fragment, local);
    			transition_out(tab2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tab0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tab1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tab2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(6:2) <TabList>",
    		ctx
    	});

    	return block;
    }

    // (12:2) <TabPanel>
    function create_default_slot_3(ctx) {
    	let div;
    	let h2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h2 = element("h2");
    			h2.textContent = "Panel One";
    			add_location(h2, file$1, 13, 6, 246);
    			attr_dev(div, "class", "p-2");
    			add_location(div, file$1, 12, 4, 221);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h2);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(12:2) <TabPanel>",
    		ctx
    	});

    	return block;
    }

    // (18:2) <TabPanel>
    function create_default_slot_2(ctx) {
    	let div;
    	let h2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h2 = element("h2");
    			h2.textContent = "Panel Two";
    			add_location(h2, file$1, 19, 6, 338);
    			attr_dev(div, "class", "p-2");
    			add_location(div, file$1, 18, 4, 313);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h2);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(18:2) <TabPanel>",
    		ctx
    	});

    	return block;
    }

    // (24:2) <TabPanel>
    function create_default_slot_1(ctx) {
    	let div;
    	let h2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h2 = element("h2");
    			h2.textContent = "Panel Three";
    			add_location(h2, file$1, 25, 6, 430);
    			attr_dev(div, "class", "p-2");
    			add_location(div, file$1, 24, 4, 405);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h2);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(24:2) <TabPanel>",
    		ctx
    	});

    	return block;
    }

    // (5:0) <Tabs>
    function create_default_slot(ctx) {
    	let tablist;
    	let t0;
    	let tabpanel0;
    	let t1;
    	let tabpanel1;
    	let t2;
    	let tabpanel2;
    	let current;

    	tablist = new TabList({
    			props: {
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabpanel0 = new TabPanel({
    			props: {
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabpanel1 = new TabPanel({
    			props: {
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabpanel2 = new TabPanel({
    			props: {
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tablist.$$.fragment);
    			t0 = space();
    			create_component(tabpanel0.$$.fragment);
    			t1 = space();
    			create_component(tabpanel1.$$.fragment);
    			t2 = space();
    			create_component(tabpanel2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tablist, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tabpanel0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tabpanel1, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(tabpanel2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tablist_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tablist_changes.$$scope = { dirty, ctx };
    			}

    			tablist.$set(tablist_changes);
    			const tabpanel0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tabpanel0_changes.$$scope = { dirty, ctx };
    			}

    			tabpanel0.$set(tabpanel0_changes);
    			const tabpanel1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tabpanel1_changes.$$scope = { dirty, ctx };
    			}

    			tabpanel1.$set(tabpanel1_changes);
    			const tabpanel2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tabpanel2_changes.$$scope = { dirty, ctx };
    			}

    			tabpanel2.$set(tabpanel2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tablist.$$.fragment, local);
    			transition_in(tabpanel0.$$.fragment, local);
    			transition_in(tabpanel1.$$.fragment, local);
    			transition_in(tabpanel2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tablist.$$.fragment, local);
    			transition_out(tabpanel0.$$.fragment, local);
    			transition_out(tabpanel1.$$.fragment, local);
    			transition_out(tabpanel2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tablist, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tabpanel0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tabpanel1, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(tabpanel2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(5:0) <Tabs>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let tabs;
    	let current;

    	tabs = new Tabs({
    			props: {
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tabs.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(tabs, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tabs_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tabs_changes.$$scope = { dirty, ctx };
    			}

    			tabs.$set(tabs_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabs.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabs.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tabs, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SvelteTabs", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SvelteTabs> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Tabs, Tab, TabList, TabPanel });
    	return [];
    }

    class SvelteTabs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SvelteTabs",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    var name = "svelte-rodry-common";
    var svelte = "src/index.js";
    var module = "dist/index.mjs";
    var main = "dist/index.js";
    var version = "1.1.0";
    var scripts = {
    	build: "rollup -c",
    	prepublishOnly: "npm run build",
    	dev: "rollup -c rollup.config.dev.js -w",
    	start: "sirv public"
    };
    var devDependencies = {
    	"@rollup/plugin-commonjs": "^17.1.0",
    	"@rollup/plugin-json": "^4.1.0",
    	"@rollup/plugin-node-resolve": "^11.2.0",
    	html2canvas: "^1.0.0-rc.7",
    	rollup: "^2.40.0",
    	"rollup-plugin-css-only": "^3.1.0",
    	"rollup-plugin-livereload": "^2.0.0",
    	"rollup-plugin-node-polyfills": "^0.2.1",
    	"rollup-plugin-serve": "^1.1.0",
    	"rollup-plugin-svelte": "^7.1.0",
    	"sirv-cli": "^1.0.11",
    	svelte: "^3.34.0",
    	"tabulator-tables": "^4.9.3",
    	tailwindcss: "^2.0.3"
    };
    var keywords = [
    	"svelte"
    ];
    var files = [
    	"src",
    	"dist"
    ];
    var pkg = {
    	name: name,
    	svelte: svelte,
    	module: module,
    	main: main,
    	version: version,
    	scripts: scripts,
    	devDependencies: devDependencies,
    	keywords: keywords,
    	files: files
    };

    /* tests\App.svelte generated by Svelte v3.38.2 */
    const file = "tests\\App.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (322:8) 
    function create_title_slot(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Modal Title";
    			attr_dev(div, "slot", "title");
    			attr_dev(div, "class", "svelte-g1xzir");
    			add_location(div, file, 321, 8, 7548);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot.name,
    		type: "slot",
    		source: "(322:8) ",
    		ctx
    	});

    	return block;
    }

    // (323:8) 
    function create_body_slot(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Modal Body";
    			attr_dev(div, "slot", "body");
    			attr_dev(div, "class", "svelte-g1xzir");
    			add_location(div, file, 322, 8, 7593);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot.name,
    		type: "slot",
    		source: "(323:8) ",
    		ctx
    	});

    	return block;
    }

    // (324:8) 
    function create_footer_slot(ctx) {
    	let div;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			button.textContent = "Close";
    			attr_dev(button, "class", "svelte-g1xzir");
    			add_location(button, file, 324, 10, 7698);
    			attr_dev(div, "slot", "footer");
    			attr_dev(div, "class", "grid justify-items-end svelte-g1xzir");
    			add_location(div, file, 323, 8, 7636);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*toggleModal*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_footer_slot.name,
    		type: "slot",
    		source: "(324:8) ",
    		ctx
    	});

    	return block;
    }

    // (347:12) {#each selectedCountries as country}
    function create_each_block(ctx) {
    	let small;
    	let t0_value = /*country*/ ctx[11] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			small = element("small");
    			t0 = text(t0_value);
    			t1 = text(",");
    			attr_dev(small, "class", "svelte-g1xzir");
    			add_location(small, file, 347, 14, 8437);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, small, anchor);
    			append_dev(small, t0);
    			append_dev(small, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*selectedCountries*/ 4 && t0_value !== (t0_value = /*country*/ ctx[11] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(small);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(347:12) {#each selectedCountries as country}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let title_value;
    	let t0;
    	let main;
    	let h1;
    	let t5;
    	let h2;
    	let t7;
    	let section0;
    	let div0;
    	let h30;
    	let t9;
    	let button;
    	let t11;
    	let modal;
    	let t12;
    	let section1;
    	let div4;
    	let h31;
    	let t14;
    	let div3;
    	let label0;
    	let t15;
    	let multiselect;
    	let t16;
    	let div2;
    	let h5;
    	let t18;
    	let div1;
    	let t19;
    	let section2;
    	let div5;
    	let h32;
    	let t21;
    	let sveltetabs;
    	let t22;
    	let section3;
    	let div7;
    	let h33;
    	let t24;
    	let div6;
    	let treeview;
    	let t25;
    	let section4;
    	let div8;
    	let h34;
    	let t27;
    	let breadcrumbs;
    	let t28;
    	let hr;
    	let t29;
    	let div9;
    	let strong;
    	let t31;
    	let label1;
    	let input0;
    	let t32;
    	let t33;
    	let label2;
    	let input1;
    	let t34;
    	let t35;
    	let label3;
    	let input2;
    	let t36;
    	let t37;
    	let label4;
    	let input3;
    	let t38;
    	let t39;
    	let section5;
    	let div10;
    	let h35;
    	let t41;
    	let tabulator;
    	let current;
    	let mounted;
    	let dispose;
    	document.title = title_value = "" + (pkg.name + " (v" + pkg.version + ")");

    	modal = new Modal({
    			props: {
    				cssClass: "w-8/12",
    				show: /*showModal*/ ctx[1],
    				onClose: /*toggleModal*/ ctx[8],
    				$$slots: {
    					footer: [create_footer_slot],
    					body: [create_body_slot],
    					title: [create_title_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	multiselect = new MultiSelect({
    			props: {
    				items: /*items*/ ctx[7],
    				value: /*selectedCountries*/ ctx[2],
    				onChange: /*func*/ ctx[10]
    			},
    			$$inline: true
    		});

    	let each_value = /*selectedCountries*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	sveltetabs = new SvelteTabs({ $$inline: true });

    	treeview = new Treeview({
    			props: { items: /*treeviewItems*/ ctx[6] },
    			$$inline: true
    		});

    	breadcrumbs = new Breadcrumbs({
    			props: {
    				activeItem: /*activeCrumb*/ ctx[0],
    				items: /*crumbs*/ ctx[5]
    			},
    			$$inline: true
    		});

    	tabulator = new Tabulator_1({
    			props: {
    				columns: /*columns*/ ctx[3],
    				data: /*data*/ ctx[4],
    				height: "300",
    				showHeader: false
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			main = element("main");
    			h1 = element("h1");
    			h1.textContent = `${pkg.name} (v${pkg.version})`;
    			t5 = space();
    			h2 = element("h2");
    			h2.textContent = "Testing Playground";
    			t7 = space();
    			section0 = element("section");
    			div0 = element("div");
    			h30 = element("h3");
    			h30.textContent = "Modal";
    			t9 = space();
    			button = element("button");
    			button.textContent = "Show Modal";
    			t11 = space();
    			create_component(modal.$$.fragment);
    			t12 = space();
    			section1 = element("section");
    			div4 = element("div");
    			h31 = element("h3");
    			h31.textContent = "MultiSelect";
    			t14 = space();
    			div3 = element("div");
    			label0 = element("label");
    			t15 = text("Country List\r\n          ");
    			create_component(multiselect.$$.fragment);
    			t16 = space();
    			div2 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Items selected";
    			t18 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t19 = space();
    			section2 = element("section");
    			div5 = element("div");
    			h32 = element("h3");
    			h32.textContent = "Svelte Tabs";
    			t21 = space();
    			create_component(sveltetabs.$$.fragment);
    			t22 = space();
    			section3 = element("section");
    			div7 = element("div");
    			h33 = element("h3");
    			h33.textContent = "Treeview";
    			t24 = space();
    			div6 = element("div");
    			create_component(treeview.$$.fragment);
    			t25 = space();
    			section4 = element("section");
    			div8 = element("div");
    			h34 = element("h3");
    			h34.textContent = "Breadcrumbs";
    			t27 = space();
    			create_component(breadcrumbs.$$.fragment);
    			t28 = space();
    			hr = element("hr");
    			t29 = space();
    			div9 = element("div");
    			strong = element("strong");
    			strong.textContent = "Set active crumb:";
    			t31 = space();
    			label1 = element("label");
    			input0 = element("input");
    			t32 = text(" Main");
    			t33 = space();
    			label2 = element("label");
    			input1 = element("input");
    			t34 = text(" Queries");
    			t35 = space();
    			label3 = element("label");
    			input2 = element("input");
    			t36 = text(" Orders Search");
    			t37 = space();
    			label4 = element("label");
    			input3 = element("input");
    			t38 = text(" Clear");
    			t39 = space();
    			section5 = element("section");
    			div10 = element("div");
    			h35 = element("h3");
    			h35.textContent = "Tabulator";
    			t41 = space();
    			create_component(tabulator.$$.fragment);
    			attr_dev(h1, "class", "text-center svelte-g1xzir");
    			add_location(h1, file, 311, 2, 7207);
    			attr_dev(h2, "class", "svelte-g1xzir");
    			add_location(h2, file, 312, 2, 7267);
    			attr_dev(h30, "class", "svelte-g1xzir");
    			add_location(h30, file, 316, 6, 7390);
    			attr_dev(button, "class", "svelte-g1xzir");
    			add_location(button, file, 318, 6, 7414);
    			attr_dev(div0, "class", "rounded border border-gray-200 p-2 shadow svelte-g1xzir");
    			add_location(div0, file, 315, 4, 7327);
    			attr_dev(section0, "class", "p-2 svelte-g1xzir");
    			add_location(section0, file, 314, 2, 7300);
    			attr_dev(h31, "class", "svelte-g1xzir");
    			add_location(h31, file, 333, 6, 7921);
    			attr_dev(label0, "for", "country-list");
    			attr_dev(label0, "class", "svelte-g1xzir");
    			add_location(label0, file, 335, 8, 7993);
    			attr_dev(h5, "class", "px-2 svelte-g1xzir");
    			add_location(h5, file, 344, 10, 8286);
    			attr_dev(div1, "class", "px-2 h-20 overflow-auto svelte-g1xzir");
    			add_location(div1, file, 345, 10, 8334);
    			attr_dev(div2, "class", " rounded bg-gray-200 w-6/12  svelte-g1xzir");
    			add_location(div2, file, 343, 8, 8232);
    			attr_dev(div3, "class", "flex justify-between svelte-g1xzir");
    			add_location(div3, file, 334, 6, 7949);
    			attr_dev(div4, "class", "rounded border border-gray-200 p-2 shadow svelte-g1xzir");
    			add_location(div4, file, 332, 4, 7858);
    			attr_dev(section1, "class", "p-2 svelte-g1xzir");
    			add_location(section1, file, 331, 2, 7831);
    			attr_dev(h32, "class", "svelte-g1xzir");
    			add_location(h32, file, 358, 6, 8677);
    			attr_dev(div5, "class", "rounded border border-gray-200 p-2 shadow svelte-g1xzir");
    			add_location(div5, file, 357, 4, 8614);
    			attr_dev(section2, "class", "p-2 svelte-g1xzir");
    			add_location(section2, file, 356, 2, 8587);
    			attr_dev(h33, "class", "svelte-g1xzir");
    			add_location(h33, file, 366, 6, 8862);
    			attr_dev(div6, "class", "w-3/12 bg-gray-200 p-2 svelte-g1xzir");
    			add_location(div6, file, 367, 6, 8887);
    			attr_dev(div7, "class", "rounded border border-gray-200 p-2 shadow svelte-g1xzir");
    			add_location(div7, file, 365, 4, 8799);
    			attr_dev(section3, "class", "p-2 svelte-g1xzir");
    			add_location(section3, file, 364, 2, 8772);
    			attr_dev(h34, "class", "svelte-g1xzir");
    			add_location(h34, file, 376, 6, 9127);
    			attr_dev(div8, "class", "rounded border border-gray-200 p-2 shadow svelte-g1xzir");
    			add_location(div8, file, 375, 4, 9064);
    			attr_dev(hr, "class", "svelte-g1xzir");
    			add_location(hr, file, 379, 4, 9228);
    			attr_dev(strong, "class", "svelte-g1xzir");
    			add_location(strong, file, 381, 6, 9276);
    			attr_dev(input0, "id", "crumb-main");
    			attr_dev(input0, "type", "radio");
    			attr_dev(input0, "name", "activeCrumb");
    			input0.value = "main";
    			attr_dev(input0, "class", "svelte-g1xzir");
    			add_location(input0, file, 383, 8, 9352);
    			attr_dev(label1, "for", "crumb-main");
    			attr_dev(label1, "class", "svelte-g1xzir");
    			add_location(label1, file, 382, 6, 9318);
    			attr_dev(input1, "id", "crumb-queries");
    			attr_dev(input1, "type", "radio");
    			attr_dev(input1, "name", "activeCrumb");
    			input1.value = "queries";
    			attr_dev(input1, "class", "svelte-g1xzir");
    			add_location(input1, file, 392, 8, 9579);
    			attr_dev(label2, "for", "crumb-queries");
    			attr_dev(label2, "class", "svelte-g1xzir");
    			add_location(label2, file, 391, 6, 9542);
    			attr_dev(input2, "id", "crumb-order-search");
    			attr_dev(input2, "type", "radio");
    			attr_dev(input2, "name", "activeCrumb");
    			input2.value = "order-search";
    			attr_dev(input2, "class", "svelte-g1xzir");
    			add_location(input2, file, 401, 8, 9820);
    			attr_dev(label3, "for", "crumb-order-search");
    			attr_dev(label3, "class", "svelte-g1xzir");
    			add_location(label3, file, 400, 6, 9778);
    			attr_dev(input3, "id", "crumb-clear");
    			attr_dev(input3, "type", "radio");
    			attr_dev(input3, "name", "activeCrumb");
    			input3.value = "";
    			attr_dev(input3, "class", "svelte-g1xzir");
    			add_location(input3, file, 410, 8, 10088);
    			attr_dev(label4, "for", "crumb-clear");
    			set_style(label4, "color", "red");
    			attr_dev(label4, "class", "svelte-g1xzir");
    			add_location(label4, file, 409, 6, 10035);
    			attr_dev(div9, "class", "flex space-x-4 svelte-g1xzir");
    			add_location(div9, file, 380, 4, 9240);
    			attr_dev(section4, "class", "p-2 svelte-g1xzir");
    			add_location(section4, file, 374, 2, 9037);
    			attr_dev(h35, "class", "svelte-g1xzir");
    			add_location(h35, file, 424, 6, 10412);
    			attr_dev(div10, "class", "rounded border border-gray-200 p-2 shadow svelte-g1xzir");
    			add_location(div10, file, 423, 4, 10349);
    			attr_dev(section5, "class", "p-2 svelte-g1xzir");
    			add_location(section5, file, 422, 2, 10322);
    			attr_dev(main, "class", "w-full svelte-g1xzir");
    			add_location(main, file, 310, 0, 7182);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			append_dev(main, h1);
    			append_dev(main, t5);
    			append_dev(main, h2);
    			append_dev(main, t7);
    			append_dev(main, section0);
    			append_dev(section0, div0);
    			append_dev(div0, h30);
    			append_dev(div0, t9);
    			append_dev(div0, button);
    			append_dev(div0, t11);
    			mount_component(modal, div0, null);
    			append_dev(main, t12);
    			append_dev(main, section1);
    			append_dev(section1, div4);
    			append_dev(div4, h31);
    			append_dev(div4, t14);
    			append_dev(div4, div3);
    			append_dev(div3, label0);
    			append_dev(label0, t15);
    			mount_component(multiselect, label0, null);
    			append_dev(div3, t16);
    			append_dev(div3, div2);
    			append_dev(div2, h5);
    			append_dev(div2, t18);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(main, t19);
    			append_dev(main, section2);
    			append_dev(section2, div5);
    			append_dev(div5, h32);
    			append_dev(div5, t21);
    			mount_component(sveltetabs, div5, null);
    			append_dev(main, t22);
    			append_dev(main, section3);
    			append_dev(section3, div7);
    			append_dev(div7, h33);
    			append_dev(div7, t24);
    			append_dev(div7, div6);
    			mount_component(treeview, div6, null);
    			append_dev(main, t25);
    			append_dev(main, section4);
    			append_dev(section4, div8);
    			append_dev(div8, h34);
    			append_dev(div8, t27);
    			mount_component(breadcrumbs, div8, null);
    			append_dev(section4, t28);
    			append_dev(section4, hr);
    			append_dev(section4, t29);
    			append_dev(section4, div9);
    			append_dev(div9, strong);
    			append_dev(div9, t31);
    			append_dev(div9, label1);
    			append_dev(label1, input0);
    			append_dev(label1, t32);
    			append_dev(div9, t33);
    			append_dev(div9, label2);
    			append_dev(label2, input1);
    			append_dev(label2, t34);
    			append_dev(div9, t35);
    			append_dev(div9, label3);
    			append_dev(label3, input2);
    			append_dev(label3, t36);
    			append_dev(div9, t37);
    			append_dev(div9, label4);
    			append_dev(label4, input3);
    			append_dev(label4, t38);
    			append_dev(main, t39);
    			append_dev(main, section5);
    			append_dev(section5, div10);
    			append_dev(div10, h35);
    			append_dev(div10, t41);
    			mount_component(tabulator, div10, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*toggleModal*/ ctx[8], false, false, false),
    					listen_dev(input0, "change", /*setActiveCrumb*/ ctx[9], false, false, false),
    					listen_dev(input1, "change", /*setActiveCrumb*/ ctx[9], false, false, false),
    					listen_dev(input2, "change", /*setActiveCrumb*/ ctx[9], false, false, false),
    					listen_dev(input3, "change", /*setActiveCrumb*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*pkg*/ 0) && title_value !== (title_value = "" + (pkg.name + " (v" + pkg.version + ")"))) {
    				document.title = title_value;
    			}

    			const modal_changes = {};
    			if (dirty & /*showModal*/ 2) modal_changes.show = /*showModal*/ ctx[1];

    			if (dirty & /*$$scope*/ 16384) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			modal.$set(modal_changes);
    			const multiselect_changes = {};
    			if (dirty & /*selectedCountries*/ 4) multiselect_changes.value = /*selectedCountries*/ ctx[2];
    			if (dirty & /*selectedCountries*/ 4) multiselect_changes.onChange = /*func*/ ctx[10];
    			multiselect.$set(multiselect_changes);

    			if (dirty & /*selectedCountries*/ 4) {
    				each_value = /*selectedCountries*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			const breadcrumbs_changes = {};
    			if (dirty & /*activeCrumb*/ 1) breadcrumbs_changes.activeItem = /*activeCrumb*/ ctx[0];
    			breadcrumbs.$set(breadcrumbs_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			transition_in(multiselect.$$.fragment, local);
    			transition_in(sveltetabs.$$.fragment, local);
    			transition_in(treeview.$$.fragment, local);
    			transition_in(breadcrumbs.$$.fragment, local);
    			transition_in(tabulator.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			transition_out(multiselect.$$.fragment, local);
    			transition_out(sveltetabs.$$.fragment, local);
    			transition_out(treeview.$$.fragment, local);
    			transition_out(breadcrumbs.$$.fragment, local);
    			transition_out(tabulator.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(modal);
    			destroy_component(multiselect);
    			destroy_each(each_blocks, detaching);
    			destroy_component(sveltetabs);
    			destroy_component(treeview);
    			destroy_component(breadcrumbs);
    			destroy_component(tabulator);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("App", slots, []);
    	let activeCrumb = "main";

    	const columns = [
    		{ title: "TestID", field: "testid" },
    		{
    			title: "Test Name",
    			field: "test_name",
    			headerFilter: "input"
    		},
    		{
    			title: "Sample Type",
    			field: "sample_type"
    		}
    	];

    	const data = [
    		{
    			testid: 1001,
    			test_name: "Glucose",
    			sample_type: "Plasma"
    		},
    		{
    			testid: 1002,
    			test_name: "Creatine",
    			sample_type: "Serum"
    		},
    		{
    			testid: 1003,
    			test_name: "HDL",
    			sample_type: "Serum"
    		},
    		{
    			testid: 1004,
    			test_name: "LDL",
    			sample_type: "Serum"
    		},
    		{
    			testid: 1001,
    			test_name: "Glucose",
    			sample_type: "Plasma"
    		},
    		{
    			testid: 1002,
    			test_name: "Creatine",
    			sample_type: "Serum"
    		},
    		{
    			testid: 1003,
    			test_name: "HDL",
    			sample_type: "Serum"
    		},
    		{
    			testid: 1004,
    			test_name: "LDL",
    			sample_type: "Serum"
    		},
    		{
    			testid: 1001,
    			test_name: "Glucose",
    			sample_type: "Plasma"
    		},
    		{
    			testid: 1002,
    			test_name: "Creatine",
    			sample_type: "Serum"
    		},
    		{
    			testid: 1003,
    			test_name: "HDL",
    			sample_type: "Serum"
    		},
    		{
    			testid: 1004,
    			test_name: "LDL",
    			sample_type: "Serum"
    		},
    		{
    			testid: 1001,
    			test_name: "Glucose",
    			sample_type: "Plasma"
    		},
    		{
    			testid: 1002,
    			test_name: "Creatine",
    			sample_type: "Serum"
    		},
    		{
    			testid: 1003,
    			test_name: "HDL",
    			sample_type: "Serum"
    		},
    		{
    			testid: 1004,
    			test_name: "LDL",
    			sample_type: "Serum"
    		},
    		{
    			testid: 1001,
    			test_name: "Glucose",
    			sample_type: "Plasma"
    		},
    		{
    			testid: 1002,
    			test_name: "Creatine",
    			sample_type: "Serum"
    		},
    		{
    			testid: 1003,
    			test_name: "HDL",
    			sample_type: "Serum"
    		},
    		{
    			testid: 1004,
    			test_name: "LDL",
    			sample_type: "Serum"
    		},
    		{
    			testid: 1001,
    			test_name: "Glucose",
    			sample_type: "Plasma"
    		},
    		{
    			testid: 1002,
    			test_name: "Creatine",
    			sample_type: "Serum"
    		},
    		{
    			testid: 1003,
    			test_name: "HDL",
    			sample_type: "Serum"
    		},
    		{
    			testid: 1004,
    			test_name: "LDL",
    			sample_type: "Serum"
    		}
    	];

    	const crumbs = [
    		{ id: "main", label: "Main", url: "#/main" },
    		{
    			id: "queries",
    			label: "Queries",
    			url: "#/main/queries"
    		},
    		{
    			id: "order-search",
    			label: "Order Search",
    			url: "#/main/queries/order-search"
    		}
    	];

    	const treeviewItems = [
    		{
    			title: "Main",
    			url: "#/main",
    			children: [
    				{
    					title: "Order Entry",
    					url: "#/order-entry"
    				},
    				{
    					title: "Queries",
    					url: "#/main/queries",
    					children: [
    						{
    							title: "Order Search",
    							url: "#/main/queries/order-search"
    						},
    						{
    							title: "Patient Search",
    							url: "#/main/queries/patient-search"
    						}
    					]
    				}
    			]
    		},
    		{
    			title: "Administration",
    			url: "#/administration",
    			children: [
    				{
    					title: "Test",
    					url: "#/administration/tests"
    				},
    				{
    					title: "Users",
    					url: "#/administration/users"
    				},
    				{ title: "QC", url: "#/administration/qc" },
    				{
    					title: "ICA",
    					url: "#/administration/ica"
    				}
    			]
    		},
    		{ title: "Monitoring", url: "#/monitoring" }
    	];

    	let showModal = false;

    	const items = [
    		"Afghanistan",
    		"Albania",
    		"Algeria",
    		"Andorra",
    		"Angola",
    		"Anguilla",
    		"Antigua & Barbuda",
    		"Argentina",
    		"Armenia",
    		"Aruba",
    		"Australia",
    		"Austria",
    		"Azerbaijan",
    		"Bahamas",
    		"Bahrain",
    		"Bangladesh",
    		"Barbados",
    		"Belarus",
    		"Belgium",
    		"Belize",
    		"Benin",
    		"Bermuda",
    		"Bhutan",
    		"Bolivia",
    		"Bosnia &amp; Herzegovina",
    		"Botswana",
    		"Brazil",
    		"British Virgin Islands",
    		"Brunei",
    		"Bulgaria",
    		"Burkina Faso",
    		"Burundi",
    		"Cambodia",
    		"Cameroon",
    		"Cape Verde",
    		"Cayman Islands",
    		"Chad",
    		"Chile",
    		"China",
    		"Colombia",
    		"Congo",
    		"Cook Islands",
    		"Costa Rica",
    		"Cote D Ivoire",
    		"Croatia",
    		"Cruise Ship",
    		"Cuba",
    		"Cyprus",
    		"Czech Republic",
    		"Denmark",
    		"Djibouti",
    		"Dominica",
    		"Dominican Republic",
    		"Ecuador",
    		"Egypt",
    		"El Salvador",
    		"Equatorial Guinea",
    		"Estonia",
    		"Ethiopia",
    		"Falkland Islands",
    		"Faroe Islands",
    		"Fiji",
    		"Finland",
    		"France",
    		"French Polynesia",
    		"French West Indies",
    		"Gabon",
    		"Gambia",
    		"Georgia",
    		"Germany",
    		"Ghana",
    		"Gibraltar",
    		"Greece",
    		"Greenland",
    		"Grenada",
    		"Guam",
    		"Guatemala",
    		"Guernsey",
    		"Guinea",
    		"Guinea Bissau",
    		"Guyana",
    		"Haiti",
    		"Honduras",
    		"Hong Kong",
    		"Hungary",
    		"Iceland",
    		"India",
    		"Indonesia",
    		"Iran",
    		"Iraq",
    		"Ireland",
    		"Isle of Man",
    		"Israel",
    		"Italy",
    		"Jamaica",
    		"Japan",
    		"Jersey",
    		"Jordan",
    		"Kazakhstan",
    		"Kenya",
    		"Kuwait",
    		"Kyrgyz Republic",
    		"Laos",
    		"Latvia",
    		"Lebanon",
    		"Lesotho",
    		"Liberia",
    		"Libya",
    		"Liechtenstein",
    		"Lithuania",
    		"Luxembourg",
    		"Macau",
    		"Macedonia",
    		"Madagascar",
    		"Malawi",
    		"Malaysia",
    		"Maldives",
    		"Mali",
    		"Malta",
    		"Mauritania",
    		"Mauritius",
    		"Mexico",
    		"Moldova",
    		"Monaco",
    		"Mongolia",
    		"Montenegro",
    		"Montserrat",
    		"Morocco",
    		"Mozambique",
    		"Namibia",
    		"Nepal",
    		"Netherlands",
    		"Netherlands Antilles",
    		"New Caledonia",
    		"New Zealand",
    		"Nicaragua",
    		"Niger",
    		"Nigeria",
    		"Norway",
    		"Oman",
    		"Pakistan",
    		"Palestine",
    		"Panama",
    		"Papua New Guinea",
    		"Paraguay",
    		"Peru",
    		"Philippines",
    		"Poland",
    		"Portugal",
    		"Puerto Rico",
    		"Qatar",
    		"Reunion",
    		"Romania",
    		"Russia",
    		"Rwanda",
    		"Saint Pierre &amp; Miquelon",
    		"Samoa",
    		"San Marino",
    		"Satellite",
    		"Saudi Arabia",
    		"Senegal",
    		"Serbia",
    		"Seychelles",
    		"Sierra Leone",
    		"Singapore",
    		"Slovakia",
    		"Slovenia",
    		"South Africa",
    		"South Korea",
    		"Spain",
    		"Sri Lanka",
    		"St Kitts &amp; Nevis",
    		"St Lucia",
    		"St Vincent",
    		"St. Lucia",
    		"Sudan",
    		"Suriname",
    		"Swaziland",
    		"Sweden",
    		"Switzerland",
    		"Syria",
    		"Taiwan",
    		"Tajikistan",
    		"Tanzania",
    		"Thailand",
    		"Timor L'Este",
    		"Togo",
    		"Tonga",
    		"Trinidad &amp; Tobago",
    		"Tunisia",
    		"Turkey",
    		"Turkmenistan",
    		"Turks &amp; Caicos",
    		"Uganda",
    		"Ukraine",
    		"United Arab Emirates",
    		"United Kingdom",
    		"Uruguay",
    		"United States of America",
    		"Uzbekistan",
    		"Venezuela",
    		"Vietnam",
    		"Virgin Islands (US)",
    		"Yemen",
    		"Zambia",
    		"Zimbabwe"
    	];

    	let selectedCountries = [];
    	const toggleModal = () => $$invalidate(1, showModal = !showModal);
    	const setActiveCrumb = e => $$invalidate(0, activeCrumb = e.target.value);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	const func = value => $$invalidate(2, selectedCountries = value);

    	$$self.$capture_state = () => ({
    		Modal,
    		Treeview,
    		Breadcrumbs,
    		Tabulator: Tabulator_1,
    		MultiSelect,
    		SvelteTabs,
    		activeCrumb,
    		columns,
    		data,
    		crumbs,
    		treeviewItems,
    		pkg,
    		showModal,
    		items,
    		selectedCountries,
    		toggleModal,
    		setActiveCrumb
    	});

    	$$self.$inject_state = $$props => {
    		if ("activeCrumb" in $$props) $$invalidate(0, activeCrumb = $$props.activeCrumb);
    		if ("showModal" in $$props) $$invalidate(1, showModal = $$props.showModal);
    		if ("selectedCountries" in $$props) $$invalidate(2, selectedCountries = $$props.selectedCountries);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		activeCrumb,
    		showModal,
    		selectedCountries,
    		columns,
    		data,
    		crumbs,
    		treeviewItems,
    		items,
    		toggleModal,
    		setActiveCrumb,
    		func
    	];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
      target: document.body,
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
